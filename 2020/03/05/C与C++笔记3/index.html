
<!DOCTYPE html>
<html lang="en" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>c与c++知识点(三) - Hexo</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="这是我自己在学习c++基础的过程中，顺便复习了下C语言，然后总结的一些小小知识点。—写在前面的话第一节1. C++内存分为四个区代码区  存放函数体的二进制代码全局区  存放全局变量和静态变量以及常,"> 
    <meta name="author" content="John Doe"> 
    <link rel="alternative" href="atom.xml" title="Hexo" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
    
<link rel="stylesheet" href="/css/diaspora.css">

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
<meta name="generator" content="Hexo 4.2.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">Hexo</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://yoursite.com"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">c与c++知识点(三)</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">c与c++知识点(三)</h1>
        <div class="stuff">
            <span>三月 05, 2020</span>
            

        </div>
        <div class="content markdown">
            <h3 id="这是我自己在学习c-基础的过程中，顺便复习了下C语言，然后总结的一些小小知识点。—写在前面的话"><a href="#这是我自己在学习c-基础的过程中，顺便复习了下C语言，然后总结的一些小小知识点。—写在前面的话" class="headerlink" title="这是我自己在学习c++基础的过程中，顺便复习了下C语言，然后总结的一些小小知识点。—写在前面的话"></a>这是我自己在学习c++基础的过程中，顺便复习了下C语言，然后总结的一些小小知识点。—写在前面的话</h3><h2 id="第一节"><a href="#第一节" class="headerlink" title="第一节"></a><em>第一节</em></h2><h4 id="1-C-内存分为四个区"><a href="#1-C-内存分为四个区" class="headerlink" title="1. C++内存分为四个区"></a>1. C++内存分为四个区</h4><h4 id="代码区-存放函数体的二进制代码"><a href="#代码区-存放函数体的二进制代码" class="headerlink" title="代码区  存放函数体的二进制代码"></a>代码区  存放函数体的二进制代码</h4><h4 id="全局区-存放全局变量和静态变量以及常量"><a href="#全局区-存放全局变量和静态变量以及常量" class="headerlink" title="全局区  存放全局变量和静态变量以及常量"></a>全局区  存放全局变量和静态变量以及常量</h4><h4 id="栈区-编译器自动分配-存放函数参数值-局部变量"><a href="#栈区-编译器自动分配-存放函数参数值-局部变量" class="headerlink" title="栈区     编译器自动分配 存放函数参数值 局部变量"></a>栈区     编译器自动分配 存放函数参数值 局部变量</h4><h4 id="堆区-程序员分配和释放，程序员不释放，程序结束时操作系统回收"><a href="#堆区-程序员分配和释放，程序员不释放，程序结束时操作系统回收" class="headerlink" title="堆区     程序员分配和释放，程序员不释放，程序结束时操作系统回收"></a>堆区     程序员分配和释放，程序员不释放，程序结束时操作系统回收</h4><h4 id="意义：不同区域存放的数据，赋予不同的生命中秋，给予更大的灵活编程"><a href="#意义：不同区域存放的数据，赋予不同的生命中秋，给予更大的灵活编程" class="headerlink" title="意义：不同区域存放的数据，赋予不同的生命中秋，给予更大的灵活编程"></a>意义：不同区域存放的数据，赋予不同的生命中秋，给予更大的灵活编程</h4><h4 id="2-代码区-（程序运行前就有）存放二进制机器指令-特点-共享、只读"><a href="#2-代码区-（程序运行前就有）存放二进制机器指令-特点-共享、只读" class="headerlink" title="2. 代码区  （程序运行前就有）存放二进制机器指令 特点 : 共享、只读"></a>2. 代码区  （程序运行前就有）存放二进制机器指令 特点 : 共享、只读</h4><h4 id="3-全局区-（程序运行前就有）存放全局变量和静态变量以及常量-该区的数据在程序结束后-由操作系统释放"><a href="#3-全局区-（程序运行前就有）存放全局变量和静态变量以及常量-该区的数据在程序结束后-由操作系统释放" class="headerlink" title="3. 全局区  （程序运行前就有）存放全局变量和静态变量以及常量  该区的数据在程序结束后#### 由操作系统释放"></a>3. 全局区  （程序运行前就有）存放全局变量和静态变量以及常量  该区的数据在程序结束后#### 由操作系统释放</h4><h4 id="在全局区（静态变量-static关键字-常量（字符串常量和const-修饰的全局变量））"><a href="#在全局区（静态变量-static关键字-常量（字符串常量和const-修饰的全局变量））" class="headerlink" title="在全局区（静态变量 static关键字  常量（字符串常量和const 修饰的全局变量））"></a>在全局区（静态变量 static关键字  常量（字符串常量和const 修饰的全局变量））</h4><h4 id="不在全局区的数据（局部常量）"><a href="#不在全局区的数据（局部常量）" class="headerlink" title="不在全局区的数据（局部常量）"></a>不在全局区的数据（局部常量）</h4><h4 id="4-栈区（程序运行后才有）不要返回局部变量的地址"><a href="#4-栈区（程序运行后才有）不要返回局部变量的地址" class="headerlink" title="4. 栈区（程序运行后才有）不要返回局部变量的地址"></a>4. 栈区（程序运行后才有）不要返回局部变量的地址</h4><h4 id="5-堆区-程序运行后才有）-程序员手动开辟和释放（delete））利用new关键字，将数据开辟到堆区-返回的直接是地址-int-p-new-int-10-指针本质在栈区，其数据在堆区"><a href="#5-堆区-程序运行后才有）-程序员手动开辟和释放（delete））利用new关键字，将数据开辟到堆区-返回的直接是地址-int-p-new-int-10-指针本质在栈区，其数据在堆区" class="headerlink" title="5. 堆区  (程序运行后才有）(程序员手动开辟和释放（delete））利用new关键字，将数据开辟到堆区  返回的直接是地址,  int * p = new int (10) ;  指针本质在栈区，其数据在堆区"></a>5. 堆区  (程序运行后才有）(程序员手动开辟和释放（delete））利用new关键字，将数据开辟到堆区  返回的直接是地址,  int * p = new int (10) ;  指针本质在栈区，其数据在堆区</h4><hr>
<h2 id="第二节"><a href="#第二节" class="headerlink" title="第二节"></a><em>第二节</em></h2><h4 id="1-new-返回的是该数据类型的指针-int-p-new-int-10-创建了一个new型为10的变量地址-释放-delete-p"><a href="#1-new-返回的是该数据类型的指针-int-p-new-int-10-创建了一个new型为10的变量地址-释放-delete-p" class="headerlink" title="1.new  返回的是该数据类型的指针  int * p=new int(10) ; 创建了一个new型为10的变量地址  (释放 delete p;)"></a>1.new  返回的是该数据类型的指针  int * p=new int(10) ; 创建了一个new型为10的变量地址  (释放 delete p;)</h4><h4 id="int-array-nem-int-10-创建了一个变量为整型个数为10的数组，他的首地址给了array-释放数组-delete-arr"><a href="#int-array-nem-int-10-创建了一个变量为整型个数为10的数组，他的首地址给了array-释放数组-delete-arr" class="headerlink" title="int * array = nem int[10]; 创建了一个变量为整型个数为10的数组，他的首地址给了array (释放数组  delete[] arr;)"></a>int * array = nem int[10]; 创建了一个变量为整型个数为10的数组，他的首地址给了array (释放数组  delete[] arr;)</h4><h4 id="2-引用-就是给变量起别名"><a href="#2-引用-就是给变量起别名" class="headerlink" title="2.  引用:  就是给变量起别名"></a>2.  引用:  就是给变量起别名</h4><h4 id="语法：数据类型-amp-别名-原名-对别名进行操作等于对原名的数据进行操作-int-a-10"><a href="#语法：数据类型-amp-别名-原名-对别名进行操作等于对原名的数据进行操作-int-a-10" class="headerlink" title="语法：数据类型 &amp;别名=原名   对别名进行操作等于对原名的数据进行操作  int a=10;"></a>语法：数据类型 &amp;别名=原名   对别名进行操作等于对原名的数据进行操作  int a=10;</h4><h4 id="Int-amp-b-a-b-20-那么-a也为20"><a href="#Int-amp-b-a-b-20-那么-a也为20" class="headerlink" title="Int  &amp; b = a; b = 20;  那么 a也为20"></a>Int  &amp; b = a; b = 20;  那么 a也为20</h4><h4 id="3-引用的注意事项"><a href="#3-引用的注意事项" class="headerlink" title="3.引用的注意事项"></a>3.引用的注意事项</h4><h4 id="1-引用的时候必须要给予初始化-int-amp-b-a-引用过程给予初始化，只有这一种写法"><a href="#1-引用的时候必须要给予初始化-int-amp-b-a-引用过程给予初始化，只有这一种写法" class="headerlink" title="1) 引用的时候必须要给予初始化  int &amp; b = a; (引用过程给予初始化，只有这一种写法)"></a>1) 引用的时候必须要给予初始化  int &amp; b = a; (引用过程给予初始化，只有这一种写法)</h4><h4 id="2-引用一旦初始化后，不可更改"><a href="#2-引用一旦初始化后，不可更改" class="headerlink" title="2) 引用一旦初始化后，不可更改"></a>2) 引用一旦初始化后，不可更改</h4><h4 id="4-引用也会使得形参修饰实参-void-my3-int-amp-a-int-amp-b-有两种解决办法-指针-和-引用"><a href="#4-引用也会使得形参修饰实参-void-my3-int-amp-a-int-amp-b-有两种解决办法-指针-和-引用" class="headerlink" title="4.  引用也会使得形参修饰实参  void my3(int &amp;a,int &amp;b)  有两种解决办法  指针 和 引用"></a>4.  引用也会使得形参修饰实参  void my3(int &amp;a,int &amp;b)  有两种解决办法  指针 和 引用</h4><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项:"></a>注意事项:</h4><h4 id="1-不要返回局部变量的引用int-amp-test-int-a-10-return-a"><a href="#1-不要返回局部变量的引用int-amp-test-int-a-10-return-a" class="headerlink" title="1 )不要返回局部变量的引用int &amp;test(){int a=10;return a;}"></a>1 )不要返回局部变量的引用int &amp;test(){int a=10;return a;}</h4><h4 id="2-函数的调用可以作为左值-int-amp-ref-test-test-100"><a href="#2-函数的调用可以作为左值-int-amp-ref-test-test-100" class="headerlink" title="2 )函数的调用可以作为左值 int &amp;ref=test();test()=100;"></a>2 )函数的调用可以作为左值 int &amp;ref=test();test()=100;</h4><h4 id="cout-lt-lt-ref-lt-lt-endl-ref-100"><a href="#cout-lt-lt-ref-lt-lt-endl-ref-100" class="headerlink" title="cout &lt;&lt; ref &lt;&lt; endl; ref = 100;"></a>cout &lt;&lt; ref &lt;&lt; endl; ref = 100;</h4><h4 id="5-引用的本质是一个指针常量-int-a-10"><a href="#5-引用的本质是一个指针常量-int-a-10" class="headerlink" title="5.引用的本质是一个指针常量  int a=10;"></a>5.引用的本质是一个指针常量  int a=10;</h4><h4 id="int-amp-b-a-相当于-int-const-b-a-这也就是为什么引用不可修改，因为指针常量的指针指向不可修改-b中保存着a的地址-。cout-lt-lt-a-lt-lt-b-lt-lt-endl-a-b-10"><a href="#int-amp-b-a-相当于-int-const-b-a-这也就是为什么引用不可修改，因为指针常量的指针指向不可修改-b中保存着a的地址-。cout-lt-lt-a-lt-lt-b-lt-lt-endl-a-b-10" class="headerlink" title="int &amp;b = a;相当于 int * const  b = &a;  这也就是为什么引用不可修改，因为指针常量的指针指向不可修改(b中保存着a的地址)。cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl; a = b = 10;"></a>int &amp;b = a;相当于 int * const  b = &a;  这也就是为什么引用不可修改，因为指针常量的指针指向不可修改(b中保存着a的地址)。cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl; a = b = 10;</h4><h4 id="b-20解引用-也就是-b-20"><a href="#b-20解引用-也就是-b-20" class="headerlink" title="b = 20解引用  也就是*b = 20;"></a>b = 20解引用  也就是*b = 20;</h4><hr>
<h2 id="第三节"><a href="#第三节" class="headerlink" title="第三节"></a><em>第三节</em></h2><h4 id="1-常量引用"><a href="#1-常量引用" class="headerlink" title="1.常量引用"></a>1.常量引用</h4><h4 id="引用的两种写法"><a href="#引用的两种写法" class="headerlink" title="引用的两种写法"></a>引用的两种写法</h4><h4 id="1-int-a-10；int-amp-b-a-必须为名称，不能为10"><a href="#1-int-a-10；int-amp-b-a-必须为名称，不能为10" class="headerlink" title="1 ) int a=10；int &amp; b = a(必须为名称，不能为10);"></a>1 ) int a=10；int &amp; b = a(必须为名称，不能为10);</h4><h4 id="2-const-int-amp-b-10-第二种相当于编译器系统设置了一个变量int-temp-10；const-int-amp-b-temp"><a href="#2-const-int-amp-b-10-第二种相当于编译器系统设置了一个变量int-temp-10；const-int-amp-b-temp" class="headerlink" title="2). const int &amp; b = 10;    第二种相当于编译器系统设置了一个变量int temp = 10；const int &amp;b = temp;"></a>2). const int &amp; b = 10;    第二种相当于编译器系统设置了一个变量int temp = 10；const int &amp;b = temp;</h4><h4 id="b-20-这是错误的，因为加上const-之后变为只读不可修改状态"><a href="#b-20-这是错误的，因为加上const-之后变为只读不可修改状态" class="headerlink" title="b = 20(这是错误的，因为加上const 之后变为只读不可修改状态)"></a>b = 20(这是错误的，因为加上const 之后变为只读不可修改状态)</h4><h4 id="2-函数默认参数-优先用户自定义的-int-fun-int-a-int-b-10-int-c-30-return-a-b-c"><a href="#2-函数默认参数-优先用户自定义的-int-fun-int-a-int-b-10-int-c-30-return-a-b-c" class="headerlink" title="2.函数默认参数 优先用户自定义的 int fun(int a,int b=10,int c=30){ return a+b+c;}"></a>2.函数默认参数 优先用户自定义的 int fun(int a,int b=10,int c=30){ return a+b+c;}</h4><h4 id="main-cout-lt-lt-fun-10-30-30-70-当某个位置有了默认参数，那么他后边都必须是默认参数-例如-b为默认参数，那么-c-也必须是默认参数"><a href="#main-cout-lt-lt-fun-10-30-30-70-当某个位置有了默认参数，那么他后边都必须是默认参数-例如-b为默认参数，那么-c-也必须是默认参数" class="headerlink" title="main{ cout &lt;&lt; fun (10 , 30 , 30 ) ; } 70; 当某个位置有了默认参数，那么他后边都必须是默认参数(例如 b为默认参数，那么 c 也必须是默认参数)"></a>main{ cout &lt;&lt; fun (10 , 30 , 30 ) ; } 70; 当某个位置有了默认参数，那么他后边都必须是默认参数(例如 b为默认参数，那么 c 也必须是默认参数)</h4><h4 id="3-声明和实现-只能有一个有默认参数-int-fun-int-a-10-int-b-30-int-fun-int-a-int-b-return-a-b-40"><a href="#3-声明和实现-只能有一个有默认参数-int-fun-int-a-10-int-b-30-int-fun-int-a-int-b-return-a-b-40" class="headerlink" title="3.  声明和实现 只能有一个有默认参数 int fun (int a = 10,int b = 30); int fun(int a , int b) {return a + b;}  40"></a>3.  声明和实现 只能有一个有默认参数 int fun (int a = 10,int b = 30); int fun(int a , int b) {return a + b;}  40</h4><h4 id="4-占位参数（只有函数类型，没有名字）-void-fun-int-a-int-cout-lt-lt-”-abc-”-引用时fun-10-10-占位参数还可以有默认参数void-fun-int-a-int-10-return-“-abc-”-引用时-fun-10"><a href="#4-占位参数（只有函数类型，没有名字）-void-fun-int-a-int-cout-lt-lt-”-abc-”-引用时fun-10-10-占位参数还可以有默认参数void-fun-int-a-int-10-return-“-abc-”-引用时-fun-10" class="headerlink" title="4. 占位参数（只有函数类型，没有名字） void fun ( int a , int){cout &lt;&lt; ” abc ” ; } 引用时fun(10 , 10)  占位参数还可以有默认参数void fun(int a , int  = 10)  {return “ abc ” ; } 引用时 fun( 10 ) ;"></a>4. 占位参数（只有函数类型，没有名字） void fun ( int a , int){cout &lt;&lt; ” abc ” ; } 引用时fun(10 , 10)  占位参数还可以有默认参数void fun(int a , int  = 10)  {return “ abc ” ; } 引用时 fun( 10 ) ;</h4><h4 id="5-函数重载-函数名可以相同"><a href="#5-函数重载-函数名可以相同" class="headerlink" title="5. 函数重载(函数名可以相同)"></a>5. 函数重载(函数名可以相同)</h4><h4 id="条件-同一个作用域下-函数名称相同-函数的参数类型不同-或者-个数不同或者顺序不同"><a href="#条件-同一个作用域下-函数名称相同-函数的参数类型不同-或者-个数不同或者顺序不同" class="headerlink" title="条件 : 同一个作用域下  函数名称相同  函数的参数类型不同 或者 个数不同或者顺序不同"></a>条件 : 同一个作用域下  函数名称相同  函数的参数类型不同 或者 个数不同或者顺序不同</h4><h4 id="注意：函数的返回值不可以作为函数重载的条件-void-fun-void-fun-int-a-void-fun-double-b"><a href="#注意：函数的返回值不可以作为函数重载的条件-void-fun-void-fun-int-a-void-fun-double-b" class="headerlink" title="注意：函数的返回值不可以作为函数重载的条件 void fun ( )  void fun(int a)     void fun(double b)"></a>注意：函数的返回值不可以作为函数重载的条件 void fun ( )  void fun(int a)     void fun(double b)</h4><hr>
<h4 id="未完待续…"><a href="#未完待续…" class="headerlink" title="未完待续…"></a>未完待续…</h4>
            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="true">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='https://link.hhtjim.com/163/438900437.mp3'></li>
                        
                    
                        
                            <li title='1' data-url='https://link.hhtjim.com/163/438900437.mp3'></li>
                        
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
		data-enable='false'
        data-ae='false'
        data-ci=''
        data-cs=''
        data-r=''
        data-o=''
        data-a=''
        data-d='false'
    >查看评论</div>


    </div>
    
        <div class='side'>
			<ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#这是我自己在学习c-基础的过程中，顺便复习了下C语言，然后总结的一些小小知识点。—写在前面的话"><span class="toc-number">1.</span> <span class="toc-text">这是我自己在学习c++基础的过程中，顺便复习了下C语言，然后总结的一些小小知识点。—写在前面的话</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第一节"><span class="toc-number"></span> <span class="toc-text">第一节</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-C-内存分为四个区"><span class="toc-number">0.1.</span> <span class="toc-text">1. C++内存分为四个区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#代码区-存放函数体的二进制代码"><span class="toc-number">0.2.</span> <span class="toc-text">代码区  存放函数体的二进制代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#全局区-存放全局变量和静态变量以及常量"><span class="toc-number">0.3.</span> <span class="toc-text">全局区  存放全局变量和静态变量以及常量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#栈区-编译器自动分配-存放函数参数值-局部变量"><span class="toc-number">0.4.</span> <span class="toc-text">栈区     编译器自动分配 存放函数参数值 局部变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#堆区-程序员分配和释放，程序员不释放，程序结束时操作系统回收"><span class="toc-number">0.5.</span> <span class="toc-text">堆区     程序员分配和释放，程序员不释放，程序结束时操作系统回收</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#意义：不同区域存放的数据，赋予不同的生命中秋，给予更大的灵活编程"><span class="toc-number">0.6.</span> <span class="toc-text">意义：不同区域存放的数据，赋予不同的生命中秋，给予更大的灵活编程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-代码区-（程序运行前就有）存放二进制机器指令-特点-共享、只读"><span class="toc-number">0.7.</span> <span class="toc-text">2. 代码区  （程序运行前就有）存放二进制机器指令 特点 : 共享、只读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-全局区-（程序运行前就有）存放全局变量和静态变量以及常量-该区的数据在程序结束后-由操作系统释放"><span class="toc-number">0.8.</span> <span class="toc-text">3. 全局区  （程序运行前就有）存放全局变量和静态变量以及常量  该区的数据在程序结束后#### 由操作系统释放</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#在全局区（静态变量-static关键字-常量（字符串常量和const-修饰的全局变量））"><span class="toc-number">0.9.</span> <span class="toc-text">在全局区（静态变量 static关键字  常量（字符串常量和const 修饰的全局变量））</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#不在全局区的数据（局部常量）"><span class="toc-number">0.10.</span> <span class="toc-text">不在全局区的数据（局部常量）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-栈区（程序运行后才有）不要返回局部变量的地址"><span class="toc-number">0.11.</span> <span class="toc-text">4. 栈区（程序运行后才有）不要返回局部变量的地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-堆区-程序运行后才有）-程序员手动开辟和释放（delete））利用new关键字，将数据开辟到堆区-返回的直接是地址-int-p-new-int-10-指针本质在栈区，其数据在堆区"><span class="toc-number">0.12.</span> <span class="toc-text">5. 堆区  (程序运行后才有）(程序员手动开辟和释放（delete））利用new关键字，将数据开辟到堆区  返回的直接是地址,  int * p &#x3D; new int (10) ;  指针本质在栈区，其数据在堆区</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第二节"><span class="toc-number"></span> <span class="toc-text">第二节</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-new-返回的是该数据类型的指针-int-p-new-int-10-创建了一个new型为10的变量地址-释放-delete-p"><span class="toc-number">0.1.</span> <span class="toc-text">1.new  返回的是该数据类型的指针  int * p&#x3D;new int(10) ; 创建了一个new型为10的变量地址  (释放 delete p;)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#int-array-nem-int-10-创建了一个变量为整型个数为10的数组，他的首地址给了array-释放数组-delete-arr"><span class="toc-number">0.2.</span> <span class="toc-text">int * array &#x3D; nem int[10]; 创建了一个变量为整型个数为10的数组，他的首地址给了array (释放数组  delete[] arr;)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-引用-就是给变量起别名"><span class="toc-number">0.3.</span> <span class="toc-text">2.  引用:  就是给变量起别名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#语法：数据类型-amp-别名-原名-对别名进行操作等于对原名的数据进行操作-int-a-10"><span class="toc-number">0.4.</span> <span class="toc-text">语法：数据类型 &amp;别名&#x3D;原名   对别名进行操作等于对原名的数据进行操作  int a&#x3D;10;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Int-amp-b-a-b-20-那么-a也为20"><span class="toc-number">0.5.</span> <span class="toc-text">Int  &amp; b &#x3D; a; b &#x3D; 20;  那么 a也为20</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-引用的注意事项"><span class="toc-number">0.6.</span> <span class="toc-text">3.引用的注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-引用的时候必须要给予初始化-int-amp-b-a-引用过程给予初始化，只有这一种写法"><span class="toc-number">0.7.</span> <span class="toc-text">1) 引用的时候必须要给予初始化  int &amp; b &#x3D; a; (引用过程给予初始化，只有这一种写法)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-引用一旦初始化后，不可更改"><span class="toc-number">0.8.</span> <span class="toc-text">2) 引用一旦初始化后，不可更改</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-引用也会使得形参修饰实参-void-my3-int-amp-a-int-amp-b-有两种解决办法-指针-和-引用"><span class="toc-number">0.9.</span> <span class="toc-text">4.  引用也会使得形参修饰实参  void my3(int &amp;a,int &amp;b)  有两种解决办法  指针 和 引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#注意事项"><span class="toc-number">0.10.</span> <span class="toc-text">注意事项:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-不要返回局部变量的引用int-amp-test-int-a-10-return-a"><span class="toc-number">0.11.</span> <span class="toc-text">1 )不要返回局部变量的引用int &amp;test(){int a&#x3D;10;return a;}</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-函数的调用可以作为左值-int-amp-ref-test-test-100"><span class="toc-number">0.12.</span> <span class="toc-text">2 )函数的调用可以作为左值 int &amp;ref&#x3D;test();test()&#x3D;100;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cout-lt-lt-ref-lt-lt-endl-ref-100"><span class="toc-number">0.13.</span> <span class="toc-text">cout &lt;&lt; ref &lt;&lt; endl; ref &#x3D; 100;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-引用的本质是一个指针常量-int-a-10"><span class="toc-number">0.14.</span> <span class="toc-text">5.引用的本质是一个指针常量  int a&#x3D;10;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#int-amp-b-a-相当于-int-const-b-a-这也就是为什么引用不可修改，因为指针常量的指针指向不可修改-b中保存着a的地址-。cout-lt-lt-a-lt-lt-b-lt-lt-endl-a-b-10"><span class="toc-number">0.15.</span> <span class="toc-text">int &amp;b &#x3D; a;相当于 int * const  b &#x3D; &amp;a;  这也就是为什么引用不可修改，因为指针常量的指针指向不可修改(b中保存着a的地址)。cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl; a &#x3D; b &#x3D; 10;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-20解引用-也就是-b-20"><span class="toc-number">0.16.</span> <span class="toc-text">b &#x3D; 20解引用  也就是*b &#x3D; 20;</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第三节"><span class="toc-number"></span> <span class="toc-text">第三节</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-常量引用"><span class="toc-number">0.1.</span> <span class="toc-text">1.常量引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#引用的两种写法"><span class="toc-number">0.2.</span> <span class="toc-text">引用的两种写法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-int-a-10；int-amp-b-a-必须为名称，不能为10"><span class="toc-number">0.3.</span> <span class="toc-text">1 ) int a&#x3D;10；int &amp; b &#x3D; a(必须为名称，不能为10);</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-const-int-amp-b-10-第二种相当于编译器系统设置了一个变量int-temp-10；const-int-amp-b-temp"><span class="toc-number">0.4.</span> <span class="toc-text">2). const int &amp; b &#x3D; 10;    第二种相当于编译器系统设置了一个变量int temp &#x3D; 10；const int &amp;b &#x3D; temp;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-20-这是错误的，因为加上const-之后变为只读不可修改状态"><span class="toc-number">0.5.</span> <span class="toc-text">b &#x3D; 20(这是错误的，因为加上const 之后变为只读不可修改状态)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-函数默认参数-优先用户自定义的-int-fun-int-a-int-b-10-int-c-30-return-a-b-c"><span class="toc-number">0.6.</span> <span class="toc-text">2.函数默认参数 优先用户自定义的 int fun(int a,int b&#x3D;10,int c&#x3D;30){ return a+b+c;}</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#main-cout-lt-lt-fun-10-30-30-70-当某个位置有了默认参数，那么他后边都必须是默认参数-例如-b为默认参数，那么-c-也必须是默认参数"><span class="toc-number">0.7.</span> <span class="toc-text">main{ cout &lt;&lt; fun (10 , 30 , 30 ) ; } 70; 当某个位置有了默认参数，那么他后边都必须是默认参数(例如 b为默认参数，那么 c 也必须是默认参数)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-声明和实现-只能有一个有默认参数-int-fun-int-a-10-int-b-30-int-fun-int-a-int-b-return-a-b-40"><span class="toc-number">0.8.</span> <span class="toc-text">3.  声明和实现 只能有一个有默认参数 int fun (int a &#x3D; 10,int b &#x3D; 30); int fun(int a , int b) {return a + b;}  40</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-占位参数（只有函数类型，没有名字）-void-fun-int-a-int-cout-lt-lt-”-abc-”-引用时fun-10-10-占位参数还可以有默认参数void-fun-int-a-int-10-return-“-abc-”-引用时-fun-10"><span class="toc-number">0.9.</span> <span class="toc-text">4. 占位参数（只有函数类型，没有名字） void fun ( int a , int){cout &lt;&lt; ” abc ” ; } 引用时fun(10 , 10)  占位参数还可以有默认参数void fun(int a , int  &#x3D; 10)  {return “ abc ” ; } 引用时 fun( 10 ) ;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-函数重载-函数名可以相同"><span class="toc-number">0.10.</span> <span class="toc-text">5. 函数重载(函数名可以相同)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#条件-同一个作用域下-函数名称相同-函数的参数类型不同-或者-个数不同或者顺序不同"><span class="toc-number">0.11.</span> <span class="toc-text">条件 : 同一个作用域下  函数名称相同  函数的参数类型不同 或者 个数不同或者顺序不同</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#注意：函数的返回值不可以作为函数重载的条件-void-fun-void-fun-int-a-void-fun-double-b"><span class="toc-number">0.12.</span> <span class="toc-text">注意：函数的返回值不可以作为函数重载的条件 void fun ( )  void fun(int a)     void fun(double b)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#未完待续…"><span class="toc-number">0.13.</span> <span class="toc-text">未完待续…</span></a></li></ol></li></ol>	
        </div>
    
</div>


    </div>
</div>
</body>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>






</html>
