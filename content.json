{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[{"title":"search","date":"2020-03-28T12:55:50.000Z","updated":"2020-03-28T12:56:19.471Z","comments":true,"path":"search/index.html","permalink":"http://yoursite.com/search/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-03-28T12:50:44.000Z","updated":"2020-03-29T03:25:06.161Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-03-28T12:52:27.000Z","updated":"2020-03-29T03:27:15.002Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"H-bの博客","slug":"H-bの博客","date":"2020-03-29T12:37:08.353Z","updated":"2020-03-29T12:37:08.353Z","comments":true,"path":"2020/03/29/H-bの博客/","link":"","permalink":"http://yoursite.com/2020/03/29/H-b%E3%81%AE%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"蓝桥杯基础","slug":"蓝桥杯基础","date":"2020-03-07T04:49:16.000Z","updated":"2020-03-30T13:57:26.344Z","comments":true,"path":"2020/03/07/蓝桥杯基础/","link":"","permalink":"http://yoursite.com/2020/03/07/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%9F%BA%E7%A1%80/","excerpt":"","text":"这是我自己在学习蓝桥杯过程中总结的一些知识，希望对今后的学习和备战蓝桥的同学能够提供一些帮助吧。必须要知道的知识1.1234567891011 void delayms(uint ms) // 15芯片延时一毫秒软件实现&#123; uint a; for(;ms&gt;0;ms--) &#123;for(a=845;a&gt;0;a--); &#125;&#125; 2.1234567891011121314void allinit(void) // 初始化关闭其他模块(led、继电器、蜂咛器、数码管)&#123; P2=0XA0; // 继电器，蜂咛器 P0=0X00; P2=0X80; // 小灯 P0=0XFF; P2=0XC0; // 段选 1~8 P0=0XFF; P2=0XFF; P0=0XFF;&#125; 3.123456789101112131415161718192021222324252627282930313233343536373839404142void keyscan(void ) // 独立按键 从上至下 S7 - S4 (P30 - P33)&#123;if(P30==0) &#123; delayms(5); if(P30==0) &#123; &#125; while(!P30); // 消抖操作 &#125;if(P31==0) &#123; delayms(5); if(P31==0) &#123; &#125; while(!P31); &#125; if(P32==0) &#123; delayms(5); if(P32==0) &#123; &#125; while(!P32); &#125; if(P33==0) &#123; delayms(5); if(P33==0) &#123; &#125; while(!P33); &#125;&#125; 4.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147void display16() // 矩阵按键(需要改变按键跳线帽) P37 = P44 P36 = P42 &#123;/**************************/ // 第1横行读取 P30=0; P31=P32=P33=1; // 从上至下(行) S7 - S4 (P30 - P33) P44=P42=P35=P34=1; // 从左至右(列) P44(P37) P42(P36) P35 P34 if(P44==0) &#123; delayms(5); if(P44==0) &#123; while(!P44); // 消抖 &#125; &#125; else if(P42==0) &#123; delayms(5); if(P42==0) &#123; while(!P42); &#125; &#125; else if(P35==0) &#123; delayms(5); if(P35==0) &#123; while(!P35); &#125; &#125; else if(P34==0) &#123; delayms(5); if(P34==0) &#123; while(!P34); &#125; &#125; /**************************/ // 第2横行读取 P31=0; P30=P32=P33=1; P44=P42=P35=P34=1; if(P44==0) &#123; delayms(5); if(P44==0) &#123; while(!P44); &#125; &#125; else if(P42==0) &#123; delayms(5); if(P42==0) &#123; while(!P42); &#125; &#125; else if(P35==0) &#123; delayms(5); if(P35==0) &#123; while(!P35); &#125; &#125; else if(P34==0) &#123; delayms(5); if(P34==0) &#123; while(!P34); &#125; &#125; /**************************/ // 第3横行读取 P32=0; P30=P31=P33=1; P44=P42=P35=P34=1; if(P44==0) &#123; delayms(5); if(P44==0) &#123; while(!P44); &#125; &#125; else if(P42==0) &#123; delayms(5); if(P42==0) &#123; while(!P42); &#125; &#125; else if(P35==0) &#123; delayms(5); if(P35==0) &#123; while(!P35); &#125; &#125; else if(P34==0) &#123; delayms(5); if(P34==0) &#123; while(!P34); &#125; &#125; /**************************/ // 第4横行读取 P33=0; P30=P31=P32=1; P44=P42=P35=P34=1; if(P44==0) &#123; delayms(5); if(P44==0) &#123; while(!P44); &#125; &#125; else if(P42==0) &#123; delayms(5); if(P42==0) &#123; while(!P42); &#125; &#125; else if(P35==0) &#123; delayms(5); if(P35==0) &#123; while(!P35); &#125; &#125; else if(P34==0) &#123; delayms(5); if(P34==0) &#123; while(!P34); &#125; &#125;&#125; 5.12345678910111213141516uchar tab[]=&#123;0xc0, 0xf9,0xa4,0xB0,0x99,0x92,0x82,0xf8,0x80,0x90, 0xbf,0x7f,0xff&#125;; // - . void display(uchar channel,uchar number) // 位选 段选 &#123; P2=0XC0; // 段选 P0=0X01&lt;&lt;channel; P2=0XFF; // 段选 P0=tab[number]; delayms(1);&#125;display(7,1); // 使得数码管 从左数第七个 显示1 未完待续…","categories":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"http://yoursite.com/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}],"tags":[]},{"title":"c与c++知识点(四)","slug":"C与C++笔记4","date":"2020-03-06T04:49:16.000Z","updated":"2020-03-30T12:35:40.403Z","comments":true,"path":"2020/03/06/C与C++笔记4/","link":"","permalink":"http://yoursite.com/2020/03/06/C%E4%B8%8EC++%E7%AC%94%E8%AE%B04/","excerpt":"","text":"这是我自己在学习c++基础的过程中，顺便复习了下C语言，然后总结的一些小小知识点。—写在前面的话第四节1.c++面向对象特性 封装 继承 多态 万事万物都皆为对象2.1234567891011c++ class aa&#123;//访问权限//属性（变量）//行为（函数）&#125; 3.属性和行为 都称之为 成员 成员属性 = 属性4.12345public // 公共权限 成员 类内可以访问 类外可以访问Protected // 保护权限 成员 类内可以访问 类外不可以访问（儿子可以访问父亲的保护内容）Private // 私有权限 成员 类内可以访问 类外不可以访问（儿子不可以访问父亲私有权限） 5.12345struct class // 区别在于 默认访问权限不同 struct // 默认为公共 public class // 默认为私有 private 未完待续…","categories":[{"name":"c与c++","slug":"c与c","permalink":"http://yoursite.com/categories/c%E4%B8%8Ec/"}],"tags":[]},{"title":"c与c++知识点(三)","slug":"C与C++笔记3","date":"2020-03-05T04:49:16.000Z","updated":"2020-03-30T12:35:11.090Z","comments":true,"path":"2020/03/05/C与C++笔记3/","link":"","permalink":"http://yoursite.com/2020/03/05/C%E4%B8%8EC++%E7%AC%94%E8%AE%B03/","excerpt":"","text":"这是我自己在学习c++基础的过程中，顺便复习了下C语言，然后总结的一些小小知识点。—写在前面的话第三节1.C++内存分为四个区123456789// 代码区 存放函数体的二进制代码// 全局区 存放全局变量和静态变量以及常量// 栈区 编译器自动分配 存放函数参数值 局部变量// 堆区 程序员分配和释放，程序员不释放，程序结束时操作系统回收// 意义： 不同区域存放的数据，赋予不同的生命中秋，给予更大的灵活编程 1234567891011// 代码区 （程序运行前就有）存放二进制机器指令 特点 : 共享、只读// 全局区 （程序运行前就有）存放全局变量和静态变量以及常量 该区的数据在程序结束后#### 由操作系 统释放 // 在全局区（静态变量 static关键字 常量（字符串常量和const 修饰的全局变量）） 不在全局区的数 据（局部常量）// 栈区 （程序运行后才有）不要返回局部变量的地址 // 堆区 （程序运行后才有）（程序员手动开辟和释放（delete））利用new关键字，将数据开辟到堆区 返回的直接是地址 int * p = new int (10) ; // 指针本质在栈区，其数据在堆区 2.12new // 返回的是该数据类型的指针 int * p=new int(10) ; // 创建了一个new型为10的变量地址 (释放 delete p;) 3.12 int * array = nem int[10]; // 创建了一个变量为整型个数为10的数组，他的首地址给了array (释放数组 delete[] arr;) 4.1234567// 引用：就是给变量起别名 // 语法：数据类型 &amp;别名=原名 对别名进行操作等于对原名的数据进行操作 int a=10; int &amp; b = a; b = 20; // 那么 a也为20 5.1234567// 引用的注意事项 // 1) 引用的时候必须要给予初始化 int &amp; b = a; (引用过程给予初始化，只有这一种写法) // 2) 引用一旦初始化后，不可更改 6.123456789101112131415161718192021// 引用也会使得形参修饰实参 void my3(int &amp;a,int &amp;b) // 有两种解决办法 指针 和 引用 // 注意事项:// 1 )不要返回局部变量的引用 int &amp;test() &#123; int a=10;return a; &#125; // 2 )函数的调用可以作为左值 int &amp;ref=test(); test()=100; cout &lt;&lt; ref &lt;&lt; endl; ref = 100; 7.123456789//引用的本质是一个指针常量 int a=10; int &amp;b = a; // 相当于 int * const b = &amp;a; 这也就是为什么引用不可修改，因为指针常量的指针指 向不可修改(b中保存着a的地址) cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl; a = b = 10;// b = 20解引用 也就是*b = 20; 8.12345678910111213141516// 常量引用 // 引用的两种写法// 1 ) int a=10； int &amp; b = a // (必须为名称，不能为10)；// 2) const int &amp; b = 10; // 第二种相当于编译器系统设置了一个变量 int temp = 10； const int &amp;b = temp； b = 20 // (这是错误的，因为加上const 之后变为只读不可修改状态) 9.1234567891011121314// 函数默认参数 优先用户自定义的 int fun(int a,int b=10,int c=30)&#123; return a+b+c;&#125;main&#123; cout &lt;&lt; fun (10 , 30 , 30 ) ; &#125; // 70; // 当某个位置有了默认参数，那么他后边都必须是默认参数(例如 b为默认参数，那么 c 也必须是默认参数) 10.12345678910// 声明和实现 只能有一个有默认参数 int fun (int a = 10,int b = 30); int fun(int a , int b) &#123; return a + b; &#125; // 40 11.1234567891011121314// 占位参数（只有函数类型，没有名字） void fun ( int a , int) &#123; cout &lt;&lt; ” abc ” ; &#125; // 引用时fun(10 , 10) 占位参数还可以有默认参数void fun(int a , int = 10) &#123; return “ abc ” ; &#125; // 引用时 fun( 10 ) 12.12345678// 函数重载(函数名可以相同) // 条件 : 同一个作用域下 函数名称相同 函数的参数类型不同 或者 个数不同或者顺序不同 // 注意：函数的返回值不可以作为函数重载的条件,如下 void fun ( ) void fun(int a) void fun(double b) 未完待续…","categories":[{"name":"c与c++","slug":"c与c","permalink":"http://yoursite.com/categories/c%E4%B8%8Ec/"}],"tags":[]},{"title":"c与c++知识点(二)","slug":"C与C++笔记2","date":"2020-03-04T04:49:16.000Z","updated":"2020-03-30T12:34:23.425Z","comments":true,"path":"2020/03/04/C与C++笔记2/","link":"","permalink":"http://yoursite.com/2020/03/04/C%E4%B8%8EC++%E7%AC%94%E8%AE%B02/","excerpt":"","text":"这是我自己在学习c++基础的过程中，顺便复习了下C语言，然后总结的一些小小知识点。—写在前面的话第二节1.1234/*二维数组 总元素*/ sizeof ( arr ) ;/* 第一行元素 */ sizeof ( arr [0] ) ;/* 行数 */ sizeof ( arr ) / sizeof ( arr [0] ) /* 列数 */ sizeof ( arr [0]) / sizeof( arr [0] [0] ) ) 2.1234/* 二维数组首地址 */ cout &lt;&lt; arr &lt;&lt; endl; /* 第一行首地址 */ cout &lt;&lt; arr [0] &lt;&lt; endl; /*第一个元素首地址 */ cout &lt;&lt; &amp; arr [0] [0] &lt;&lt; endl; // 此三者相等三者相等 /* 第二行首地址 */ cout &lt;&lt; arr[1] &lt;&lt; endl; 3.1/*指针就是地址*/ int *p; （p为指针变量） //使用时需要解引用 *p 即可 ( *p解引用） 4.12/*空指针: 用来给指针变量进行初始化，空指针不可以进行访问的*/ int *p = NULL; //不可再将地址赋值给 p 输出 5.1234567const修饰指针 ---重点1）const修饰指针---常量指针 2）const修饰常量---指针常量 3）const既修饰指针又修饰常量 6.—重点—12345678910//1）常量指针 const int * p = &amp;a; /*指针的指向可以修改，但是指针指向 的值不可修改 *///2）指针常量 int * const p = &amp;a; /*指针的指向不可以修改，指针的值可以修改 *///3）既修饰指针又修饰常量 const int * const p = &amp;a; /*指针的指向和指针的值都不可以修改 *///（如何记忆: const—常量 ，* p —指针 如何用：紧接着 const 的是p / * 紧跟着谁 谁不能操作） 7.12int arr [10], int * p; p = arr ; cout &lt;&lt; *p;//（数组的名称为其的首地址) 8.值传递，不能修改实参的值，只能修改形参的值。地址传递可以修改实参的值。9.结构体123456789101112131415struct student/**** 自己创建的结构体类型为 student, 此类型的变量名字为s1, s2 ***/ &#123; string name; int age; int score; &#125;;//1 struct student s1;//2 struct student s2 = &#123; &#125;;//3 创建结构体时顺便创建结构体变量,通过.来访问结构体中的属性 10.结构体创建自定义类型过程中struct不能省略，但是创建变量的过程c++ struct可以 省略11.12345678910111213// 结构体数组 struct 结构体名字 数组名字&#123;个数&#125;=&#123; &#123; &#125;，&#123; &#125; ，&#123; &#125; &#125;// 结构体指针 利用-&gt;可以通过结构体来访问结构体的属性student s1 = &#123; \"李斯\",56,99 &#125;;student * p = &amp;s1;cout &lt;&lt; \"姓名:\" &lt;&lt; p-&gt;name &lt;&lt; \"年龄:\" &lt;&lt; p-&gt;age &lt;&lt; \"分数\" &lt;&lt; p-&gt;score; 12.结构体嵌套结构体12345678910111213141516171819202122232425262728293031323334353637383940414243 struct student &#123; string name; int scroe; &#125;; struct teacher&#123; int id; string name; int age; struct student s1;//学生 s1&#125;; teacher t; t.id = 10086; t.name = \"老王\"; t.age = 58; t.s1. name = \"小王\"; t.s1.scroe = 99; teacher * p = &amp;t; cout &lt;&lt; \"老师姓名：\" &lt;&lt; p-&gt;name &lt;&lt; \"老师工号: \" &lt;&lt; p-&gt;id &lt;&lt; \"老师年龄: \" &lt;&lt; p-&gt;age &lt;&lt; \"老师的学生名字: \" &lt;&lt; p-&gt;s1.name &lt;&lt; \"老师的学生分数: \" &lt;&lt; p-&gt;s1.scroe; 13. 结构体中使用const来防止误操作14.—重点—main里面调用函数，形参相当于把参数复制了一遍，增大了储存空间和代码量。将函数的形参变为指针，可以大大减少内存的占用（指针不会复制数据，其只是进行地址传递）15.123system( “ pause ” ); //请按任意键继续 system( “ cls ” ); //清屏操作 未完待续…","categories":[{"name":"c与c++","slug":"c与c","permalink":"http://yoursite.com/categories/c%E4%B8%8Ec/"}],"tags":[]},{"title":"c与c++知识点(一)","slug":"C与C++笔记1","date":"2020-03-03T04:49:16.000Z","updated":"2020-03-30T12:32:58.451Z","comments":true,"path":"2020/03/03/C与C++笔记1/","link":"","permalink":"http://yoursite.com/2020/03/03/C%E4%B8%8EC++%E7%AC%94%E8%AE%B01/","excerpt":"","text":"这是我自己在学习c++基础的过程中，顺便复习了下C语言，然后总结的一些小小知识点。—写在前面的话第一节1.1int a; sizeof(int) = sizeof(a); ---求所储存的字节 2.1float aa = 'A' cout &lt;&lt; (int)aa &lt;&lt; endl; //输出A的数值(强制转化为 int) 注意格式 3.1float f2 = 3e2 //3*10^2 float f3 = 3e-2 //3*0.1^2 4.bool 真或假 bool flag = false/true(0/1); —除了0为假，其余都为真5.字符串&nbsp;&nbsp;(1)1char str[ ] = \"hello world\" cout&lt;&lt;str&lt;&lt;endl; &nbsp;&nbsp;(2) string 变量名 =”字符串值” （引用头文件include“string” 有的是在iostream头文件中）1string name[3] = &#123;\"张三\",\"李四\",\"王麻子\"&#125;; string name=”胖虎”； 6.12int a1 = 10; ++a1*10; //(运算结果为110)先加1后乘以10，int a1 =10; a1++*10; //(运算结果为101)先乘以10 后加1，先执行表达式，再增加 7.12-= /= %= int a=10; int b=5; cout&lt;&lt;(a==b); //输出结果为0(假) 8.1234rand() % 80; //生成0-79的随机数 rand() % 80+1; // 生成0-80随机数 /* 需要包含头文件 #include “cstdlib” */// #include ”ctime“ (伪函数) srand((unsigned int)time(NULL)); 利用系统时钟生成伪数字 9.1int a = 10; int b = 20; (a&lt;b?a:b)=100; cout &lt;&lt;a; a=100 cout&lt;&lt;b; //b=2 10.1int a = 354; //个位 a%10 十位 a%100/10 百位 a/100 11.1\\t 制表符代替空格 12.1goto flag ； flag： //跳转语句 ---读懂就可，不建议使用 13.1234/*数组*/ int arr[5] = &#123;1,2,3,4,5&#125; /*每个数组占用的内存空间*/ sizeof(arr)/*每个素占用的内存空间 */ sizeof(arr[0]),/*数组中元素个数为*/ sizeof(arr) / sizeof(arr[0]) //------重点 14.123/*数组地址 */ int arr[5] = &#123;1,2,3,4,5&#125; /*数组首整型地址*/ cout&lt;&lt; (int)arr; /*第一个元素整型地址*/ cout&lt;&lt;(int)&amp;arr[0]; //------重点 15.冒泡排序法12345678910111213141516void fun(int c[], int d)&#123; int temp=0; for (int a = 0; a &lt; d - 1; a++) &#123; for (int b = 0; b &lt; d - 1 - a; b++) &#123; if (c[b] &lt;c[b + 1]) &#123; temp = c[b]; c[b] = c[b + 1]; c[b + 1] = temp; &#125; &#125; &#125;&#125; 未完待续…","categories":[{"name":"c与c++","slug":"c与c","permalink":"http://yoursite.com/categories/c%E4%B8%8Ec/"}],"tags":[]},{"title":"MDK、KEIL的兼容与破解","slug":"MDK、KEIL的兼容与破解","date":"2020-03-02T04:49:16.000Z","updated":"2020-03-29T13:50:29.084Z","comments":true,"path":"2020/03/02/MDK、KEIL的兼容与破解/","link":"","permalink":"http://yoursite.com/2020/03/02/MDK%E3%80%81KEIL%E7%9A%84%E5%85%BC%E5%AE%B9%E4%B8%8E%E7%A0%B4%E8%A7%A3/","excerpt":"很多人可能有和我一样的经历，刚刚学完51单片机就转手来学32开发板，可面临的第一个很尴尬的问题就是KEIL和MDK不能同时兼容存在，自己想学32就要用到MDK,可又放不下刚刚捧热的”情人”keil”","text":"很多人可能有和我一样的经历，刚刚学完51单片机就转手来学32开发板，可面临的第一个很尴尬的问题就是KEIL和MDK不能同时兼容存在，自己想学32就要用到MDK,可又放不下刚刚捧热的”情人”keil” 第一章其实keil和mdk的共存是很简单的，话不多说，下文直接上硬菜(附keil&amp;mdk的安装包)先在d盘创建英文的文件夹(名件名为英文的是为了防止在后续的开发中出现莫名奇妙的警告错误信息)我创建的文件名称为 MDK5 然后打开我们mdk的安装包，按照顺序将程序安装到d盘MDK5的路径下(安装包文末会提供)（以32的f4包来举个栗子） 第二章请务必按如下顺序安装：安装MDK521A安装Keil.STM32F4xx_DFP（安装过程中需要输入的用户名字和Email可随意填写） 然后打开我们keil的安装包，将程序安装到d盘MDK5的路径下(安装包文末会提供)（两个安装包安装路径一定要相同） mdK和KEIL是安装在同一路径下，使用同一个桌面快捷方式，接下来教大家如何分别创建51和32新文件. 第三章双击打开我们的keil,Project -&gt;第一个New uVision Project当我们需要写32代码时，选择下面如图这个选项，然后选择相应的芯片来写代码。 当我们需要写51代码时，选择下面如图这个选项，然后在Atmel中选择stc89c52来写代码 在文章的结尾我为大家分享下keil&amp;mdk的安装包软件keil&amp;mdk安装包链接：https://pan.baidu.com/s/1IPHFC7OMV42ard_GX4LL0w提取码：rrki如果链接失效，请留言进行补充(小白的第一篇博客，不喜勿喷，若有不足之处，还望多多指出,谢谢！) 喜欢就常来看看呗，武汉加油，中国加油噢","categories":[{"name":"单片机","slug":"单片机","permalink":"http://yoursite.com/categories/%E5%8D%95%E7%89%87%E6%9C%BA/"}],"tags":[]}],"categories":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"http://yoursite.com/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"},{"name":"c与c++","slug":"c与c","permalink":"http://yoursite.com/categories/c%E4%B8%8Ec/"},{"name":"单片机","slug":"单片机","permalink":"http://yoursite.com/categories/%E5%8D%95%E7%89%87%E6%9C%BA/"}],"tags":[]}