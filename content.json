{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[{"title":"search","date":"2020-03-28T12:55:50.000Z","updated":"2020-03-28T12:56:19.471Z","comments":true,"path":"search/index.html","permalink":"http://yoursite.com/search/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-03-28T12:50:44.000Z","updated":"2020-03-29T03:25:06.161Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-03-28T12:52:27.000Z","updated":"2020-03-29T03:27:15.002Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"我本善良","slug":"我本善良","date":"2020-11-30T04:49:16.000Z","updated":"2020-12-01T13:21:48.139Z","comments":true,"path":"2020/11/30/我本善良/","link":"","permalink":"http://yoursite.com/2020/11/30/%E6%88%91%E6%9C%AC%E5%96%84%E8%89%AF/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"H-bの博客","slug":"H-bの博客","date":"2020-10-26T04:49:16.000Z","updated":"2020-10-27T12:51:51.196Z","comments":true,"path":"2020/10/26/H-bの博客/","link":"","permalink":"http://yoursite.com/2020/10/26/H-b%E3%81%AE%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"天苍茫而路漫兮，岁月将行。九死生而笑看兮，且吟长歌。","categories":[],"tags":[]},{"title":"爬虫","slug":"爬虫","date":"2020-08-01T04:49:16.000Z","updated":"2020-09-04T08:50:47.432Z","comments":true,"path":"2020/08/01/爬虫/","link":"","permalink":"http://yoursite.com/2020/08/01/%E7%88%AC%E8%99%AB/","excerpt":"","text":"1 print(&quot;www&quot;,&quot;baidu&quot;,&quot;com&quot;) #输出 www baidu com print(&quot;www&quot;,&quot;baidu&quot;,&quot;com&quot;,sep=&quot;.&quot;) #用点代替空格 输出www.baidu.com 2 强制类型转换 c = int(input(&quot;shuru:&quot;)) #注意input 默认输入为str(字符型) print(&quot;shuruyigeshuzi:%d&quot;%c) #输出整型数字 3 成员运算符 in #在序列中找到，返回True,否则返回False not in #没有在序列中找到返回True,否则返回False 4 身份运算符 is #判断两个标识符是不是引用一个对象，是为True,否为False is not #判断两个标识符是不是引用不同对象，是为True,否为False 5 随机数 import random x = random.randint(0,2) #随机生成[0-2]的随机数，包含0，1，2 print(x) 6 for循环 ​ (1) for i in range(5): print(i) #打印出 0 1 2 3 4 一共循环了五次 ​ (2) for i in range(0,10,3): print(i) #打印出 0 3 6 9 从0到10，每次增加3，然后打印出来 name = &quot;chengdu&quot; for x in name: print(x,end=&quot;\\t&quot;) #打印结果 c h e n g d u a = [&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;,&quot;dd&quot;] for i in range(len(a)): # len(a)=4 长度 print(i,a[i]) &quot;&quot;&quot;打印结果如下 0 aa 1 bb 2 cc 3 dd &quot;&quot;&quot; 7 while i = 0 while i &lt; 3: print(&quot;第%d执行&quot;%(i+1)) print(&quot;i=%d&quot;%i) i += 1 &quot;&quot;&quot;打印结果如下 第1次执行 i=0 第2次执行 i=1 第3次执行 i=2 &quot;&quot;&quot; 8 break continue pass break: #语句可以直接跳出for和while循环体 i = 0 while i&lt;10: i += 1 print(&quot;-&quot;*30) if i==3: break print(i) &quot;&quot;&quot;打印结果如下 ------------------------------ 1 ------------------------------ 2 ------------------------------ &quot;&quot;&quot; continue: #语句跳出当前循环，进入下一轮循环 i = 0 while i&lt;4: i += 1 print(&quot;-&quot;*30) if i==2: continue print(i) &quot;&quot;&quot;打印结果如下 ------------------------------ 1 ------------------------------ ------------------------------ 3 ------------------------------ 4 &quot;&quot;&quot; pass: #空语句，用于占位语句，不做事情 #九九乘法表 for a in range(1,10,1): for b in range(1,a+1,1): print(end=&quot;%d*%d=%d\\t&quot;%(b,a,a*b)) print(&quot;\\n&quot;) 9 字符串 my = &quot;I&#39;m student&quot; print(my) #打印结果 I&#39;m student word = &quot;&quot;&quot; hello world hobby &quot;&quot;&quot; print(word) &quot;&quot;&quot;打印结果 hello world hobby &quot;&quot;&quot; 特殊注意几个字符 &quot;&quot;&quot; 转义字符 描述 \\\\ 反斜杠符号 \\&#39; 单引号 \\&#39;&#39; 双引号 \\n 换行 \\t 横向制表符 &quot;&quot;&quot; 截取字符串 str = &quot;chengdu&quot; print(str) #输出 chengdu print(str[0]) #输出 c print(str[0:5]) #输出 cheng print(str[1:7:2]) #输出 hnd [起始位置:终止位置:步进值] print(str[:5]) #输出 cheng print(str[5:]) #输出 du print(&quot;hello &quot; + str) #输出 hello chengdu print(&quot;hello\\nchengdu&quot;)#输出 hello(换行)chengdu print(r&quot;hello\\nchengdu&quot;)#输出 hellochengdu # 加一个r 表示直接显示，不进行转义 10 列表 # 列表类似于数组(列表中可以存储混合类型) namelist = [&quot;zhangsan&quot;,&quot;lisi&quot;,102] print(namelist[0]) #输出 zhangsan print(namelist[2]) #输出 102 print(type(namelist[0])) #输出 &lt;class &#39;str&#39;&gt; print(type(namelist[2])) #输出 &lt;class &#39;int&#39;&gt; # for遍历 namelist = [&quot;zhangsan&quot;,&quot;lisi&quot;,102] for name in namelist: print(name) &quot;&quot;&quot; zhangsan lisi 102 &quot;&quot;&quot; # while遍历 namelist = [&quot;zhangsan&quot;,&quot;lisi&quot;,102] i = 0 while i &lt; len(namelist): print(namelist[i]) i += 1 # 列表具有切片 list1[2:5:2] [起始位置:终止位置:步进值] 增 # 增1 append (在列表末尾添加新的成员) namelist = [&quot;zhangsan&quot;] nametemp = input(&quot;write new name:&quot;) namelist.append(nametemp) for a in namelist: print(a) &quot;&quot;&quot; write new name:lisi zhangsan lisi &quot;&quot;&quot; # 增2 extend (在列表末尾逐一合并增加新的成员) a = [1,2] b = [3,4] a.extend(b) print(a) # 输出结果 [1, 2, 3, 4] # 增3 insert 指定下标位置前插入元素 a = [0,1,2] a.insert(1,3) #第一个变量表示下标和，第二个表示元素(对象) print(a) #输出结果 [0 3 1 2] 删 # 删1 del 指定下标(位置)删除元素 namelist = [&quot;zhangsan&quot;,&quot;lisi&quot;,&quot;wangwu&quot;] del namelist[2] print(namelist) &quot;&quot;&quot; [&#39;zhangsan&#39;, &#39;lisi&#39;, &#39;wangwu&#39;] [&#39;zhangsan&#39;, &#39;lisi&#39;] &quot;&quot;&quot; # 删2 pop 删除列表最后一个元素 namelist = [&quot;zhangsan&quot;,&quot;lisi&quot;,&quot;wangwu&quot;] namelist.pop() print(namelist) &quot;&quot;&quot; [&#39;zhangsan&#39;, &#39;lisi&#39;] &quot;&quot;&quot; # 删3 remove 删除指定位置(若有重复数据，只删除第一个数据) namelist = [&quot;zhangsan&quot;,&quot;lisi&quot;,&quot;wangwu&quot;] namelist.remove(&quot;lisi&quot;) print(namelist) &quot;&quot;&quot; [&#39;zhangsan&#39;, &#39;wangwu&#39;] &quot;&quot;&quot; 改 # 改 指定下标内容 namelist = [&quot;zhangsan&quot;,&quot;lisi&quot;,&quot;wangwu&quot;] namelist[1] = &quot;xiaoming&quot; #下标直接修改即可 print(namelist) &quot;&quot;&quot; [&#39;zhangsan&#39;, &#39;xiaoming&#39;, &#39;wangwu&#39;] &quot;&quot;&quot; 查 # 查 在或者不在 namelist = [&quot;zhangsan&quot;,&quot;lisi&quot;,&quot;wangwu&quot;] findname = input(&quot;write that whate student do you want?&quot;) if findname in namelist: print(findname + &quot;had been find&quot; ) else: print(findname + &quot;had been not find&quot; ) &quot;&quot;&quot; write that whate student do you want? zhangsan zhangsan had been find &quot;&quot;&quot; 11 元组 列表属于可变序列,它的元素可以随时修改或者删除,而元组属于不可变序列,其中的元素是不能修改的,除非整体重新赋值。 定义元组 &quot;&quot;&quot; 无数值空元组时: tup = () 一个数值元组时: tup = (20,) # 必须要加逗号 多个数值元组时: tup = (10，20，30) &quot;&quot;&quot; 增：相当于创建了新的元组 tup1 = (&quot;abc&quot;,30,9) tup2=(&quot;gh&quot;,50) tup = tup1 + tup2 print(tup) # 运行结果 (&#39;abc&#39;, 30, 9, &#39;gh&#39;, 50) 删：不允许删除某个具体的值，删除的是整个变量 tup1 = (&quot;abc&quot;,30,9) print(tup1) del tup1 print(tup1) #报错 找不到tup1,该变量已经被彻底删除了 改：不能修改 tup1 = (&quot;abc&quot;,30,9) tup1[1] = 50 # 报错 查：用列表的查看方法即可 tup2=(&quot;gh&quot;,50,6,23,4,8) print(tup2[1:5:2]) # (50, 23) 12 字典(dict) (1)字典是无序的对象集合，使用键-值存储 (2)键必须使用不可变类型，值可以一样 (3)同一个字典中，键必须是唯一的 定义 inf = {&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:18} print(inf[&quot;age&quot;]) # 输出结果 18 #访问不存在的键 inf = {&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:18} print(inf.get(&quot;shengao&quot;)) # 输出结果 None (默认返回 None) print(inf.get(&quot;shengao&quot;,&quot;mec&quot;)) # 输出结果 mec (修改默认值返回 mec) 增 student = {&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:18} newid = input(&quot;write new id: &quot;) student[&quot;id&quot;] = newid print(student[&quot;id&quot;]) &quot;&quot;&quot; write new id: 86 86 &quot;&quot;&quot; 删 #(1) del student = {&quot;name&quot;:&quot;lisi&quot;,&quot;age&quot;:18} del student[&quot;name&quot;] print(&quot;change after: %s&quot;%student[&quot;name&quot;]) #报错 因为删除了是键值对(&quot;name&quot;:&quot;lisi&quot;) student = {&quot;name&quot;:&quot;lisi&quot;,&quot;age&quot;:18} del student print(student) # 报错 删除了字典 #(2) clear student = {&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:18} student.clear() print(student) # 输出结果 {} 改 student = {&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:18} student[&quot;age&quot;] = 20 print(student[&quot;age&quot;]) # 输出结果 20 查 student = {&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:18,&quot;id&quot;:1} print(student.keys()) print(student.values()) print(student.items()) &quot;&quot;&quot; dict_keys([&#39;name&#39;, &#39;age&#39;, &#39;id&#39;]) #得到所有的键 是列表形式 dict_values([&#39;zhangsan&#39;, 18, 1]) #得到所有的值 是列表形式 dict_items([(&#39;name&#39;, &#39;zhangsan&#39;), (&#39;age&#39;, 18), (&#39;id&#39;, 1)]) #得到的是所有的项(元组)，每个键值对是一个元组 &quot;&quot;&quot; #遍历所有的键 student = {&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:18,&quot;id&quot;:1} for key in student.keys(): print(key) &quot;&quot;&quot; name age id &quot;&quot;&quot; #遍历所有的值 student = {&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:18,&quot;id&quot;:1} for value in student.values(): print(value) &quot;&quot;&quot; zhangsan 18 1 &quot;&quot;&quot; #遍历所有的键值对 student = {&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:18,&quot;id&quot;:1} for key,value in student.items(): print(&quot;key = %s,value = %s&quot;%(key,value)) &quot;&quot;&quot; key = name,value = zhangsan key = age,value = 18 key = id,value = 1 &quot;&quot;&quot; # 使用枚举函数(enumerate)，同时得到列表的下标和元素内容 mylist = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,66] for i,x in enumerate(mylist): print(i+1,x) &quot;&quot;&quot; 1 a 2 b 3 c 4 66 &quot;&quot;&quot; 13 函数 定义 def 函数名(): 代码 # 可以返回多个值 def dvd(a,b): return a/b,a%b print(dvd(5,2)) # 运行结果(2.5,1) def a1(): print(&quot;-&quot;*15) def write(numb): x = 0 while x &lt; numb: a1() x += 1 nua = int(input(&quot;the nub do you want: &quot;)) #input默认为str类型 print(type(nua)) write(nua) &quot;&quot;&quot; the nub do you want: 2 &lt;class &#39;int&#39;&gt; --------------- --------------- &quot;&quot;&quot; 14 文件操作 打开/关闭(open/close) f = open(&quot;test.txt&quot;,&quot;w&quot;) # w为写入模式，如果没有test.txt自动创建一个 f.close() #关闭 r :以读打开文件，若没有文件，就报错(默认模式) w :以写打开文件，若没有文件，就自动创建 rb :以二进制打开文件用于只读 wb :以二进制打开文件用于只写 # 将字符串写入(write) f = open(&quot;test.txt&quot;,&quot;w&quot;) f.write(&quot;hello world ,i am here&quot;) f.close() # 读5个字符(read,读完后向后移动) f = open(&quot;test.txt&quot;,&quot;r&quot;) content=f.read(5) print(content) content=f.read(5) print(content) f.close() &quot;&quot;&quot; hello worl &quot;&quot;&quot; # 读取列表readlines(一次性读取全部列表) f = open(&quot;test.txt&quot;,&quot;r&quot;) content = f.readlines() print(content) i = 1 for temp in content: print(&quot;%d,%s&quot;%(i,temp)) i += 1 f.close() &quot;&quot;&quot; 1,hello world ,i am here 2,hello world ,i am here 3,hello world ,i am here 4,hello world ,i am here &quot;&quot;&quot; # 读取列表readline(一次读取一行列表) # 文件重命名os的rename(需要修改的名字，新的名字) import os os.rename(&quot;test.txt&quot;,&quot;abc.txt&quot;) 15 异常处理 print(&quot;---test---1---&quot;) f = open(&quot;123.txt&quot;,&quot;r&quot;) # 会报错，用只读打开了一个不存在的文件 print(&quot;---test---2---&quot;) # 这句代码不会被执行 #捕获所有的异常并且全部打印(Exception,as result) try: print(&quot;---test---1---&quot;) f = open(&quot;123.txt&quot;,&quot;r&quot;) print(num) except Exception as result: # Exception包含所有的错误类型 print(result) #打印所有的错误类型 try....finally和嵌套，不管如何报错，都会执行文件关闭的程序 import time try: f = open(&quot;123.txt&quot;,&quot;r&quot;) try: while True: content = f.readline() if len(content) == 0: break time.sleep(2) print(content) finally: #无论程序能否执行，此代码一定会被执行的 f.close() print(&quot;close wenjian&quot;) except Exception as result: print(&quot;had been error&quot;) &quot;&quot;&quot; had been error &quot;&quot;&quot; 16.正则表达式的常用操作符 &quot;&quot;&quot; . ：表示任何单个字符 [] ：字符集，对单个字符给出取值范围 例子:[abc]表示a、b、c，[a-z]表示a到z单个字符 [^ ] ：非字符集，对单个字符给出排除范围 例子:[^abc] 表示非a或b或c的单个字符 * ：前一个字符0次或无限次扩展 例子：abc*表示ab、abc、abcc、 abccc等 + ：前一个字符1次或无限次扩展 例子：abc+表示abc、abcc、abccc等 ? ：前一个字符0次或1次扩展 例子：abc？表示ab、abc | ：左右表达式任意一个 例子：abc|def表示abc、def {m} ：扩展前一个字符m次 例子：ab{2}c表示abbc {m. n} ；扩展前一个字符m至n次（含n） 例子：ab{1，2}c表示abc、abbc ^ ：匹配字符串开头 例子：^abc表示abc且在一个字符串的开头 $ ：匹配字符串结尾 例子：abc$表示abc且在一个字符串的结尾 () ：分组标记，内部只能使用|操作符 例子：（abc）表示abc，（abc|def）表示abc、def \\d ：数字，等价于[6-9] \\w ：单词字符，等价于[A-Za-z0-9_] &quot;&quot;&quot; 17. &quot;&quot;&quot; re search（） ：在一个字符串中搜索匹配正则表达式的第一个位置，返回 match对象 re match（） ：在一个字符串中搜索匹配正则表达式的第一个位置，返回 match对象 re. finally（） ：搜索字符串，以列表类型返回全部能匹配的子串 re split（） ：将一个字符串按照正则表达式匹配结果进行分割，返回列表类型 re. finditer（） ：搜索字符串，返回一个匹配结果的迭代类型，每个迭代元素是 match对象 re sub（） ：在一个字符串中替换所有匹配正则表达式的子串，返回替换后的字符串 &quot;&quot;&quot; 18. re修饰符 &quot;&quot;&quot; re.l：使匹配对大小写不敏感 re.L：做本地化识别（ ocale- aware）匹配 re.M：多行匹配，影响^和$ re.S：使匹配包括换行在内的所有字符 re.U：根据 Unicode字符集解析字符。这个标志影响w，W，\\b，\\B. re.X：该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。 &quot;&quot;&quot;","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[]},{"title":"解除限速","slug":"破解百度网盘限速","date":"2020-06-13T04:49:16.000Z","updated":"2020-07-11T05:11:16.267Z","comments":true,"path":"2020/06/13/破解百度网盘限速/","link":"","permalink":"http://yoursite.com/2020/06/13/%E7%A0%B4%E8%A7%A3%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E9%99%90%E9%80%9F/","excerpt":"","text":"自己亲自实践有效的解除限速1. 在电脑上下载一个IDM下载器或者迅雷下载器(下面用的IDM举例子) 2. 复制好所要下载文件的链接 3. 打开浏览器，输入http://pan.naifei.cc/? 4. 在上面的那个链接后边，直接将刚刚复制的分享链接粘贴进去即可。然后右键点击下载，选择IDM下载(如图) 5. 然后IMD会自动的帮我们下载，还可以设定下载路径之类的，速度很快的(由于我是电脑连接手机热点，所以图显速度不是很快)，成功解除限速","categories":[],"tags":[]},{"title":"opcv第一讲","slug":"Opencv加载、显示、保存处理图像","date":"2020-06-12T04:49:16.000Z","updated":"2020-07-07T09:10:42.574Z","comments":true,"path":"2020/06/12/Opencv加载、显示、保存处理图像/","link":"","permalink":"http://yoursite.com/2020/06/12/Opencv%E5%8A%A0%E8%BD%BD%E3%80%81%E6%98%BE%E7%A4%BA%E3%80%81%E4%BF%9D%E5%AD%98%E5%A4%84%E7%90%86%E5%9B%BE%E5%83%8F/","excerpt":"","text":"1. 加载图像（cv::imread）Mat src = imread(&quot;D:/c++练习/opencv/可删/1.jpg&quot;); imread 的功能是加载图像文件成为一个 Mat 对象其中第一个参数表示图像文件名称第二个参数，表示加载的图像是什么类型，支持常见的三个参数值如下所示：Mat src = imread(&quot;D:/c++练习/opencv/可删/1.jpg&quot;,IMREAD_GRAYSCALE); // IMREAD_GRAYSCALE 加载出灰色照片 // IMREAD_UNCHANGED (&lt;0) 表示加载原图，不做任何改变 // IMREAD_GRAYSCALE ( 0)表示把原图作为灰度图像加载进来 // IMREAD_COLOR (&gt;0) 表示把原图作为RGB图像加载进来 // 注意：OpenCV支持JPG、PNG、TIFF、RGB等常见格式图像文件加载 2. 显示图像 (cv::namedWindos / cv::imshow)（1）. namedWindos的功能是创建一个OpenCV窗口，它是由OpenCV自动创建与释放，你无需取销毁它。常见用法如下namedWindow(&quot;Window Title&quot;, WINDOW_AUTOSIZE) WINDOW_AUTOSIZE 会自动根据图像大小，显示窗口大小，不能人为改变窗口大小WINDOW_NORMAL 跟QT集成的时候会使用，允许修改窗口大小namedWindow(&quot;test opencv setup&quot;,CV_WINDOW_AUTOSIZE); // test opencv setup 窗口名称可以自己修改定义 （2）. imshow根据窗口名称显示图像到指定的窗口上去，第一个参数是窗口名称，第二参数是Mat对象Mat src = imread(&quot;D:/c++练习/opencv/可删/1.jpg&quot;,IMREAD_GRAYSCALE); imshow(&quot;test opencv setup&quot;, src); // test opencv setup 窗口名称可以自己修改定义 3. 修改图像 (cv::cvtColor)cvtColor的功能是把图像从一个彩色空间转换到另外一个色彩空间，有三个参数，第一个参数表示源图像、第二参数表示色彩空间转换之后的图像、第三个参数表示源和目标色彩空间如：COLOR_BGR2HLS 、COLOR_BGR2GRAY 等 Mat src = imread(&quot;D:/c++练习/opencv/可删/1.jpg&quot;,UNDERFLOW);// 原图 imshow(&quot;123&quot;, src); //123 窗口名称可以自己修改定义,显示src Mat output_image; cvtColor(src, output_image, COLOR_BGR2HLS); // 新图名为 output_image, 转换新图到 COLOR_BGR2HLS 色彩空间 imshow(&quot;111&quot;, output_image); // 显示output_image的新图，窗口名字为111 (4). 保存图像 cv::imwrite保存图像文件到指定目录路径只有8位、16位的PNG、JPG、Tiff文件格式而且是单通道或者三通道的BGR的图像才可以通过这种方式保存保存PNG格式的时候可以保存透明通道的图片可以指定压缩参数imwrite(&quot;D:/new.jpg&quot;, output_image); //将output_image的副本放在D盘，并且命新的名字为 new.jpg","categories":[{"name":"opencv视觉","slug":"opencv视觉","permalink":"http://yoursite.com/categories/opencv%E8%A7%86%E8%A7%89/"}],"tags":[]},{"title":"Essential 视觉Slam第一讲","slug":"Linux下的视觉Slam 第一讲 手把手教你Kdevelop编程","date":"2020-06-10T04:49:16.000Z","updated":"2020-07-01T15:11:16.503Z","comments":true,"path":"2020/06/10/Linux下的视觉Slam 第一讲 手把手教你Kdevelop编程/","link":"","permalink":"http://yoursite.com/2020/06/10/Linux%E4%B8%8B%E7%9A%84%E8%A7%86%E8%A7%89Slam%20%E7%AC%AC%E4%B8%80%E8%AE%B2%20%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0Kdevelop%E7%BC%96%E7%A8%8B/","excerpt":"","text":"这是我在自学Linux下的视觉slam所做的一些笔记，记录了一些坑和经验，方便日后的学习。我将手把手教大家介绍如何在linux系统下，在Kdevelop编译器下进行第一个slam_hello程序的编程。第一讲(1). 首先我们要在Linux系统下打开终端命令窗口(快捷键是 Ctrl + Alt + T)(2). 然后创建一个文件夹用来专门的保存代码，我这里用的是 home 路径下的 slam 文件夹 ，我们等会就在它里面的 ch2 文件夹下来创建我们第一个程序(如下所示) 方法一：(推荐)(1). 我们直接在终端命令输入Kdevelop，就可以打开编程软件了，效果如下所示![](https://gitee.com/two_finger_meditation/bed/raw/master/img/25 (1).png) (2). 然后我们打开工程，点击第一个，从模板新建![](https://gitee.com/two_finger_meditation/bed/raw/master/img/25 (2).png) (3). 然后在类别中选择Standard ，工程类别选择 Terminal ,具体详情如下 (4). 然后填写项目名称和修改保存的路径，如下 (5). 然后点击下一步 (6). 点击完成和ok即可 (7). 然后的界面如图所示 (8). 接下来配置启动器。单击 ”运行“ 中的 ”配置启动“ 进入配置页面。选中自己建立的工程之后单击 “添加”，选下拉菜单中的工程名称，然后点击Apply以及OK。其过程如下图所示。 (9). 然后在初始页面，加上命名空间，再小修改整理下，如下所示 (10). 然后点击”运行”，’’执行启动“(快捷键是 Shift + F9) (11). 运行后的效果如下 方法二：（详见方法一，法二不推荐）(1). 使用 touch 命令创建一个hello_slam.cpp文件，具体操作如下图所示 (2). 然后我们用Kdevelop编译器打开刚刚创建好的文件，具体操作如图所示(附一张打开后的页面) (3). 其他的步骤参考法(一)如果各位小伙伴有什么疑问，欢迎留言一起讨论呀！","categories":[{"name":"视觉Slam","slug":"视觉Slam","permalink":"http://yoursite.com/categories/%E8%A7%86%E8%A7%89Slam/"}],"tags":[]},{"title":"Essential C++ 笔记1","slug":"Essential C++ 笔记1","date":"2020-06-01T04:49:16.000Z","updated":"2020-06-27T03:01:03.656Z","comments":true,"path":"2020/06/01/Essential C++ 笔记1/","link":"","permalink":"http://yoursite.com/2020/06/01/Essential%20C++%20%E7%AC%94%E8%AE%B01/","excerpt":"","text":"Stanley B.Lippman时隔多年所写的轻量级C++，为C++初学者铺的红地毯。侯捷老师翻译，以此做笔记，方便日后回忆。第一章1. Class (类) 用户自定义数据类型2. 输入/输出库 ，名叫iostream ,包含整套的Class3. string Class 用于定义 string user_name , 并且属于声明，要包含 string Class 的头文件 #include “string”4. std 是标准库所驻命名空间 (namespace) 的名称5. 使用命名空间，避免和应用程序发生命名冲突的问题 (具有相同的名字)6. 在程序中使用 string Class 及 cin 、cout 的 iostream 类对象，不仅包含 string 、iostream 的头文件，还得让命名空间 std 内的名称曝光 ——using namespace std;（最简单曝光的方法）7. bool 值为 true / false8. 被定义为 const 对象后，获得初值后，无法再改变9. 数组 Array 与 Vector 容器 int pell [18] ; vector &lt;int&gt; seq(18); 10. 容器第一个元素位置为011. 数组 Array 与 Vector 容器的区别1. //容器定义、初始化必有大小，而数组可没有，例如 int pell []={1,2 ,3}; 2. Vector &lt;int&gt; *addrs[1]={&amp;a}; // 元素类型为 vector&lt;int&gt; * // addrs[0] 值为 a的地址 12. Vector 初始化的两种方式1. vector &lt;int&gt; seq(2); seq[0]=1; seq[1]=2; 2. //利用已初始化的Array 作为该Vector容器的初值 ------重要 int vals[5]={0,1,2,3,4}; vector &lt;int&gt; seq(vals,vals+5); 13. Vector的特点Vector容器知道自己的大小int a = seq.size(); //a中储存的就是vector &lt;int&gt; seq(2)的数据个数（为2） seq.size()会返回该容器的大小 14. 指针内含某特定类型对象的内存地址int *pi; // pi 是个int 类型的对象 int *pi= &amp; inval; // pi储存的是inval的内存地址 未完待续…","categories":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/categories/c/"}],"tags":[]},{"title":"STM32知识点(一)","slug":"STM32知识点(一)","date":"2020-05-28T04:49:16.000Z","updated":"2020-06-01T11:26:52.696Z","comments":true,"path":"2020/05/28/STM32知识点(一)/","link":"","permalink":"http://yoursite.com/2020/05/28/STM32%E7%9F%A5%E8%AF%86%E7%82%B9(%E4%B8%80)/","excerpt":"","text":"以前学习STM32感觉掌握的不牢固，很多知识都遗忘了，所以趁着疫情在家重新学习下，顺便记录下容易混的知识，和大家一起分享。1. GPIO — 指的是通用输入和输出端口引脚与GPIO区别?（1）引脚有的是做GPIO用，有的是做电源引脚，复位引脚，晶振引脚等（2）引脚可以复用，可以做GPIO，也可以做其他的作用(例如做串口…)2. GPIO的八种工作模式 — 重点四种输入：浮空输入: 芯片读取的引脚电平状态不确定，取决于GPIO外部电平，可以做KEY识别上拉输入: IO内带上拉电阻输入下拉输入: IO内带下拉电阻输入模拟输入: ADC模拟输入，不像其他输入模式只有0和1，模拟输入模式可以读取到很细微变化的值，ADC四种输出(以下四个均含上下拉):开漏输出: 只能输出低电平，外部不接上拉电阻时，所以要想输出高电平必须要外接上拉电阻 GPIO_MODE_OUTPUT_PP // 开漏输出 开漏复用输出: 理解为GPIO第二功能IO输出0-接GND， IO输出1 -接VCC，读输入值是未知的推挽式输出: 可以输出强高低电平，连接数字其间。例如IIC (SCL,SDA) GPIO_MODE_OUTPUT_OD // 推挽式输出 推挽式复用输出: 理解为GPIO第二功能,例如串口通信TX,SPI等3.八种模式对应Hal函数（1）GPIO_Mode_IN_FLOATING // 浮空输入 （2）GPIO_Mode_IPU // 上拉输入 （3）GPIO_Mode_IPD // 下拉输入 （4）GPIO_Mode_AIN // 模拟输入 （5）GPIO_Mode_Out_OD // 开漏输出 （6）GPIO_Mode_AF_OD // 开漏复用输出 （7）GPIO_Mode_Out_PP // 推挽输出 （8）GPIO_Mode_AF_PP // 复用推挽输出 4. 注意 — 重点当引脚高有效的我们就下拉，低有效的话我们就上拉,增强其控制能力 后续将继续补充与完善…","categories":[{"name":"STM32","slug":"STM32","permalink":"http://yoursite.com/categories/STM32/"}],"tags":[]},{"title":"Linux操作系统命令","slug":"Linux操作系统命令","date":"2020-05-04T04:49:16.000Z","updated":"2020-06-01T11:26:35.654Z","comments":true,"path":"2020/05/04/Linux操作系统命令/","link":"","permalink":"http://yoursite.com/2020/05/04/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4/","excerpt":"","text":"这是我自己在看视频过程中记录的Linux基础的小知识点。1.ctrl + shift + = // 为放大字体 ctrl + - // 为缩小字体 ctrl + alt + t // 为打开终端 clean // 清屏ls tab // 自动补全目录 2. 以下直接回车即可ls // 查看当前文件夹下内容 pwd // 查看当前所在文件夹 3. 以下需要加上对象，再回车cd // 切换文件夹(注意空格pwd) touch // 如果文件不存在，新建文件 mkdir // 创建文件夹(目录) mkdir -p a/b/c/d //(创建a文件，a包含了b，b包含了c，c包含了d) rm // 删除指定文件(不能删除文件夹（目录）) rm -d // 文件夹名 (删除文件夹(目录)) rm -r // 文件夹名 (删除文件夹(单目录和多目录)) rm -f // (强力删除，不提示任何信息) 4. 命令查询两种方法command --help man command 5. 文件和目录常用命令ls // 查看目录内容 cd // 切换目录 touch // 创建文件(当文件不存在时创建，如果已存在，则修改日期) rm mkdir // 删除 cp // 拷贝 mv // 移动 6. 隐藏文件以 .开头touch .123.txt // (以ls不可看见，ls -a(目录全部)才可见) // 删除时 rm .123.txt // . 代表为当前目录 // .. 代表上一级目录 例如(cd .. 为返回上一级目录) 7. ls常用的命令ls -a // 显示全部文件(包括隐藏的文件) ls -l // 显示文件的详细信息 ls -l -h // 人性化的显示文件的详细信息(ls -lh与前边那种书写相同) 8. 进制B 字节 一般为8位二进制数 K 1K = 1024 B M 1M = 1024 B G 1G = 1024 M T 1T = 1024 G 9. 通配符. // 代表任意个数个字符 ？ // 代表任意一个字符 至少一个 [] // 代表可以匹配字符组中任意一个 [abc] // 匹配 a b c 中任意一个 [a-f] // 匹配 a 到 f 范围的任意一个字符 ls 1* // (显示以1开头的文件) ls *1.txt // (显示以1.txt结尾的文件) ls [1-3].txt /***/// cd 拓展cd // 切换到当前用户的主目录(/home/用户目录) cd ~ // 切换到当前用户的主目录(/home/用户目录) cd . // 保留在当前目录 cd .. // 切换到上一级目录 cd - // 切换最近两次目录 /***/// 相对路径与绝对路径cd /home/zdaxian/Desktop // 绝对路径 // 相对路径 最前边不是/或- 便是相对目录所在目录位置 未完待续…","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[]},{"title":"蓝桥杯-第六届(温度记录)","slug":"蓝桥杯-第六届(温度记录)","date":"2020-04-18T04:49:16.000Z","updated":"2020-06-01T11:26:11.500Z","comments":true,"path":"2020/04/18/蓝桥杯-第六届(温度记录)/","link":"","permalink":"http://yoursite.com/2020/04/18/%E8%93%9D%E6%A1%A5%E6%9D%AF-%E7%AC%AC%E5%85%AD%E5%B1%8A(%E6%B8%A9%E5%BA%A6%E8%AE%B0%E5%BD%95)/","excerpt":"","text":"这是我自己在学习蓝桥杯过程中总结的一些知识，希望对今后的学习和备战蓝桥的同学能够提供一些帮助吧。蓝桥杯-第六届(温度记录)1.试题要求如下 2.题目要点分析1）指示符在显示时，需要闪烁(可以根据奇或偶来进行判断)2) 按下 s6 后，自动显示索引、各个温度(10个)3.注意事项1）运用到了以前几届的 DS18820 和 DS1302知识2）本届难度不大，综合运用了前边的知识4.代码实现开始的一些初始化之类的和第三届一样，这里不再分开叨叙(一笔简明带过)，忘记的朋友可以去看第三届解析#include &quot;stc15f2k60s2.h&quot; #include &quot;ds18b20.h&quot; #include &quot;ds1302.h&quot; uchar tab[]={0xc0, 0xf9,0xa4,0xB0,0x99,0x92,0x82,0xf8,0x80,0x90, 0xbf,0x7f,0xff}; // - . uint yi=0;uint er=0;uint san=0;uint si=0; uint wu=0;uint liu=0;uint qi=0;uint ba=0; uchar time_between=1; // 采集时间间隔 1 5 30 60采集 uchar caiji=0; extern uchar shijian[]; // 1302 时间数组 uint tt=0; // 中断计数 uchar save[10]; // 保留10次采集的温度记录在数组中 uchar save_n=0; // 与数组下标对应 uchar wendu; // 读取温度寄存 bit led1_spot=0; // 小灯开启标志位 bit fla=0; // 小灯闪烁标志位 void delayms(uint ms) { uint a; for(;ms&gt;0;ms--) { for(a=845;a&gt;0;a--); } } void allinit(void) { P2=0XA0; P0=0X00; P2=0X80; P0=0XFF; P2=0XC0; P0=0XFF; P2=0XFF; P0=0XFF; } void display(uchar channel,uchar number) { P2=0XC0; P0=0X01&lt;&lt;channel; P2=0XFF; P0=tab[number]; delayms(1); } void show_SMG() { display(0,yi); display(1,er); display(2,san); display(3,si); display(4,wu); display(5,liu); display(6,qi); display(7,ba); P2=0XC0; // 防止最后一个数码管过亮 P0=0XFF; P2=0XFF; P0=0XFF; } 官方提供的 ds18b20 代码资料 — 需修改 — 重点 /************************************************/ // 以下为官方提供 #include &quot;stc15f2k60s2.h&quot; #include &quot;ds18b20.h&quot; sbit DQ = P1^4; void Delay_OneWire(unsigned int t) { unsigned char i; while(t--){ for(i=0; i&lt;8; i++); } } void Write_DS18B20(unsigned char dat) // 写 { unsigned char i; for(i=0;i&lt;8;i++) { DQ = 0; DQ = dat&amp;0x01; Delay_OneWire(5); DQ = 1; dat &gt;&gt;= 1; } Delay_OneWire(5); } unsigned char Read_DS18B20(void) // 读 { unsigned char i; unsigned char dat; for(i=0;i&lt;8;i++) { DQ = 0; dat &gt;&gt;= 1; DQ = 1; if(DQ) { dat |= 0x80; } Delay_OneWire(5); } return dat; } bit init_ds18b20(void) // ds18b20初始化 { bit initflag = 0; DQ = 1; Delay_OneWire(12); DQ = 0; Delay_OneWire(80); DQ = 1; Delay_OneWire(10); initflag = DQ; Delay_OneWire(5); return initflag; } /*********************************************/ //以下需要自己写 unsigned char Tempget(void) { unsigned char low,high,temp; /***************************/ // 温度读取 init_ds18b20(); Write_DS18B20(0XCC); // 18b20手册 Write_DS18B20(0x44); Delay_OneWire(100); /***************************/ // 温度进行转化 init_ds18b20(); Write_DS18B20(0xcc); Write_DS18B20(0xbe); low=Read_DS18B20(); high=Read_DS18B20(); temp=high&lt;&lt;4; // 注意此处 temp|=(low&gt;&gt;4); return temp; } 官方提供的 ds1302 代码资料 — 需修改 — 重点#include &lt;STC15F2K60S2.H&gt; #include &lt;intrins.h&gt; #include &quot;ds1302.h&quot; sbit SCK=P1^7; sbit SDA=P2^3; sbit RST = P1^3; void Write_Ds1302_Byte(unsigned char temp) { unsigned char i; for (i=0;i&lt;8;i++) { SCK=0; SDA=temp&amp;0x01; temp&gt;&gt;=1; SCK=1; } } void Write_Ds1302( unsigned char address,unsigned char dat ) { RST=0; _nop_(); SCK=0; _nop_(); RST=1; _nop_(); Write_Ds1302_Byte(address); //Write_Ds1302_Byte(dat); // 需要修改如下 Write_Ds1302_Byte((dat/10&lt;&lt;4)|(dat%10)); // 修改后的 RST=0; } unsigned char Read_Ds1302 ( unsigned char address ) { unsigned char i,temp=0x00; uchar dat1,dat2; // 修改添加的 RST=0; _nop_(); SCK=0; _nop_(); RST=1; _nop_(); Write_Ds1302_Byte(address); for (i=0;i&lt;8;i++) { SCK=0; temp&gt;&gt;=1; if(SDA) temp|=0x80; SCK=1; } RST=0; _nop_(); RST=0; SCK=0; _nop_(); SCK=1; _nop_(); SDA=0; _nop_(); SDA=1; _nop_(); dat1=temp/16; // 10进制与16进制的转化 dat2=temp%16; temp=dat1*10+dat2; // 三行自己添加的 return (temp); } /**********************************/ // 以下需要自己写的 uchar shijian[]={50,59,23,0,0,0,0}; // 秒分时 日月周年 void DS_Write(void) { uchar i,add; add=0x80; // 0x80 写 0x81 读 Write_Ds1302(0x8e,0x00); // 开始对其 写(0x00) for(i=0;i&lt;7;i++) { Write_Ds1302(add,shijian[i]); add+=2; // 1302 每次增加2 } Write_Ds1302(0x8e,0x80); // 80 关闭 } void DS_Read(void) { uchar i,add; add=0x81; // 0x81 读取 Write_Ds1302(0x8e,0x00); for(i=0;i&lt;7;i++) { shijian[i]=Read_Ds1302(add); add+=2; } Write_Ds1302(0x8e,0x80); // 80 关闭 } 中断函数 — 重要void Timer0Init(void) // 0 5ms { AUXR |=0X80; TMOD &amp;=0XF0; TL0=0X00; TH0=0X28; TF0=0; TR0=1; EA=1; ET0=1; } void timer0 () interrupt 1 { tt++; if(caiji==1) { if(tt==200*time_between) // 化为1s * 变成间隔多长时间进行采集 { tt=0; save[save_n]=wendu; save_n++; if(save_n==10) { caiji=2; // 采集完成标志位 save_n=0; er=san=0;si=wu=12; // 显示规定的显示 yi=liu=10; qi=save[0]/10; ba=save[0]%10; led1_spot=1; // 小灯开始闪烁的标志位 标志采集完成 } } } if((caiji==2)&amp;&amp;(tt==200)) // 1s 采集完成 闪烁 { tt=0; if(led1_spot==1) // 小灯开始闪烁标志位 { if(fla==0) // 控制小灯闪烁 { P2=0X80; P0=0xfe; fla=1; } else if(fla==1) { P2=0X80; P0=0XFF; fla=0; } } else if(led1_spot==0) // 小灯闪烁标志位为关闭状态 { // 当caiji=2,标志着采集完成，此时按下s6,led1_spot变为0， // 依次显示已经保存的10个温度 索引值也随之改变 yi=liu=10;si=wu=12; er=save_n/10; san=save_n%10; qi=save[save_n]/10; ba=save[save_n]%10; save_n++; if(save_n==10) { save_n=0; caiji=3; // caiji=3,已经显示完了已保存的温度 } } } } 按键功能操作 — 重点void keyscan4() { if(P30==0) { delayms(5); if(P30==0) { if(caiji==3) // caiji=3,已经依次显示完了已保存的温度 { caiji=0; // 恢复s4的再次按键控制作用 } }while(!P30); } if(P31==0) { delayms(5); if(P31==0) { if(caiji==2) // 采集完成后的标志位---也就是依次显示 { led1_spot=0; // 关闭小灯闪烁 P2=0X80; P0=0XFF; } }while(!P31); } if(P32==0) { delayms(5); if(P32==0) { if(caiji==0) // 采集开始后标志为1 { caiji=1; } tt=0; // 再次计数时，恢复中断的计数器 // (当caiji==3时，标志已经依次显示完温度) // 此时tt已经自动计数到很大了，进不到中断判断中，故需清零 }while(!P32); } if(P33==0) // s4 { delayms(5); if(P33==0) { if(caiji==0) // 采集未开始标志 { if(time_between==1) // 按下切换采集间隔时间 { time_between=5; } else if(time_between==5) { time_between=30; } else if(time_between==30) { time_between=60; } else if(time_between==60) { time_between=1; } } }while(!P33); } } 主函数中对标志位进行判断 — 重点void main() { allinit(); DS_Write(); // 初始化1302 Timer0Init(); yi=er=san=si=wu=12; liu=10;qi=0;ba=1; while(1) { wendu=Tempget(); if(caiji==0) // 采集未开始标志 { // 显示 1 5 30 60 采集时间设定 yi=er=san=si=wu=12; liu=10; qi=time_between/10; ba=time_between%10; } else if(caiji==1) // 开始采集的标志 { DS_Read(); // 读取1302时间 yi=shijian[2]/10;er=shijian[2]%10;san=10; si=shijian[1]/10;wu=shijian[1]%10;liu=10; // 分隔符 qi=shijian[0]/10;ba=shijian[0]%10; if(shijian[0]%2==0) // 横杠闪烁 { san=liu=10; // 横杠 } else { san=liu=12; } } show_SMG(); keyscan4(); } } 版权所有，未经允许，不得转载 !","categories":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"http://yoursite.com/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}],"tags":[]},{"title":"蓝桥杯-第五届(温度采集)","slug":"蓝桥杯-第五届(温度采集)","date":"2020-04-10T04:49:16.000Z","updated":"2020-06-01T11:26:01.260Z","comments":true,"path":"2020/04/10/蓝桥杯-第五届(温度采集)/","link":"","permalink":"http://yoursite.com/2020/04/10/%E8%93%9D%E6%A1%A5%E6%9D%AF-%E7%AC%AC%E4%BA%94%E5%B1%8A(%E6%B8%A9%E5%BA%A6%E9%87%87%E9%9B%86)/","excerpt":"","text":"这是我自己在学习蓝桥杯过程中总结的一些知识，希望对今后的学习和备战蓝桥的同学能够提供一些帮助吧。蓝桥杯-第五届(温度采集)1.试题要求如下 2.题目要点分析1）根据当前温度来显示不同的温度区间2）不同的温度区间，led闪烁不同的频率3）矩阵按键输入设置上下温度3.注意事项1）输入进去的温度，要进行最大温度与最小温度的比较，若有误，需清屏2）按键扫描函数延时与中断触发时间可能会有干扰，需解决4.代码实现开始的一些初始化之类的和第三届一样，这里不再分开叨叙(一笔简明带过)，忘记的朋友可以去看第三届解析#include &quot;stc15f2k60s2.h&quot; #include &quot;ds18b20.h&quot; uchar tab[]={0xc0, // 段选 0- 9 加上 - . 熄灭 0xf9,0xa4,0xB0,0x99,0x92,0x82,0xf8,0x80,0x90, 0xbf,0x7f,0xff}; // - . uint yi=0;uint er=0;uint san=0;uint si=0; uint wu=0;uint liu=0;uint qi=0;uint ba=0; // 全局变量 控制数码管的段选显示变化 uchar max=30; // 初始化温度上限30 全局变量 uchar min=20; // 初始化温度下限20 全局变量 uchar qujian; // 寄存判断区间后显示的数值 全局变量 uchar wendu=0; // 读取当前的温度，进行与区间判断 全局变量 uchar shezhi=0; // 按键设置的标志位 初始化为0 全局变量 uchar num; // 按下不同的矩阵的按键后，num发生变化，被赋予不同的数 全局变量 uchar flag=0 // 按下矩阵按键后的标志位，标志其被按下 全局变量 void delayms(uint a) // 延时 1ms { uint b; for(;a&gt;0;a--) { for(b=845;b&gt;0;b--); } } void all_init() // 初始化 关闭蜂咛器 继电器 数码管等 { P2=0XA0; P0=0X00; P2=0X80; P0=0XFF; P2=0XC0; P0=0XFF; P2=0XFF; P0=0XFF; } void display(uchar channel,uchar number) // 数码管的位选与段选 { P2=0XC0; P0=0X01&lt;&lt;channel; P2=0XFF; P0=tab[number]; delayms(1); } void show_SMG() // 数码显示函数 { display(0,yi); display(1,er); display(2,san); display(3,si); display(4,wu); display(5,liu); display(6,qi); display(7,ba); P2=0XC0; // 为了解决最后一个数码管过亮问题 P0=0XFF; P2=0XFF; P0=0XFF; } 官方提供的ds18b20代码资料 — 需修改 — 重点/*************************************************/ // 以下为官方提供 #include &quot;stc15f2k60s2.h&quot; #include &quot;ds18b20.h&quot; sbit DQ = P1^4; void Delay_OneWire(unsigned int t) // 延时函数 { unsigned char i; while(t--){ for(i=0; i&lt;8; i++); } } void Write_DS18B20(unsigned char dat) // 向ds18b20写一个字节 { unsigned char i; for(i=0;i&lt;8;i++) { DQ = 0; DQ = dat&amp;0x01; Delay_OneWire(5); DQ = 1; dat &gt;&gt;= 1; } Delay_OneWire(5); } unsigned char Read_DS18B20(void) // 从ds18b20读取一个字节 { unsigned char i; unsigned char dat; for(i=0;i&lt;8;i++) { DQ = 0; dat &gt;&gt;= 1; DQ = 1; if(DQ) { dat |= 0x80; } Delay_OneWire(5); } return dat; } bit init_ds18b20(void) // ds18b20 设备初始化 { bit initflag = 0; DQ = 1; Delay_OneWire(12); DQ = 0; Delay_OneWire(80); DQ = 1; Delay_OneWire(10); initflag = DQ; Delay_OneWire(5); return initflag; } /*********************************/ // 以下需要自己写 unsigned char Tempget(void) { unsigned char low,high,temp; /***************************/ // 温度进行读取 init_ds18b20(); Write_DS18B20(0XCC); // ds18b20手册 Write_DS18B20(0x44); Delay_OneWire(100); /***************************/ // 温度进行转化 init_ds18b20(); Write_DS18B20(0xcc); Write_DS18B20(0xbe); low=Read_DS18B20(); high=Read_DS18B20(); temp=high&lt;&lt;4; temp|=(low&gt;&gt;4); return temp; } 按键功能操作 — 重点void keyscan16() { /**************************/ // 第一行扫描 P30=0; P31=P32=P33=1; P44=P42=P35=P34=1; if(P44==0) { delayms(5); if(P44==0) { num=0; // 显示数字为0 flag=1; // 按下的标志位 while(!P44); } } else if(P42==0) { delayms(5); if(P42==0) { num=1; flag=1; while(!P42); } } else if(P35==0) { delayms(5); if(P35==0) { num=2; flag=1; while(!P35); } } /**************************/ //第二行扫描 P31=0; P30=P32=P33=1; P44=P42=P35=P34=1; if(P44==0) { delayms(5); if(P44==0) { num=3; flag=1; while(!P44); } } else if(P42==0) { delayms(5); if(P42==0) { num=4; flag=1; while(!P42); } } else if(P35==0) { delayms(5); if(P35==0) { num=5; flag=1; while(!P35); } } /**************************/ // 第三行扫描 P32=0; P30=P31=P33=1; P44=P42=P35=P34=1; if(P44==0) { delayms(5); if(P44==0) { num=6; flag=1; while(!P44); } } else if(P42==0) { delayms(5); if(P42==0) { num=7; flag=1; while(!P42); } } else if(P35==0) { delayms(5); if(P35==0) { num=8; flag=1; while(!P35); } } /**************************/ // 第四行扫描 --- 重点 P33=0; P30=P31=P32=1; P44=P42=P35=P34=1; if(P44==0) { delayms(5); if(P44==0) { num=9; flag=1; while(!P44); } } else if(P42==0) { delayms(5); if(P42==0) { if(shezhi==0) // 设置按键的标志位 { shezhi=1; EA=0; // 按下设置后 关闭中断 实际是为了关闭led灯的闪烁 TR0=0; ET0=0; P2=0X80; // 在设置时 关闭led P0=0XFF; P2=0XA0; // 在设置时 关闭 继电器 蜂咛器 P0=0X00; yi=liu=10; // - 显示设置时候的独特数码管 er=san=si=wu=qi=ba=12; } else if(shezhi==1) // 如果再次按下设置按键 打开中断 恢复小灯的闪烁 { shezhi=0; EA=1; // 按下设置后 打开中断 实际是为了恢复led灯的闪烁 TR0=1; ET0=1; max=er*10+san; // 再次按下这个设置按键时 保存所输入的最大与最小值 min=qi*10+ba; } while(!P42); } } else if(P35==0) { delayms(5); if(P35==0) { if(shezhi==1) // 如果在设置的状态下 按下清除键 则自动的清除当前输入的数值 { er=san=qi=ba=12; } while(!P35); } } 中断函数 — 重要uint tt=0; // 累加的标志位 bit led_spot=0; // led闪烁的标志位 void Timer0Init(void) // 定时器 0 5ms { AUXR |=0x80; TMOD &amp;=0XF0; TL0=0X00; TH0=0X28; TF0=0; TR0=1; ET0=1; EA=1; } void timer0 () interrupt 1 { tt++; /****************************************/ // 0区间 if(qujian==0) { if(tt==160) // 160*5=800ms=0.8s { tt=0; if(led_spot==0) // 设置标志位 实现数码管的闪烁 { led_spot=1; P2=0X80; // 关闭其他数码管 防止干扰 下同 P0=0XFF; P2=0X80; // 点亮 led P00=0; } else if(led_spot==1) { led_spot=0; P2=0X80; // 关闭 led P0=0xff; } } } /***************************************/ // 1区间 if(qujian==1) { if(tt==80) // 80*5=400ms=0.4s { tt=0; if(led_spot==0) { led_spot=1; P2=0X80; P0=0XFF; P2=0X80; P00=0; } else if(led_spot==1) { led_spot=0; P2=0X80; P0=0xff; } } } /***************************************/ //2 if(qujian==2) { if(tt==40) // 40*5=200ms=0.2s { tt=0; if(led_spot==0) { led_spot=1; P2=0X80; P0=0XFF; P2=0X80; P00=0; } else if(led_spot==1) { led_spot=0; P2=0X80; P0=0xff; } } } } 主函数中对标志位进行判断void main() { allinit(); Timer0Init(); yi=san=10;er=1; si=wu=liu=12; while(1) { keyscan16(); // 按键扫描 if(shezhi==0) // 在自动读取温度的页面 { wendu=Tempget(); if(wendu&lt;min) // 区间0 { qujian=0; // 对区间赋值 在中断中进行判断 实现不同频率的小灯闪烁 下同 P2=0XA0; // 关闭继电器 P0=0X00; } else if((wendu&gt;=min)&amp;&amp;(wendu&lt;=max)) // 区间1 注意格式 否则程序易卡死在循环中 { qujian=1; P2=0XA0; P0=0X00; } else if(wendu&gt;max) // 区间2 { qujian=2; P2=0XA0; // 超出最大值 继电器打开 P0=0X10; } yi=10; er=qujian; san=10; si=wu=liu=12; qi=wendu/10; ba=wendu%10; show_SMG(); // 数码管显示 } else if(shezhi==1 // 在设置页面 { if((er==12)&amp;&amp;(flag==1)) // - 判断按键的标志位 并且依次显示按下去的数值 { er=num; flag=0; } else if((san==12)&amp;&amp;(flag==1)) { san=num; flag=0; } else if((qi==12)&amp;&amp;(flag==1)) { qi=num; flag=0; } else if((ba==12)&amp;&amp;(flag==1)) { ba=num; flag=0; if((qi*10+ba)&gt;(er*10+san)) // 如果输入最小值大于最大值，清屏重新输入，并且打开提示，开继电器 { yi=liu=10; er=san=si=wu=qi=ba=12; // 清屏操作 P2=0X80; P01=0; } } show_SMG(); // 显示数码管 } show_SMG(); //再次显示数码管 防漏 } } 版权所有，未经允许，不得转载 !","categories":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"http://yoursite.com/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}],"tags":[]},{"title":"蓝桥杯-第四届(自动灌溉系统)","slug":"蓝桥杯-第四届(自动灌溉)","date":"2020-04-05T04:49:16.000Z","updated":"2020-06-01T11:25:53.332Z","comments":true,"path":"2020/04/05/蓝桥杯-第四届(自动灌溉)/","link":"","permalink":"http://yoursite.com/2020/04/05/%E8%93%9D%E6%A1%A5%E6%9D%AF-%E7%AC%AC%E5%9B%9B%E5%B1%8A(%E8%87%AA%E5%8A%A8%E7%81%8C%E6%BA%89)/","excerpt":"","text":"这是我自己在学习蓝桥杯过程中总结的一些知识，希望对今后的学习和备战蓝桥的同学能够提供一些帮助吧。蓝桥杯-第四届(自动灌溉系统)1.试题要求如下 2.题目要点分析 3.注意事项1）使用电位器RB2输出电压模拟湿度输出值2）系统RTC(1302)通过EEPROM保存阈值3）本届的代码不是很难，但它的思维逻辑要求比较大，重要的是区分清楚手动和自动两种工作的模式4.代码实现开始的一些初始化之类的和第三届一样，这里不再分开叨叙(一笔简明带过)，忘记的朋友可以去看第三届解析uchar tab[]={0xc0, // 段选 0- 9 加上 - . 熄灭 0xf9,0xa4,0xB0,0x99,0x92,0x82,0xf8,0x80,0x90, 0xbf,0x7f,0xff}; // - . uint yi,er,san,si,wu,liu,qi,ba; // 全局变量 控制数码管的段选显示变化 void delayms(uint a) // 延时 { uint b; for(;a&gt;0;a--) { for(b=845;b&gt;0;b--); } } void all_init() // 初始化 关闭蜂咛器 继电器 数码管等 { P2=0XA0; P0=0X00; P2=0X80; P0=0XFF; P2=0XC0; P0=0XFF; P2=0XFF; P0=0XFF; } void display(uint channel,uint num) // 数码管的位选与段选 { P2=0XC0; P0=0X01&lt;&lt;channel; P2=0XE0; P0=tab[num]; delayms(2); } void show_SMG() // 数码管显示函数 { display(0,yi); display(1,er); display(2,san); display(3,si); display(4,wu); display(5,liu); display(6,qi); display(7,ba); } 官方提供的RTC(1302)代码资料 — 需修改 — 重点/**************************************************/ //以下为官方提供 #include &lt;STC15F2K60S2.H&gt; #include &lt;intrins.h&gt; #include &quot;ds1302.h&quot; sbit SCK=P1^7; sbit SDA=P2^3; sbit RST = P1^3; // DS1302复位 void Write_Ds1302_Byte(unsigned char temp) { unsigned char i; for (i=0;i&lt;8;i++) { SCK=0; SDA=temp&amp;0x01; temp&gt;&gt;=1; SCK=1; } } void Write_Ds1302( unsigned char address,unsigned char dat ) { RST=0; _nop_(); SCK=0; _nop_(); RST=1; _nop_(); Write_Ds1302_Byte(address); //Write_Ds1302_Byte(dat); 这为原来官方提供的51例程，但应用在15程序中应该如下修改 Write_Ds1302_Byte((dat/10&lt;&lt;4)|(dat%10)); // 这为修改后的 RST=0; } unsigned char Read_Ds1302 ( unsigned char address ) { unsigned char i,temp=0x00; uchar dat1,dat2; // 本来没有这两个参数，但为了修改成15，添加的 RST=0; _nop_(); SCK=0; _nop_(); RST=1; _nop_(); Write_Ds1302_Byte(address); for (i=0;i&lt;8;i++) { SCK=0; temp&gt;&gt;=1; if(SDA) temp|=0x80; SCK=1; } RST=0; _nop_(); RST=0; SCK=0; _nop_(); SCK=1; _nop_(); SDA=0; _nop_(); SDA=1; _nop_(); /************************************/ //这段代码原来没有，需要自己添加(源代码无删减) dat1=temp/16; // 进制的转化 在1302中 使用的是压缩BCD码 dat2=temp%16; temp=dat1*10+dat2; /************************************/ return (temp); } /****************************************************/ //以下需要自己编写 uchar shijian[]={0,30,8,0,0,0,0}; // 1302 秒 分 时 日 月 周 年 void DS_Write(void) // 在1302中写入数据 { uchar i,add; add=0x80; // 0x80写 0x81读 Write_Ds1302(0x8e,0x00); // 开始(0x00) for(i=0;i&lt;7;i++) { Write_Ds1302(add,shijian[i]); add+=2; // 1302 寄存器定义 读与写 每次加二(可能因为压缩PCB码缘故) } Write_Ds1302(0x8e,0x80); // 关闭(0x80) } void DS_Read(void) // 读取1302的数据 { uchar i,add; add=0x81; // 0x81读 Write_Ds1302(0x8e,0x00); // 开始(0x00) for(i=0;i&lt;7;i++) { shijian[i]=Read_Ds1302(add); add+=2; } Write_Ds1302(0x8e,0x80); // 关闭(0x80) } 官方提供的IIC代码资料 — 需修改成EEPROM — 需修改成AD — 重点/***************************************************/ //以下代码官方提供 #include &quot;STC15F2K60S2.H&quot; #include &quot;intrins.h&quot; #include &quot;iic.h&quot; #define somenop {_nop_();_nop_();_nop_();_nop_();_nop_();} //这里需要扩大8倍延时 #define SlaveAddrW 0xA0 #define SlaveAddrR 0xA1 sbit SDA = P2^1; /* 数据线 */ sbit SCL = P2^0; /* 时钟线 */ void IIC_Start(void) // 总线启动 { SDA = 1; SCL = 1; somenop; SDA = 0; somenop; SCL = 0; } void IIC_Stop(void) // 总线停止 { SDA = 0; SCL = 1; somenop; SDA = 1; } bit IIC_WaitAck(void) // 等待应答 { SDA = 1; somenop; SCL = 1; somenop; if(SDA) { SCL = 0; IIC_Stop(); return 0; } else { SCL = 0; return 1; } } void IIC_SendByte(unsigned char byt) // 发送数据 { unsigned char i; for(i=0;i&lt;8;i++) { if(byt&amp;0x80) { SDA = 1; } else { SDA = 0; } somenop; SCL = 1; byt &lt;&lt;= 1; somenop; SCL = 0; } } unsigned char IIC_RecByte(void) // 接收数据 { unsigned char da; unsigned char i; for(i=0;i&lt;8;i++) { SCL = 1; somenop; da &lt;&lt;= 1; if(SDA) da |= 0x01; SCL = 0; somenop; } return da; } /*********************************************************/ //以下代码需要自己写 uchar AD_read(uchar add) // 与读取IIC代码一样 { uchar temp; IIC_Start(); IIC_SendByte(0x90); IIC_WaitAck(); IIC_SendByte(add); IIC_WaitAck(); IIC_Stop(); IIC_Start(); IIC_SendByte(0x91); IIC_WaitAck(); temp=IIC_RecByte(); IIC_Stop(); return temp; } /***********************/ //EEPROM uchar EEPROM_read(uchar add) { uchar temp; IIC_Start(); IIC_SendByte(0xa0); IIC_WaitAck(); IIC_SendByte(add); IIC_WaitAck(); IIC_Stop(); IIC_Start(); IIC_SendByte(0xa1); IIC_WaitAck(); temp=IIC_RecByte(); IIC_Stop(); return temp; } void EEPROM_write(uchar add,uchar dat) // 写数据 哪个地址 写入什么数据 { IIC_Start(); IIC_SendByte(0xa0); IIC_WaitAck(); IIC_SendByte(add); IIC_WaitAck(); IIC_SendByte(dat); // 写入数据 IIC_WaitAck(); IIC_Stop(); } 按键功能操作 uchar s7_spot=0; // s7标志位 uchar s6_spot=0; // s6标志位 uchar jia_spot=0; // 加的标志位 uchar jian_spot=0; // 减的标志位 uchar fazhi; // 阈值(存入EEPROM) uchar kai=1; // 蜂咛器 uchar jidianqi=0; // 继电器 模拟灌溉设备的打开与关闭 void keyscan() { /***************************///s7 if(P30==0) { delayms(2); if(P30==0) { if(s7_spot==0) // s7_spot = 0 自动状态 { s7_spot=1; P0=0XFF; P2=0X80; // led2 亮 P01=0; } else if(s7_spot==1) // s7_spot = 1 手动状态 { s7_spot=0; P0=0XFF; P2=0X80; // led1 亮 P00=0; } }while(!P30); } /******************************///s6 if(P31==0) { delayms(2); if(P31==0) { if(s7_spot==0) // 说明是在自动状态下 { if(s6_spot==0) { s6_spot=1; } else if(s6_spot==1) { s6_spot=0; } } else if(s7_spot==1) // 说明在手动状态下 { kai = ~kai; // 蜂咛器开和关的标志位 } }while(!P31); } /*******************************///s5 +1 if(P32==0) { delayms(2); if(P32==0) { if(s7_spot==0) // 在自动状态下 { jia_spot=1; // 加 标志位 } else if(s7_spot==1) // 在手动状态下 { jidianqi=1; // 灌溉设备打开 } }while(!P32); } /*****************************///s4 -1 if(P33==0) { delayms(2); if(P33==0) { if(s7_spot==0) // 在自动状态下 { jian_spot=1; // 减 标志位 } else if(s7_spot==1) // 在手动状态下 { jidianqi=0; // 灌溉设备关闭 } }while(!P33); } } 主函数中对标志位进行判断extern uchar shijian[]; // 对1302的储存数组进行声明 void main() { uchar shidu=0; yi=0;er=8;san=10;si=3;wu=0;liu=12;qi=5;ba=0; all_init(); P2=0X80; // L1亮 自动工作模式 P00=0; DS_Write(); // ds1302写 while(1) { DS_Read(); // ds1302读 shidu=AD_read(0x03); // 从AD里面读取电压模拟湿度 shidu=shidu*0.39; // 225转换为0~5伏 if(s7_spot==0) // s7没有被按下 为自动状态 L1 { // EEPROM_write(0x10,50); // 已经初始值为50，不在打开，将其地址赋予0x10，下次上电直接从EEPROM读取，不再赋予初值和地址 // delayms(5); // 延时等待应答 fazhi=EEPROM_read(0x10); // 读取阈值 /*当前读取的湿度与阈值进行比较 小于则自动打开灌溉设备(通过继电器模拟)*/ if(shidu&lt;fazhi) { P2=0XA0; P0=0X10; } else { P2=0XA0; P0=0X00; } if(s6_spot==1) // s6按下 需要对阈值进行调整 { if(jia_spot==1) // 在s6按下后，s5被按下，加标志位为1 阈值加1 { jia_spot=0; fazhi=fazhi+1; } if(jian_spot==1) // 在s6按下后，s4被按下，减标志位为1 阈值减1 { jian_spot=0; fazhi=fazhi-1; } EEPROM_write(0x10,fazhi); // 将改变的值写入EEPROM中 yi=er=10; // 在进行阈值调整时，显示独特的显示页面 san=si=wu=liu=12; qi=fazhi/10; ba=fazhi%10; } else if(s6_spot==0) // s6没有按下 显示1302里面存储的数 { yi=shijian[2]/10; er=shijian[2]%10; san=10; si=shijian[1]/10; wu=shijian[1]%10; liu=12; qi=shidu/10; // 显示湿度 ba=shidu%10; } } /**************************************************************/ //以下两种按键实际就是 在手动工作模式下 当湿度小于阈值时，蜂咛器报警，s6可以将蜂咛 //器关闭，再次按下s6,可以开启对蜂咛器的控制。而在手动工作模式下，蜂咛器的工作(叫或 //者不叫)不会被s5、s4按键的按下所干扰，s5、s4按下只控制灌溉系统(继电器)的工作 。 else if(s7_spot==1) // s7被按下 为手动状态 L2 { if((shidu&lt;fazhi)&amp;&amp;(kai==0)) // 在手动状态下，s6被按下，蜂咛器标志位kai取反为0 { if(jidianqi==1) // 手动状态下 s5按下 只有继电器亮(暗示蜂咛器被关闭) { P2=0XA0; P0=0X10; } else if(jidianqi==0) // 手动状态下 s4按下 继电器灭 { P2=0XA0; P0=0X00; } } else if((shidu&lt;fazhi)&amp;&amp;(kai==1)) // 在手动状态下，s6没有被按下(s6被按下后 // 又被按下)，蜂咛器标志位为1 { if(jidianqi==1) // 在手动情况下，蜂咛器报警，开启灌溉 { // s5按下 继电器亮 蜂咛器叫 P2=0XA0; P0=0X50; } else if(jidianqi==0) { // s4按下 继电器灭 蜂咛器叫 P2=0XA0; P0=0X40; } } /**************************************************************/ else if(shidu&gt;fazhi) { if(jidianqi==1) // 手动状态下 s5按下 继电器亮 { P2=0XA0; P0=0X10; } else if(jidianqi==0) // 手动状态下 s4按下 继电器灭 { P2=0XA0; P0=0X00; } } yi=shijian[2]/10; er=shijian[2]%10; san=10; si=shijian[1]/10; wu=shijian[1]%10; liu=12; qi=shidu/10; ba=shidu%10; } // else if(s7_spot==1) 的括号 keyscan(); // 按键扫描函数 show_SMG(); // 对全局变量 yi~ba 返回的值进行数码管显示 } // while的括号 } // main的括号 版权所有，未经允许，不得转载 !","categories":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"http://yoursite.com/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}],"tags":[]},{"title":"蓝桥杯-第三届(自动售水机)","slug":"蓝桥杯-第三届(自动售水机)","date":"2020-03-28T04:49:16.000Z","updated":"2020-06-01T11:25:44.767Z","comments":true,"path":"2020/03/28/蓝桥杯-第三届(自动售水机)/","link":"","permalink":"http://yoursite.com/2020/03/28/%E8%93%9D%E6%A1%A5%E6%9D%AF-%E7%AC%AC%E4%B8%89%E5%B1%8A(%E8%87%AA%E5%8A%A8%E5%94%AE%E6%B0%B4%E6%9C%BA)/","excerpt":"","text":"这是我自己在学习蓝桥杯过程中总结的一些知识，希望对今后的学习和备战蓝桥的同学能够提供一些帮助吧。蓝桥杯-第三届(自动售水机)1.试题要求如下 2.题目要点分析1) 上电后各部分要初始化(关闭蜂咛器、数码管、led灯、继电器)，并且数码管要显示题目要求初始的数(含格式)2）按下 S7 清屏开始计数(计数器中断)流水显示，S6停止流水计数并且计算显示出流水价格3) 通过光敏电阻读取环境的亮度，当其发生改变时，做出不同的响应4）掌握IIC3.注意事项1）数码管小数的显示，需要重新计算数码管段选数组 tab_spot[] ，都加上h，使其显示出小数点2）S7按键不会改变流水的状态，唯有S6可以改变, S7作用只有一个，就是清屏开始流水计数3）通过流水量计算出价格这方法要注意4）光敏电阻读取数据与显示的转换要注意（ IIC 写0x90, 读0x91)5) 引用头文件并且定义无符号类型#include &quot;STC15f2k60S2.h&quot; #include &quot;intrins.h&quot; // 引用头文件 调用iic里面的延时函数 _nop_() #define uchar unsigned char #define uint unsigned int 4.代码实现首先是进行初始化void allinit() // 初始化 { P2=0XA0; P0=0X00; P2=0X80; P0=0XFF; P2=0XC0; P0=0XFF; P2=0XFF; P0=0XFF; } 延时函数void delayms(uchar a) { uint b; for(;a&gt;0;a--) { for(b=845;b&gt;0;b--) { } } } 数码管显示(双重—-正常不加小数点和加小数点)uchar tab[]={0xc0, 0xf9,0xa4,0xB0,0x99,0x92,0x82,0xf8,0x80,0x90, 0xff}; // 不加小数点 uchar tab_spot[]={0x40, 0x79,0x24,0x30,0x19,0x12,0x02,0x78,0x00,0x10, 0xff}; // 加上小数点的 void display(uchar channel,uchar num) // 不加小数点段选的数码管显示 { P2=0XC0; P0=0X01&lt;&lt;channel; P2=0XE0; P0=tab[num]; delayms(2); } void display_spot(uchar channel,uchar num) // 加小数点段选的数码管显示 { P2=0XC0; P0=0X01&lt;&lt;channel; P2=0XE0; P0=tab_spot[num]; delayms(2); } 题目要求的数码管显示格式uchar yi,er,san,si,wu,liu,qi,ba; // 全局变量 void display_SMG() { display(0,yi); display_spot(1,er); display(2,san); display(3,si); display(4,wu); display_spot(5,liu); display(6,qi); display(7,ba); } 中断void Timer0Init(void) // 5毫秒 来源stc定时器计算器 波特率11.0592 定时器0 16位自动重载 { AUXR |= 0x80; TMOD &amp;= 0xF0; TL0 = 0x00; TH0 = 0x28; TF0 = 0; TR0 = 1; } uint aa=0; // 三个全局变量 进行时间、金钱计算 uint bb=0; uint money=0; void time0 () interrupt 1 // 定时器中断服务函数 1 { aa++; if(aa==20) // 100毫秒 { bb++; // 100毫秒=10毫升 (相当于数码管最后一位) aa=0; ba=bb%10; qi=bb%100/10; liu=bb%1000/100; wu=bb/1000; } if(bb==9999) { bb=0; money=bb*0.5; // 进行金钱转化 ba=money%10; qi=money%100/10; liu=money%1000/100; wu=money/1000; } } 按键操作void start() // S7按下 开启 { wu=liu=qi=ba=0; // 使得开始按按键时 数码管后四位清零 P2=0XA0; // 开启继电器 P0=0X10; ET0=1; // 开启定时器 EA=1; } void off() // S6按下 关闭 { P2=0XA0; // 关闭继电器 P0=0X00; EA=0; // 关闭定时器 ET0=0; money=bb*0.5; // 关闭时自动显示价钱 ba=money%10; qi=money%100/10; liu=money%1000/100; wu=money/1000; bb=0; // 确保下次开始计数时 从0开始 } void keyscan() { if(P30==0) { delayms(2); if(P30==0) { start(); } while(!P30); } if(P31==0) { delayms(2); if(P31==0) { off(); } while(!P31); } } 实现光敏电阻的各项功能 (要利用给的IIC文件夹，稍加修改即可)/*********************************************/ // 以下函数在官方数据手册提供 /*********************************************/ // _nop_() 需要引入头文件 &quot;intrins.h&quot; #define somenop {_nop_();_nop_();_nop_();_nop_();_nop_();} // 这为官方给的51 #define somenop {_nop_();_nop_();_nop_();_nop_();_nop_(); // 15的延时大概为51的8倍 _nop_();_nop_();_nop_();_nop_();_nop_(); _nop_();_nop_();_nop_();_nop_();_nop_(); _nop_();_nop_();_nop_();_nop_();_nop_(); _nop_();_nop_();_nop_();_nop_();_nop_(); _nop_();_nop_();_nop_();_nop_();_nop_(); _nop_();_nop_();_nop_();_nop_();_nop_(); _nop_();_nop_();_nop_();_nop_();_nop_(); } #define SlaveAddrW 0xA0 // 写 #define SlaveAddrR 0xA1 // 读 sbit SDA = P2^1; /* 数据线 */ sbit SCL = P2^0; /* 时钟线 */ void IIC_Start(void) // 启动条件 { SDA = 1; SCL = 1; somenop; SDA = 0; somenop; SCL = 0; } void IIC_Stop(void) // 停止条件 { SDA = 0; SCL = 1; somenop; SDA = 1; } bit IIC_WaitAck(void) // 等待应答 { SDA = 1; somenop; SCL = 1; somenop; if(SDA) { SCL = 0; IIC_Stop(); return 0; } else { SCL = 0; return 1; } } void IIC_SendByte(unsigned char byt) // 通过iic发送数据 { unsigned char i; for(i=0;i&lt;8;i++) { if(byt&amp;0x80) { SDA = 1; } else { SDA = 0; } somenop; SCL = 1; byt &lt;&lt;= 1; somenop; SCL = 0; } } unsigned char IIC_RecByte(void) // 接收iic数据 { unsigned char da; unsigned char i; for(i=0;i&lt;8;i++) { SCL = 1; somenop; da &lt;&lt;= 1; if(SDA) da |= 0x01; SCL = 0; somenop; } return da; } /***********************************/ //以下的函数需要自己根据官方提供的函数来编写 uchar iic_read(uchar add) { uchar temp; /******************/ IIC_Start(); IIC_SendByte(0x90); IIC_WaitAck(); IIC_SendByte(add); IIC_WaitAck(); IIC_Stop(); /*****************/ IIC_Start(0x91); IIC_SendByte(0x91); IIC_WaitAck(); temp=IIC_RecByte(); IIC_WaitAck(); IIC_Stop(); /****************/ return temp; } 主函数void main() { uchar guangmin; // 记录数码管的值 all_init(); // 初始化，关闭蜂咛器，继电器之类 Timer0Init(); // 中断初始化 yi=10,er=0,san=5,si=0,wu=0,liu=1,qi=0,ba=0; // 开始数码管的显示 while(1) { display_SMG(); // 初始化数码管 keyscan(); // 读取按键反馈回来的全局变量 yi ~ ba 的值，并且控制其他模块 guangmin=iic_read(0x01); // !!! iic读取光敏电阻的值并进行转换 if(guangmin&lt;64) // !!! { P0=0XFF; // 避免其小灯的干扰 P2=0X80; P00=0; // 点亮 } else { P2=0X80; P0=0XFF; } } } 5.完整的代码参考(仅供学习)链接：https://pan.baidu.com/s/138PEwdj5GlsxOEjPLrFB4Q提取码：6kt5 注: 本文为原创，未经允许，禁止转载！","categories":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"http://yoursite.com/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}],"tags":[]},{"title":"蓝桥杯基础","slug":"蓝桥杯基础","date":"2020-03-19T04:49:16.000Z","updated":"2020-06-01T11:25:35.145Z","comments":true,"path":"2020/03/19/蓝桥杯基础/","link":"","permalink":"http://yoursite.com/2020/03/19/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%9F%BA%E7%A1%80/","excerpt":"","text":"这是我自己在学习蓝桥杯过程中总结的一些知识，希望对今后的学习和备战蓝桥的同学能够提供一些帮助吧。必须要知道的知识1. void delayms(uint ms) // 15芯片延时一毫秒软件实现 { uint a; for(;ms&gt;0;ms--) { for(a=845;a&gt;0;a--); } } 2.void allinit(void) // 初始化关闭其他模块(led、继电器、蜂咛器、数码管) { P2=0XA0; // 继电器，蜂咛器 P0=0X00; P2=0X80; // 小灯 P0=0XFF; P2=0XC0; // 段选 1~8 P0=0XFF; P2=0XFF; P0=0XFF; } 3.void keyscan(void ) // 独立按键 从上至下 S7 - S4 (P30 - P33) { if(P30==0) { delayms(5); if(P30==0) { } while(!P30); // 消抖操作 } if(P31==0) { delayms(5); if(P31==0) { } while(!P31); } if(P32==0) { delayms(5); if(P32==0) { } while(!P32); } if(P33==0) { delayms(5); if(P33==0) { } while(!P33); } } 4.void display16() // 矩阵按键(需要改变按键跳线帽) P37 = P44 P36 = P42 { /**************************/ // 第1横行读取 P30=0; P31=P32=P33=1; // 从上至下(行) S7 - S4 (P30 - P33) P44=P42=P35=P34=1; // 从左至右(列) P44(P37) P42(P36) P35 P34 if(P44==0) { delayms(5); if(P44==0) { while(!P44); // 消抖 } } else if(P42==0) { delayms(5); if(P42==0) { while(!P42); } } else if(P35==0) { delayms(5); if(P35==0) { while(!P35); } } else if(P34==0) { delayms(5); if(P34==0) { while(!P34); } } /**************************/ // 第2横行读取 P31=0; P30=P32=P33=1; P44=P42=P35=P34=1; if(P44==0) { delayms(5); if(P44==0) { while(!P44); } } else if(P42==0) { delayms(5); if(P42==0) { while(!P42); } } else if(P35==0) { delayms(5); if(P35==0) { while(!P35); } } else if(P34==0) { delayms(5); if(P34==0) { while(!P34); } } /**************************/ // 第3横行读取 P32=0; P30=P31=P33=1; P44=P42=P35=P34=1; if(P44==0) { delayms(5); if(P44==0) { while(!P44); } } else if(P42==0) { delayms(5); if(P42==0) { while(!P42); } } else if(P35==0) { delayms(5); if(P35==0) { while(!P35); } } else if(P34==0) { delayms(5); if(P34==0) { while(!P34); } } /**************************/ // 第4横行读取 P33=0; P30=P31=P32=1; P44=P42=P35=P34=1; if(P44==0) { delayms(5); if(P44==0) { while(!P44); } } else if(P42==0) { delayms(5); if(P42==0) { while(!P42); } } else if(P35==0) { delayms(5); if(P35==0) { while(!P35); } } else if(P34==0) { delayms(5); if(P34==0) { while(!P34); } } } 5.uchar tab[]={0xc0, 0xf9,0xa4,0xB0,0x99,0x92,0x82,0xf8,0x80,0x90, 0xbf,0x7f,0xff}; // - . void display(uchar channel,uchar number) // 位选 段选 { P2=0XC0; // 段选 P0=0X01&lt;&lt;channel; P2=0XFF; // 段选 P0=tab[number]; delayms(1); } display(7,1); // 使得数码管 从左数第七个 显示1 后续将继续补充与完善…","categories":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"http://yoursite.com/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}],"tags":[]},{"title":"c与c++知识点(四)","slug":"C与C++笔记4","date":"2020-03-17T04:49:16.000Z","updated":"2020-06-01T11:25:14.574Z","comments":true,"path":"2020/03/17/C与C++笔记4/","link":"","permalink":"http://yoursite.com/2020/03/17/C%E4%B8%8EC++%E7%AC%94%E8%AE%B04/","excerpt":"","text":"这是我自己在学习c++基础的过程中，顺便复习了下C语言，然后总结的一些小小知识点。—写在前面的话第四节1.c++面向对象特性 封装 继承 多态 万事万物都皆为对象2. c++ class aa { //访问权限 //属性（变量） //行为（函数） } 3.属性和行为 都称之为 成员 成员属性 = 属性4. public // 公共权限 成员 类内可以访问 类外可以访问 Protected // 保护权限 成员 类内可以访问 类外不可以访问（儿子可以访问父亲的保护内容） Private // 私有权限 成员 类内可以访问 类外不可以访问（儿子不可以访问父亲私有权限） 5.struct class // 区别在于 默认访问权限不同 struct // 默认为公共 public class // 默认为私有 private 未完待续…","categories":[{"name":"c与c++","slug":"c与c","permalink":"http://yoursite.com/categories/c%E4%B8%8Ec/"}],"tags":[]},{"title":"c与c++知识点(三)","slug":"C与C++笔记3","date":"2020-03-16T04:49:16.000Z","updated":"2020-06-01T11:25:05.209Z","comments":true,"path":"2020/03/16/C与C++笔记3/","link":"","permalink":"http://yoursite.com/2020/03/16/C%E4%B8%8EC++%E7%AC%94%E8%AE%B03/","excerpt":"","text":"这是我自己在学习c++基础的过程中，顺便复习了下C语言，然后总结的一些小小知识点。—写在前面的话第三节1.C++内存分为四个区 // 代码区 存放函数体的二进制代码 // 全局区 存放全局变量和静态变量以及常量 // 栈区 编译器自动分配 存放函数参数值 局部变量 // 堆区 程序员分配和释放，程序员不释放，程序结束时操作系统回收 // 意义： 不同区域存放的数据，赋予不同的生命中秋，给予更大的灵活编程 // 代码区 （程序运行前就有）存放二进制机器指令 特点 : 共享、只读 // 全局区 （程序运行前就有）存放全局变量和静态变量以及常量 该区的数据在程序结束后，由操作系统释放 // 在全局区（静态变量 static关键字 常量（字符串常量和const 修饰的全局变量）） 不在全局区的数据（局部常量） // 栈区 （程序运行后才有）不要返回局部变量的地址 // 堆区 （程序运行后才有）（程序员手动开辟和释放（delete））利用new关键字，将数据开辟到堆区返回的直接是地址 int * p = new int (10) ; // 指针本质在栈区，其数据在堆区 2. new // 返回的是该数据类型的指针 int * p=new int(10) ; // 创建了一个new型为10的变量地址 (释放 delete p;) 3. int * array = nem int[10]; // 创建了一个变量为整型个数为10的数组，他的首地址给了array (释放数组 delete[] arr;) 4.// 引用：就是给变量起别名 // 语法：数据类型 &amp;别名=原名 对别名进行操作等于对原名的数据进行操作 int a=10; int &amp; b = a; b = 20; // 那么 a也为20 5. // 引用的注意事项 // 1) 引用的时候必须要给予初始化 int &amp; b = a; (引用过程给予初始化，只有这一种写法) // 2) 引用一旦初始化后，不可更改 6. // 引用也会使得形参修饰实参 void my3(int &amp;a,int &amp;b) // 有两种解决办法 指针 和 引用 // 注意事项: // 1 )不要返回局部变量的引用 int &amp;test() { int a=10;return a; } // 2 )函数的调用可以作为左值 int &amp;ref=test(); test()=100; cout &lt;&lt; ref &lt;&lt; endl; ref = 100; 7. //引用的本质是一个指针常量 int a=10; int &amp;b = a; // 相当于 int * const b = &amp;a; 这也就是为什么引用不可修改，因为指针常量的指针指 向不可修改(b中保存着a的地址) cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl; a = b = 10; // b = 20解引用 也就是*b = 20; 8. // 常量引用 // 引用的两种写法 // 1 ) int a=10； int &amp; b = a // (必须为名称，不能为10)； // 2) const int &amp; b = 10; // 第二种相当于编译器系统设置了一个变量 int temp = 10； const int &amp;b = temp； b = 20 // (这是错误的，因为加上const 之后变为只读不可修改状态) 9. // 函数默认参数 优先用户自定义的 int fun(int a,int b=10,int c=30) { return a+b+c; } main { cout &lt;&lt; fun (10 , 30 , 30 ) ; } // 70; // 当某个位置有了默认参数，那么他后边都必须是默认参数(例如 b为默认参数，那么 c 也必须是默认参数) 10.// 声明和实现 只能有一个有默认参数 int fun (int a = 10,int b = 30); int fun(int a , int b) { return a + b; } // 40 11.// 占位参数（只有函数类型，没有名字） void fun ( int a , int) { cout &lt;&lt; ” abc ” ; } // 引用时fun(10 , 10) 占位参数还可以有默认参数 void fun(int a , int = 10) { return “ abc ” ; } // 引用时 fun( 10 ) 12. // 函数重载(函数名可以相同) // 条件 : 同一个作用域下 函数名称相同 函数的参数类型不同 或者 个数不同或者顺序不同 // 注意：函数的返回值不可以作为函数重载的条件,如下 void fun ( ) void fun(int a) void fun(double b) 未完待续…","categories":[{"name":"c与c++","slug":"c与c","permalink":"http://yoursite.com/categories/c%E4%B8%8Ec/"}],"tags":[]},{"title":"c与c++知识点(二)","slug":"C与C++笔记2","date":"2020-03-14T04:49:16.000Z","updated":"2020-06-01T11:24:58.271Z","comments":true,"path":"2020/03/14/C与C++笔记2/","link":"","permalink":"http://yoursite.com/2020/03/14/C%E4%B8%8EC++%E7%AC%94%E8%AE%B02/","excerpt":"","text":"这是我自己在学习c++基础的过程中，顺便复习了下C语言，然后总结的一些小小知识点。—写在前面的话第二节1./*二维数组 总元素*/ sizeof ( arr ) ; /* 第一行元素 */ sizeof ( arr [0] ) ; /* 行数 */ sizeof ( arr ) / sizeof ( arr [0] ) /* 列数 */ sizeof ( arr [0]) / sizeof( arr [0] [0] ) ) 2./* 二维数组首地址 */ cout &lt;&lt; arr &lt;&lt; endl; /* 第一行首地址 */ cout &lt;&lt; arr [0] &lt;&lt; endl; /*第一个元素首地址 */ cout &lt;&lt; &amp; arr [0] [0] &lt;&lt; endl; // 此三者相等三者相等 /* 第二行首地址 */ cout &lt;&lt; arr[1] &lt;&lt; endl; 3./*指针就是地址*/ int *p; （p为指针变量） //使用时需要解引用 *p 即可 ( *p解引用） 4./*空指针: 用来给指针变量进行初始化，空指针不可以进行访问的*/ int *p = NULL; //不可再将地址赋值给 p 输出 5.const修饰指针 ---重点 1）const修饰指针---常量指针 2）const修饰常量---指针常量 3）const既修饰指针又修饰常量 6.—重点—//1）常量指针 const int * p = &amp;a; /*指针的指向可以修改，但是指针指向 的值不可修改 */ //2）指针常量 int * const p = &amp;a; /*指针的指向不可以修改，指针的值可以修改 */ //3）既修饰指针又修饰常量 const int * const p = &amp;a; /*指针的指向和指针的值都不可以修改 */ //（如何记忆: const—常量 ，* p —指针 如何用：紧接着 const 的是p / * 紧跟着谁 谁不能操作） 7.int arr [10], int * p; p = arr ; cout &lt;&lt; *p; //（数组的名称为其的首地址) 8.值传递，不能修改实参的值，只能修改形参的值。地址传递可以修改实参的值。9.结构体struct student/**** 自己创建的结构体类型为 student, 此类型的变量名字为s1, s2 ***/ { string name; int age; int score; }; //1 struct student s1; //2 struct student s2 = { }; //3 创建结构体时顺便创建结构体变量,通过.来访问结构体中的属性 10.结构体创建自定义类型过程中struct不能省略，但是创建变量的过程c++ struct可以 省略11. // 结构体数组 struct 结构体名字 数组名字{个数}={ { }，{ } ，{ } } // 结构体指针 利用-&gt;可以通过结构体来访问结构体的属性 student s1 = { &quot;李斯&quot;,56,99 }; student * p = &amp;s1; cout &lt;&lt; &quot;姓名:&quot; &lt;&lt; p-&gt;name &lt;&lt; &quot;年龄:&quot; &lt;&lt; p-&gt;age &lt;&lt; &quot;分数&quot; &lt;&lt; p-&gt;score; 12.结构体嵌套结构体 struct student { string name; int scroe; }; struct teacher { int id; string name; int age; struct student s1;//学生 s1 }; teacher t; t.id = 10086; t.name = &quot;老王&quot;; t.age = 58; t.s1. name = &quot;小王&quot;; t.s1.scroe = 99; teacher * p = &amp;t; cout &lt;&lt; &quot;老师姓名：&quot; &lt;&lt; p-&gt;name &lt;&lt; &quot;老师工号: &quot; &lt;&lt; p-&gt;id &lt;&lt; &quot;老师年龄: &quot; &lt;&lt; p-&gt;age &lt;&lt; &quot;老师的学生名字: &quot; &lt;&lt; p-&gt;s1.name &lt;&lt; &quot;老师的学生分数: &quot; &lt;&lt; p-&gt;s1.scroe; 13. 结构体中使用const来防止误操作14.—重点—main里面调用函数，形参相当于把参数复制了一遍，增大了储存空间和代码量。将函数的形参变为指针，可以大大减少内存的占用（指针不会复制数据，其只是进行地址传递）15. system( “ pause ” ); //请按任意键继续 system( “ cls ” ); //清屏操作 未完待续…","categories":[{"name":"c与c++","slug":"c与c","permalink":"http://yoursite.com/categories/c%E4%B8%8Ec/"}],"tags":[]},{"title":"c与c++知识点(一)","slug":"C与C++笔记1","date":"2020-03-09T04:49:16.000Z","updated":"2020-06-01T11:24:49.257Z","comments":true,"path":"2020/03/09/C与C++笔记1/","link":"","permalink":"http://yoursite.com/2020/03/09/C%E4%B8%8EC++%E7%AC%94%E8%AE%B01/","excerpt":"","text":"这是我自己在学习c++基础的过程中，顺便复习了下C语言，然后总结的一些小小知识点。—写在前面的话第一节1.int a; sizeof(int) = sizeof(a); ---求所储存的字节 2.float aa = &#39;A&#39; cout &lt;&lt; (int)aa &lt;&lt; endl; //输出A的数值(强制转化为 int) 注意格式 3.float f2 = 3e2 //3*10^2 float f3 = 3e-2 //3*0.1^2 4.bool 真或假 bool flag = false/true(0/1); —除了0为假，其余都为真5.字符串&nbsp;&nbsp;(1)char str[ ] = &quot;hello world&quot; cout&lt;&lt;str&lt;&lt;endl; &nbsp;&nbsp;(2) string 变量名 =”字符串值” （引用头文件include“string” 有的是在iostream头文件中）string name[3] = {&quot;张三&quot;,&quot;李四&quot;,&quot;王麻子&quot;}; string name=”胖虎”； 6.int a1 = 10; ++a1*10; //(运算结果为110)先加1后乘以10， int a1 =10; a1++*10; //(运算结果为101)先乘以10 后加1，先执行表达式，再增加 7.-= /= %= int a=10; int b=5; cout&lt;&lt;(a==b); //输出结果为0(假) 8.rand() % 80; //生成0-79的随机数 rand() % 80+1; // 生成0-80随机数 /* 需要包含头文件 #include “cstdlib” */ // #include ”ctime“ (伪函数) srand((unsigned int)time(NULL)); 利用系统时钟生成伪数字 9.int a = 10; int b = 20; (a&lt;b?a:b)=100; cout &lt;&lt;a; a=100 cout&lt;&lt;b; //b=2 10.int a = 354; //个位 a%10 十位 a%100/10 百位 a/100 11. \\t 制表符代替空格 12.goto flag ； flag： //跳转语句 ---读懂就可，不建议使用 13./*数组*/ int arr[5] = {1,2,3,4,5} /*每个数组占用的内存空间*/ sizeof(arr) /*每个素占用的内存空间 */ sizeof(arr[0]), /*数组中元素个数为*/ sizeof(arr) / sizeof(arr[0]) //------重点 14./*数组地址 */ int arr[5] = {1,2,3,4,5} /*数组首整型地址*/ cout&lt;&lt; (int)arr; /*第一个元素整型地址*/ cout&lt;&lt;(int)&amp;arr[0]; //------重点 15.冒泡排序法void fun(int c[], int d) { int temp=0; for (int a = 0; a &lt; d - 1; a++) { for (int b = 0; b &lt; d - 1 - a; b++) { if (c[b] &lt;c[b + 1]) { temp = c[b]; c[b] = c[b + 1]; c[b + 1] = temp; } } } } 未完待续…","categories":[{"name":"c与c++","slug":"c与c","permalink":"http://yoursite.com/categories/c%E4%B8%8Ec/"}],"tags":[]},{"title":"MDK、KEIL的兼容与破解","slug":"MDK、KEIL的兼容与破解","date":"2020-03-02T04:49:16.000Z","updated":"2020-03-29T13:50:29.084Z","comments":true,"path":"2020/03/02/MDK、KEIL的兼容与破解/","link":"","permalink":"http://yoursite.com/2020/03/02/MDK%E3%80%81KEIL%E7%9A%84%E5%85%BC%E5%AE%B9%E4%B8%8E%E7%A0%B4%E8%A7%A3/","excerpt":"很多人可能有和我一样的经历，刚刚学完51单片机就转手来学32开发板，可面临的第一个很尴尬的问题就是KEIL和MDK不能同时兼容存在，自己想学32就要用到MDK,可又放不下刚刚捧热的”情人”keil”","text":"很多人可能有和我一样的经历，刚刚学完51单片机就转手来学32开发板，可面临的第一个很尴尬的问题就是KEIL和MDK不能同时兼容存在，自己想学32就要用到MDK,可又放不下刚刚捧热的”情人”keil” 第一章其实keil和mdk的共存是很简单的，话不多说，下文直接上硬菜(附keil&amp;mdk的安装包)先在d盘创建英文的文件夹(名件名为英文的是为了防止在后续的开发中出现莫名奇妙的警告错误信息)我创建的文件名称为 MDK5 然后打开我们mdk的安装包，按照顺序将程序安装到d盘MDK5的路径下(安装包文末会提供)（以32的f4包来举个栗子） 第二章请务必按如下顺序安装：安装MDK521A安装Keil.STM32F4xx_DFP（安装过程中需要输入的用户名字和Email可随意填写） 然后打开我们keil的安装包，将程序安装到d盘MDK5的路径下(安装包文末会提供)（两个安装包安装路径一定要相同） mdK和KEIL是安装在同一路径下，使用同一个桌面快捷方式，接下来教大家如何分别创建51和32新文件. 第三章双击打开我们的keil,Project -&gt;第一个New uVision Project当我们需要写32代码时，选择下面如图这个选项，然后选择相应的芯片来写代码。 当我们需要写51代码时，选择下面如图这个选项，然后在Atmel中选择stc89c52来写代码 在文章的结尾我为大家分享下keil&amp;mdk的安装包软件keil&amp;mdk安装包链接：https://pan.baidu.com/s/1IPHFC7OMV42ard_GX4LL0w提取码：rrki如果链接失效，请留言进行补充(小白的第一篇博客，不喜勿喷，若有不足之处，还望多多指出,谢谢！) 喜欢就常来看看呗，武汉加油，中国加油噢","categories":[{"name":"单片机","slug":"单片机","permalink":"http://yoursite.com/categories/%E5%8D%95%E7%89%87%E6%9C%BA/"}],"tags":[]}],"categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"},{"name":"opencv视觉","slug":"opencv视觉","permalink":"http://yoursite.com/categories/opencv%E8%A7%86%E8%A7%89/"},{"name":"视觉Slam","slug":"视觉Slam","permalink":"http://yoursite.com/categories/%E8%A7%86%E8%A7%89Slam/"},{"name":"c++","slug":"c","permalink":"http://yoursite.com/categories/c/"},{"name":"STM32","slug":"STM32","permalink":"http://yoursite.com/categories/STM32/"},{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"http://yoursite.com/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"},{"name":"c与c++","slug":"c与c","permalink":"http://yoursite.com/categories/c%E4%B8%8Ec/"},{"name":"单片机","slug":"单片机","permalink":"http://yoursite.com/categories/%E5%8D%95%E7%89%87%E6%9C%BA/"}],"tags":[]}