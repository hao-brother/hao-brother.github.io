{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[{"title":"旺仔计划","date":"2021-06-22T04:49:16.000Z","updated":"2021-06-27T00:40:01.119Z","comments":true,"path":"她.html","permalink":"http://yoursite.com/%E5%A5%B9.html","excerpt":"","text":"吸引我的，是你的温柔，负责任的眼神，认真学习的态度，但又活泼的日常。华晨宇说：“你遇到一个女孩子.你想跟她谈恋爱.你很喜欢她.这才叫做谈恋爱.而不是某个时期.你想谈恋爱.所以去找了一个女孩子.这只能证明你寂寞”“遇见你是上天的安排，喜欢上你是我情不自禁。只要你要，只要我有，尽我所能，倾我所有”。我阅读查理芒格、影响力、小狗钱钱等经济书、研究行为学规律，看同货膨胀，汇率等金融知识，慢慢学着理财、炒股。因为我明白，富人之所以为富，不是他们财富多了才是富人，而是他们脑海中的思维意识、知识储备起决定因素，暴发户可能一时有钱，但若干年后，他们的资本也会通过各种殊途流入到资本富人的手中，我觉得他们少的就是那种支配与拥有财富的能力，能力、眼界、知识储备决定了你的阶级与财富。可能你会觉得我很俗，各种挣钱(电信公司上班、跑外卖、水果店上班、代做毕业设计/论文 、卖对联(自己的爆竹)、咸鱼贩卖东西,QQ群贩卖资料、百洁、炒股、一对一辅导课程等)，但，我想说的是，在以前我看到过一篇文章里的一句话: 在遇到合适的另一半的之前，我们要做的，就是保持自己足够的优秀，然后攒好一起消费的备用金，给彼此一个稍微舒坦无忧的未来。这一点我记得很清楚，并且也早已经开始积攒了，就是时刻准备着迎接我的她。可能这不是很多(猜猜它会有多少？)，但却是我自己自己挣的，也算能够解一些燃眉吧，画自己的钱真的很酷，6400的电脑，1799的平板都是自己的钱买的，哈哈。男孩要穷养，以后才会知道生活的不易，和对家庭负责，我只想给你稳定，值得依赖的未来。不该在考研自习室经常性的漠视你，却又一直在背后偷偷看你学习的背影，我想，这便是懦弱吧。我应该多经常的和你打打招呼，关心日常，饿了递专门为你买的饭，渴了为你买水，还有时间，我还有机会，你一定要等我， 我不要你被别人牵走了ヽ(‘⌒´メ)ノ4.19 1 奥迪(尽量要有自己的一辆，我自己觉得吉利o2/o3型就很酷) 2 奶茶要少放糖，记住了(奶昔 桃囍) 她喜欢 吃东区还有大学城的烤饼 3 她的眼睛干涩，近视加深 解决办法，晚上不能让她熬夜，同时补充维生素B，汤臣倍健，蓝光眼镜，更重要是晚上不能熬夜。建议给她买汤臣倍健，还有蓝莓，黑枸杞。 更重要的是她睡觉轻，平常要多留意安神助睡的方法与实物等，给她分享。4.20 1.平常要多注意关心她，占占位置之类的，可不能冷落或者打扰到各自复习。 2. 思考题：男人有了事业在谈恋爱，还是先谈恋爱在谈事业？ 立业是年入XX万以上吗？ 成家是结个婚就完事吗？想明白了就有答案了 立业是半辈子的奋斗 成家是一辈子的付出不管是事业机会还是恋爱机会，谁来了，就勇敢并且机敏的去抓住！ 多想告诉你，手机壳里的宝通寺门票可以扔了噢，我不该给你说，我要先立业后成家，我都要。我想一直在你旁边，可这会影响复习，还有一年多时间，每天憧憬还能上课坐后边看看你学习背影，真的很棒噢，加油，好好学习，一战成研。3.和你聊天背景特设为你的照片，聊天记录我要保存一年，哈哈，这个我可是给你说了，申请版权啦。看到你和猛哥这个男生聊天，我真心吃醋了啊，心里很是别扭，呜呜呜… 我才不要你给他贴钢化膜，就是吃醋了，我立马给他都贴好了，不比你贴的差呢，嘿嘿。不许以后冯治愈对你动手动脚，俺都不忍心啊，委屈你了。4.21 1.眼睛好了，你说是戴隐形的原因，结果还一直说上课听不懂，一直想睡觉，哈哈。 2.好好学习专业课，我要帮你复习，才不要每次复习都要你整理，这学期我要帮你复习。3.茫茫人世中，你是晚来风。 4.给了你河师大上岸激励图，要加油噢。考完研，不要让她等太久。5.多想给你说，四价HPV费用我要给你出了，但我怕，怕你会怀疑我图谋不轨，哈哈，我就是图谋不轨了，嘿嘿，这个费用我一定要给你出，你不用问家里人再要啦。4.22 一定要带她去看海底世界，她很喜欢那个，小本本记下啦(郑州的好像被她吐槽了，那就不去那个了，我看好了，就去西安的曲江的吧，差旅费准备好了噢，两人1.5k两天应该是够了)。2.表白后，给她买纯金耳钉，就是现在戴的那种，圆圆的(她一直戴着这种，可能是喜欢这种简洁优雅的款吧)，我的老婆就得用好的呢，(买金的费用已经攒够了，计划3k左右) 我的疏忽，让她中午没吃饭就来实验室加班了，下午特地为她买零食藏书包里，以后遇到她饿了就拿出来。 4.我在想我这算是暗恋吗？我不止一次的展望过我们的未来，虽远但必达，考上研，一起开开心心学习，工作，攒彩礼，去你家提亲，考不上的话，我会去做生意，积累经验，然后开一家店，等你毕业送给你，让你做老板娘，让我的孩子是富二代。4.23 想要得到你，必须忘记你，提升自己 靠的是吸引，而不是舔。找到自己努力的方向，做好自己，加油。和四年前一模一样的情形，这次又该怎么样做呢，我想这次的心中早已自有答案。自我反省: 我会努力学习，凭借实力去吸引你，而不是靠关心博得关注，我强你就弱，这样才能给你个坚实的肩膀呀，让你的温柔流露心田。看行动吧。 4.25 你个笨笨，那么多专业课，还赶上党课笔记… 反正我心疼了噢，那个考试专业课我学学，考前教你，你安心学习教科吧，我一定要努力强大起来，给你个依靠。大笨笨，还问我感冒发烧好了么，竟然让我多喝水，哈哈哈，这是直女嘛？哈哈(ಡωಡ)hiahiahia 4.26 你还有好多书没复习，那书我看了真的是心累呀，笔记做的很认真噢，赞个呀，加油加油，晚上帮你整理比赛照片，帮你省点时间，竟然晚上头次说了 晚安，哈哈，那就我高冷的不回了啊，懒猫快睡觉，嘿嘿😁 4.28 听从党的指导，五一回家，哈哈，光速看票，买票，走之前要给她晕车的药，要好的，我记得有香港产的，效果能好点，她无意间说她是汽车回家的噢，这个可不能忘了。然后回家，摘好的漂亮的樱桃，专门为她带过来，嘿嘿。 4.29 拖老姜给她带去了晕车药，她来谢谢我啦，尽管刚到家门就被锁在门外，但已经很开心呀。苦尽甘来的那一天，山河星月都作贺礼。我无悔我的选择，但我必须学会放弃一切4.30 自认为我自己的运气一直不算差，从小到大 遇到过许多对我有启发与指明的各类人物。从比完赛到现在，有过很多对你的回想与思念吧，同时自己也有对未来的迷茫，在这次回家种种事情中我逐渐的明白了，想清楚了很多。/*****/ 回家坐的是郑州凌晨2点四十多的站票车，我站在车站的靠近衔接口处，有位大哥是洛阳的，搞得也是电气(主要从事也是接电工作)，我旁边的灵宝女生，竟然也是电气工程专业的，与那个大哥一下聊到凌晨四点多，和他的一番交流，我渐渐真的明白了许多许多，我当下面临的诸多疑惑慢慢全被解开了(择校，地域，学历，恋爱观念，对收入看法，经济收入支配等问题)，真心的谢谢他。他虽然挣的不是太多，但他的各种观点我可以感受的到，是肺腑之言，他的老婆，算不得好看，我同样也没有资格去评头品足，但我体会到他们之间的恩爱，他为她买的大足金的耳钉，我也要给你买。等我！大哥洛阳站便下车了，提前半个多小时让我坐他那里，但是坐了一会，洛阳站又上来了他的那个位置的人，我又没座位了，站了一会，14车厢的列车长，专门给我说，旁边的六个位只卖出了五个，有个是不卖的。但是那六个位全满了，也就是有个人没位但坐了那里，他专门查了下，让那个没位的人站起来，离开，让我坐那，我开始愣傻了，然后急着说，没事儿，他以为我没听到，语气很是温和的又重复了一遍(是个大哥哥噢)，旁边那么多的人(好多放假回家的学生)都没有座位，在站着，结果，他只对我说让我坐那，还重复了两遍，他们还看着我，顿时感觉我自己，像是被团宠了一样，哎呀，只好羞答答的答应，让人怪不好意思嘞，乖乖坐那里，嘿嘿。 /*****/ 可能以后和你扣字交谈次数会少很多，但有什么心里话我都会写下来，考完研再给你看，我要让你以我为傲，就像RM一样！不打扰，是我最后的温柔。/*****/ 5.1 我在家可是学习了噢，复习了单词还有看了线性代数，嘿嘿，偷偷学习超过你。返校给你带樱桃。 5.3 你个可爱的小家伙，哈哈，返校了后到处去跑，不应该是神兽归笼嘛，安安稳稳的么？跑去和同学去玩，不学习嘛，哼，提出严重的交涉噢，两条小腿倒腾的开嘛，一直逛啊逛。哈哈哈，奇奇怪怪，可可爱爱。 摘的樱桃给你送过去啦，你还专门给我发图书馆的位置，你要笑死我嘛，我可能路痴，但图书馆还是可以找的到滴，还有就是不用说谢谢噢，特地专门买的保鲜盒包装的，美中不足的就是室友一直从中捏走偷吃，呜呜呜(┯_┯)偷偷告诉你奥，从网上看到，要追优秀的小姐姐(比如你呀)，就得自己更优秀，更自律，更爱干净(我知道你是处女座的，特别爱干净噢)，RM的视觉我来接担子啦，视觉还有工程我来负责，考完研就上手，现在这几天已经开始慢慢重学C++啦，学完这个，再看看opencv 视觉我就可以搞啦，以前整过，这次应该不会很费力气。我会努力的，让你以我为傲。这几天已经可以全身心投入到学习了，那种状态真的很棒，人书合一，哈哈，是真的，那种学习的感觉，真的很nice。 缺钱我就去挣钱(外接项目，炒股基金，咸鱼贩等等)，缺能力我就去学，学习专业课去给你讲，学习高数，英语，学习c++ opencv 提高自身能力，缺啥补啥，我就是想要你不被别人牵走，等我好吗？就七个月。很多很多道理我都明白，但我表达不出来，只能用行动来展示了，一起加油噢。以后线上联系可能会少很多，毕竟各自都在努力噢，你也要加油呀，不要被我超过太多呀，嘿嘿，就是这么自信。 5.6 今天全身心投入学习，完成了高数笔记，EDA复习等 5.8 专门为你买的保鲜盒包装樱桃，被你用来盛饭啦，哈哈，我不嫌弃你胖嘟嘟的，一点也不，要对自己好一点噢，今晚我应该问你吃饭了吗？结果又害你九点多才吃饭，我反省。晚上给你分享啦刚刚看到的小米应用，应该可以缓解你的轻睡眠，我可是操碎了心呐，知道吗，宝宝？ 哈哈&lt;(｀^´)&gt; 还有还有就是今天我调戏你啦，嘿嘿，心里很开森，给你送plc课本(专门给你挑的一本白白净净没有批注的书)，问你是几楼学习，你回答啦是8，然后我应啦 哎，哈哈哈，你还没反应过来，我没笑，真的，除非是真的忍不住，嘿嘿，说好的，可不许生气啊，嘿嘿，”好儿砸”😊 走的时候，好像看到你的同学她在卫生间门口等手干，我那会去的时候她不在。我真的只想好好照顾好你，但我必须努力提高自己，优秀的吸引你，等我，我会继续挤时间努力加油的。5.10 完成了高数*10，看了继电保护的一二段电流保护，还有EDA课后题编程。给你分享了EDA课后答案(怕中午吵醒你，没敢发，下午才发-喜欢的很小心翼翼)还有继电保护作业题。 5.11 你打电话给我，询问照片，我急着赶去09给你弄，并且让你放心，一切交给我。但你说，已经借到电脑弄好了，我怕格式小不合格，又专门拐回宿舍给你弄，也都发过去，来来回回耽搁三个小时复习时间，最后的结果就是，音沉大海，连句收到也没，哈哈，其实我也明白，以前和你聊天，可能会有点不耐烦，也是我耽搁你休息还有复习了，这一切的一切，都是我自作多情，自我感动罢了。我真的真的真的很讨厌这种熟悉难受的感觉，我知道你平常连和我说句话的时间也都没有，然而我却常常幻想未来”与你共黄昏，问你粥可温” 我怕可能是这个时代太坏了，感情泛滥，语言没有重量，随便说出口的喜欢与爱，配不上一颗赤诚的心。于是我将它写了下来，向你走了99步，最后一步你会走向我吗？ 我想和你联系，却又怕打扰你； 我想要缠着你，可又想放弃你； 我试着离开你，却又怕失去你，放不下的是我自己；我以为只要我等你够久，你就会感动。后来我发现，你可能并不缺我，我想对你说的话欲言又止，想找你的心寸步难行。我本来已经习惯了一个人，可我遇到了你，而你却让我知道了，我真的很差劲，连倒贴都没人要。我自己都讨厌自己，更何况是你，你不喜欢我也很正常，怪我自己自作多情，最后输得一塌糊涂。 5.13 今天的你身体虚弱，出虚汗，我想给你送药，但却被拒绝了，仅仅给了一点点的修养建议，也说了一些从学姐那学的经验，但我怕说的太多又被嫌弃与冷漠，那我应该怎么办？ 5.14 不就是考研和追你嘛 两件事，一件件的做，等我，我就是想要你。 5.19 “你对象？”“嗯”昨天被甩锅，今天遇见你和你对象，哈哈。彻底崩溃，也很难受。祝99。 5.23 对不起，我不该又想你了 5.25 跟着宝藏老师，高数学的是真的厉害。 今天下午我向你道歉，结果，你说分手了，真的别是一番滋味在心头，心里为你难受，却又为你不会被人欺负而略带欢喜，真的好难受。 5.31 小计 本周小结，我想不通明明自己早已经心性看穿恋爱和各式关系，那些画各色的妆，去见各样的人，充满消费主义的男生与女生，已经本不会和其一路，但逐渐又偏了自我(耐克，阿迪，苹果等一系列衣用品，几K而已，分分钟可买，单靠自己消费那些足矣，但大部分消费那些的人还有买莆田系列产品的目的又是何在呢？是为了打球更厉害，还是别人投来羡慕的目光，借此优越感形成上下阶级感吗？没有必要，不需要借此来包装自己，这是消费主义社会，任何人都逃避不了，唯有能做的是做好自己，遵从内心的感受，这便足矣) 当你左知感情右知生活，遍经殊历，看透人心善变，懂得利益套路时，心里就会明白，才会知道最终靠的住的永远只有自己和那攥在手里的钞票——你不知道我走过怎样的路，但我想这便是我以前最好的总结吧。我想为你买金饰，买漂亮贵贵的裙子，买香奈儿，迪奥，想把一切最好的留给你，那我这算是喜欢还是舔？一边喜欢着你，一边又说服自己暂时放下你。拿得起放得下，不乱于心，不困于情，不念过去，不畏将来。你开心回眸笑语与招手，我是真的好喜欢啊，心里开满寒冬的花。 努力做好自己，不认命，那就拼命，至于其它的，就交给时间和缘分吧！ 6.2 哇哇哇，今早上课来迟到，被点名记旷课，你发信息，和打QQ电话，然后直接电话打来，询问信息，还中途催我快快的到，被你关心的感受，真的很开心⊙▽⊙ 被记不记迟到，旷不旷课无所谓啦，我就当你是你关心我啦，反正，我开森了一整天☺️，嘿嘿，我就是这么没出息，唉╯﹏╰ 还有你竟然知道昨晚我逃课，室友替答到，反正，我就是你的人啦。 各自好好努力噢，等考完研，我追你，好不好。 6.4 我该不该放下你呢？早上包里给你带了防晒霜还有扎的娃娃(想当做端午礼物)，打算放到你的桌子上，想想，还是算了吧，虽然我也舍不得，出场顺序很重要。要是之前知道你有这样一位好朋友，我是决不会喜欢上你的，毕竟我也得对得起他。前几天我把书从六楼挪走了，那里留给你们吧，学着慢慢放下你，为他留位，微信记录一直没删，每日看一遍祝99，他比我更适合。 6.22 你对我两次深深的欺骗，我该相信你吗？余生最憎恨欺骗。一次误删，我问同学：很重要的人闹了矛盾后，将其删了，并说是误删，这是误删吗？同学给我说，根本不存在误删这种情况，所以，很难受，我很难再相信你。我必须离开，为何一次次打破我的幻想，让我伤的遍体鳞伤。你随他吧，QQ申请就没必要了，这份伤我自己去默默承受。敢保证的是，以后未来，你再难遇到我这样，一直为在一起的未来而努力的，努力的学习，努力规划可视的未来，努力攒那份彩礼，努力的给你我能给予的一切，努力… 再会。 共5766字 毕。"},{"title":"categories","date":"2020-03-28T12:50:44.000Z","updated":"2020-03-29T03:25:06.161Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"search","date":"2020-03-28T12:55:50.000Z","updated":"2020-03-28T12:56:19.471Z","comments":true,"path":"search/index.html","permalink":"http://yoursite.com/search/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-03-28T12:52:27.000Z","updated":"2020-03-29T03:27:15.002Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"H-bの博客","slug":"H-bの博客","date":"2021-06-23T04:49:16.000Z","updated":"2021-06-26T23:32:51.358Z","comments":true,"path":"2021/06/23/H-bの博客/","link":"","permalink":"http://yoursite.com/2021/06/23/H-b%E3%81%AE%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"天苍茫而路漫兮，岁月将行。九死生而笑看兮，且吟长歌。","categories":[],"tags":[]},{"title":"蓝桥杯单片机","slug":"蓝桥杯单片机","date":"2021-01-06T04:49:16.000Z","updated":"2021-01-10T07:08:20.916Z","comments":true,"path":"2021/01/06/蓝桥杯单片机/","link":"","permalink":"http://yoursite.com/2021/01/06/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8D%95%E7%89%87%E6%9C%BA/","excerpt":"","text":"一、 准备知识首先要复习下C语言知识，不用全面复习，简单复习下单片机经常用到的知识就行（自行百度以下的简单语法的用法就好，先留个印象，以后碰到不会了随查就好） ​ 1. 引用头文件 #include &#39;&#39;头文件&#39;&#39; #include &lt;头文件&gt; 宏定义 #define uint unsigned int #define uchar unsigned char 二进制、十进制、十六进制的相互转化 if语句的基本语法(if–else、if–else if等) for语句的基本用法 while语句的基本用法(一般是while(1)，其次是whil(!a)等) switch语句的基本用法(协同break语句) 一维数组的定义和调用里边存储数据 &amp; 、| 运算 函数的调用(函数的声明、调用、形参和实参，虚空和带有返回值参数的区别及使用) .c .h文件的区别及其调用、使用 全局变量定义和使用 (剩下的c语言知识，在写代码遇到后，简单查询下用法就好) 二、单片机学习篇​ 1、编译环境的搭建(keil 的安装、单片机的驱动安装、stc15f2k60s2库的添加、stc的使用) 这些东西在csdn上都有前辈发的步骤图片贴子，这里不多叙述。 ​ 2、单片机入门学习 ​ 我自己是根据网上开源的免费资料进行入门15单片机学习的，我的同学是购买的人家录好的视频学习，这方面就看自己的选择了。 ​ 首先说说我看的资源，在哔哩哔哩动画上面，欧老师的小蜜蜂笔记，链接如下，刚开始看的时候，最好不要快进，可能头次接触，会有点懵，可以反复听听。学习单片机一定要自己动手练习，一定要自己动手练习，一定要自己动手练习，同时还能够增加自己的自信感。 https://www.bilibili.com/video/BV1Bt41187hw?from=search&amp;seid=15982805789821873450 ​ 我的同学购买的是淘宝上大科的0基础视频，链接如下，视频无法共享，因为视频被加密需要专门的播放器播放，每个电脑有个专属的播放码，共享了也无法观看。 https://item.taobao.com/item.htm?spm=a1z09.2.0.0.310a2e8dK1rK9x&amp;id=558493290924&amp;_u=a2coppc9d534 ​ 3、省赛真题练习 ​ 1.刚开始学完单片机后练习省赛的题，感觉很难，是因为，在学习时是按模块学习的，而比赛是直接给你个小项目让你来完成(单位时间内)，一下两种思维的转变很让人头疼。那时候俺为了走捷径，省时间，直接买的大科的省赛真题讲解，阅读完题目后边看视频边打代码，然后关了视频自己想想本届赛题的逻辑是什么，都考察那些模块，模块之间如何联通，然后关了视频和刚刚自己写的代码，重新再写，就这样看了三四届练习了三四届后，就会有自己的感觉了，接下来的几届俺都是先自己审题，然后练习编写，哪里不会了再看视频的讲解，然后接着写。我的这种方法可能有点投机取巧的应试教育理念在里边，但改变不了教育体制那就只能慢慢适应了。 ​ 2.一般的练习都是从最开始的第三届开始练起，那样能感知每届题的难易变化和考察的侧重点，每届题都要认认真真的做，不能敷衍马虎噢，在比赛前，尤其是底层驱动代码的改写，自己一定要特别特别的熟练，一天练几次，底层驱动代码一错，模块功能实现就有问题了。切记！切记！切记！(给的资源包内有我以前写好的省赛驱动) ​ 3.如果省赛学完自我感觉还好的话，可以做做国赛的题，用国赛的标准来准备省赛是绝对没有问题的，国赛的话就不要购买大科的国赛视频了，讲的很不好，被很多人吐槽。 ​ 4.省赛视频补充，除了大科的省赛的视频讲的不错，还有电子设计工坊的省赛讲解，也很不错，可以看看，不过需要付费，看个人所需了吧，链接如下 https://shop102956872.taobao.com/?spm=a230r.1.0.0.1a9d1304DzgjcO 三、客观题部分​ 1、客观题主要是考察模电、数电、单片机基础的知识，有点杂且多，不好准备，所以建议是考前两周左右再看，这里我给了模电和数电的学习资料，如下 链接：https://pan.baidu.com/s/1lCQETyfPWztRS5dPJM3CYw 提取码：vw67 复制这段内容后打开百度网盘手机App，操作更方便哦--来自百度网盘超级会员V3的分享 2、官方出售的蓝桥杯指导书的电子版如下，里边包含客观题的答案及其省赛部分代码的解析 链接：https://pan.baidu.com/s/1hK30RC97HXpgMlq08LfL7g 提取码：e8j9 复制这段内容后打开百度网盘手机App，操作更方便哦--来自百度网盘超级会员V3的分享","categories":[],"tags":[]},{"title":"爬虫","slug":"爬虫","date":"2020-08-01T04:49:16.000Z","updated":"2020-09-04T08:50:47.432Z","comments":true,"path":"2020/08/01/爬虫/","link":"","permalink":"http://yoursite.com/2020/08/01/%E7%88%AC%E8%99%AB/","excerpt":"","text":"1 print(&quot;www&quot;,&quot;baidu&quot;,&quot;com&quot;) #输出 www baidu com print(&quot;www&quot;,&quot;baidu&quot;,&quot;com&quot;,sep=&quot;.&quot;) #用点代替空格 输出www.baidu.com 2 强制类型转换 c = int(input(&quot;shuru:&quot;)) #注意input 默认输入为str(字符型) print(&quot;shuruyigeshuzi:%d&quot;%c) #输出整型数字 3 成员运算符 in #在序列中找到，返回True,否则返回False not in #没有在序列中找到返回True,否则返回False 4 身份运算符 is #判断两个标识符是不是引用一个对象，是为True,否为False is not #判断两个标识符是不是引用不同对象，是为True,否为False 5 随机数 import random x = random.randint(0,2) #随机生成[0-2]的随机数，包含0，1，2 print(x) 6 for循环 ​ (1) for i in range(5): print(i) #打印出 0 1 2 3 4 一共循环了五次 ​ (2) for i in range(0,10,3): print(i) #打印出 0 3 6 9 从0到10，每次增加3，然后打印出来 name = &quot;chengdu&quot; for x in name: print(x,end=&quot;\\t&quot;) #打印结果 c h e n g d u a = [&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;,&quot;dd&quot;] for i in range(len(a)): # len(a)=4 长度 print(i,a[i]) &quot;&quot;&quot;打印结果如下 0 aa 1 bb 2 cc 3 dd &quot;&quot;&quot; 7 while i = 0 while i &lt; 3: print(&quot;第%d执行&quot;%(i+1)) print(&quot;i=%d&quot;%i) i += 1 &quot;&quot;&quot;打印结果如下 第1次执行 i=0 第2次执行 i=1 第3次执行 i=2 &quot;&quot;&quot; 8 break continue pass break: #语句可以直接跳出for和while循环体 i = 0 while i&lt;10: i += 1 print(&quot;-&quot;*30) if i==3: break print(i) &quot;&quot;&quot;打印结果如下 ------------------------------ 1 ------------------------------ 2 ------------------------------ &quot;&quot;&quot; continue: #语句跳出当前循环，进入下一轮循环 i = 0 while i&lt;4: i += 1 print(&quot;-&quot;*30) if i==2: continue print(i) &quot;&quot;&quot;打印结果如下 ------------------------------ 1 ------------------------------ ------------------------------ 3 ------------------------------ 4 &quot;&quot;&quot; pass: #空语句，用于占位语句，不做事情 #九九乘法表 for a in range(1,10,1): for b in range(1,a+1,1): print(end=&quot;%d*%d=%d\\t&quot;%(b,a,a*b)) print(&quot;\\n&quot;) 9 字符串 my = &quot;I&#39;m student&quot; print(my) #打印结果 I&#39;m student word = &quot;&quot;&quot; hello world hobby &quot;&quot;&quot; print(word) &quot;&quot;&quot;打印结果 hello world hobby &quot;&quot;&quot; 特殊注意几个字符 &quot;&quot;&quot; 转义字符 描述 \\\\ 反斜杠符号 \\&#39; 单引号 \\&#39;&#39; 双引号 \\n 换行 \\t 横向制表符 &quot;&quot;&quot; 截取字符串 str = &quot;chengdu&quot; print(str) #输出 chengdu print(str[0]) #输出 c print(str[0:5]) #输出 cheng print(str[1:7:2]) #输出 hnd [起始位置:终止位置:步进值] print(str[:5]) #输出 cheng print(str[5:]) #输出 du print(&quot;hello &quot; + str) #输出 hello chengdu print(&quot;hello\\nchengdu&quot;)#输出 hello(换行)chengdu print(r&quot;hello\\nchengdu&quot;)#输出 hellochengdu # 加一个r 表示直接显示，不进行转义 10 列表 # 列表类似于数组(列表中可以存储混合类型) namelist = [&quot;zhangsan&quot;,&quot;lisi&quot;,102] print(namelist[0]) #输出 zhangsan print(namelist[2]) #输出 102 print(type(namelist[0])) #输出 &lt;class &#39;str&#39;&gt; print(type(namelist[2])) #输出 &lt;class &#39;int&#39;&gt; # for遍历 namelist = [&quot;zhangsan&quot;,&quot;lisi&quot;,102] for name in namelist: print(name) &quot;&quot;&quot; zhangsan lisi 102 &quot;&quot;&quot; # while遍历 namelist = [&quot;zhangsan&quot;,&quot;lisi&quot;,102] i = 0 while i &lt; len(namelist): print(namelist[i]) i += 1 # 列表具有切片 list1[2:5:2] [起始位置:终止位置:步进值] 增 # 增1 append (在列表末尾添加新的成员) namelist = [&quot;zhangsan&quot;] nametemp = input(&quot;write new name:&quot;) namelist.append(nametemp) for a in namelist: print(a) &quot;&quot;&quot; write new name:lisi zhangsan lisi &quot;&quot;&quot; # 增2 extend (在列表末尾逐一合并增加新的成员) a = [1,2] b = [3,4] a.extend(b) print(a) # 输出结果 [1, 2, 3, 4] # 增3 insert 指定下标位置前插入元素 a = [0,1,2] a.insert(1,3) #第一个变量表示下标和，第二个表示元素(对象) print(a) #输出结果 [0 3 1 2] 删 # 删1 del 指定下标(位置)删除元素 namelist = [&quot;zhangsan&quot;,&quot;lisi&quot;,&quot;wangwu&quot;] del namelist[2] print(namelist) &quot;&quot;&quot; [&#39;zhangsan&#39;, &#39;lisi&#39;, &#39;wangwu&#39;] [&#39;zhangsan&#39;, &#39;lisi&#39;] &quot;&quot;&quot; # 删2 pop 删除列表最后一个元素 namelist = [&quot;zhangsan&quot;,&quot;lisi&quot;,&quot;wangwu&quot;] namelist.pop() print(namelist) &quot;&quot;&quot; [&#39;zhangsan&#39;, &#39;lisi&#39;] &quot;&quot;&quot; # 删3 remove 删除指定位置(若有重复数据，只删除第一个数据) namelist = [&quot;zhangsan&quot;,&quot;lisi&quot;,&quot;wangwu&quot;] namelist.remove(&quot;lisi&quot;) print(namelist) &quot;&quot;&quot; [&#39;zhangsan&#39;, &#39;wangwu&#39;] &quot;&quot;&quot; 改 # 改 指定下标内容 namelist = [&quot;zhangsan&quot;,&quot;lisi&quot;,&quot;wangwu&quot;] namelist[1] = &quot;xiaoming&quot; #下标直接修改即可 print(namelist) &quot;&quot;&quot; [&#39;zhangsan&#39;, &#39;xiaoming&#39;, &#39;wangwu&#39;] &quot;&quot;&quot; 查 # 查 在或者不在 namelist = [&quot;zhangsan&quot;,&quot;lisi&quot;,&quot;wangwu&quot;] findname = input(&quot;write that whate student do you want?&quot;) if findname in namelist: print(findname + &quot;had been find&quot; ) else: print(findname + &quot;had been not find&quot; ) &quot;&quot;&quot; write that whate student do you want? zhangsan zhangsan had been find &quot;&quot;&quot; 11 元组 列表属于可变序列,它的元素可以随时修改或者删除,而元组属于不可变序列,其中的元素是不能修改的,除非整体重新赋值。 定义元组 &quot;&quot;&quot; 无数值空元组时: tup = () 一个数值元组时: tup = (20,) # 必须要加逗号 多个数值元组时: tup = (10，20，30) &quot;&quot;&quot; 增：相当于创建了新的元组 tup1 = (&quot;abc&quot;,30,9) tup2=(&quot;gh&quot;,50) tup = tup1 + tup2 print(tup) # 运行结果 (&#39;abc&#39;, 30, 9, &#39;gh&#39;, 50) 删：不允许删除某个具体的值，删除的是整个变量 tup1 = (&quot;abc&quot;,30,9) print(tup1) del tup1 print(tup1) #报错 找不到tup1,该变量已经被彻底删除了 改：不能修改 tup1 = (&quot;abc&quot;,30,9) tup1[1] = 50 # 报错 查：用列表的查看方法即可 tup2=(&quot;gh&quot;,50,6,23,4,8) print(tup2[1:5:2]) # (50, 23) 12 字典(dict) (1)字典是无序的对象集合，使用键-值存储 (2)键必须使用不可变类型，值可以一样 (3)同一个字典中，键必须是唯一的 定义 inf = {&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:18} print(inf[&quot;age&quot;]) # 输出结果 18 #访问不存在的键 inf = {&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:18} print(inf.get(&quot;shengao&quot;)) # 输出结果 None (默认返回 None) print(inf.get(&quot;shengao&quot;,&quot;mec&quot;)) # 输出结果 mec (修改默认值返回 mec) 增 student = {&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:18} newid = input(&quot;write new id: &quot;) student[&quot;id&quot;] = newid print(student[&quot;id&quot;]) &quot;&quot;&quot; write new id: 86 86 &quot;&quot;&quot; 删 #(1) del student = {&quot;name&quot;:&quot;lisi&quot;,&quot;age&quot;:18} del student[&quot;name&quot;] print(&quot;change after: %s&quot;%student[&quot;name&quot;]) #报错 因为删除了是键值对(&quot;name&quot;:&quot;lisi&quot;) student = {&quot;name&quot;:&quot;lisi&quot;,&quot;age&quot;:18} del student print(student) # 报错 删除了字典 #(2) clear student = {&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:18} student.clear() print(student) # 输出结果 {} 改 student = {&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:18} student[&quot;age&quot;] = 20 print(student[&quot;age&quot;]) # 输出结果 20 查 student = {&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:18,&quot;id&quot;:1} print(student.keys()) print(student.values()) print(student.items()) &quot;&quot;&quot; dict_keys([&#39;name&#39;, &#39;age&#39;, &#39;id&#39;]) #得到所有的键 是列表形式 dict_values([&#39;zhangsan&#39;, 18, 1]) #得到所有的值 是列表形式 dict_items([(&#39;name&#39;, &#39;zhangsan&#39;), (&#39;age&#39;, 18), (&#39;id&#39;, 1)]) #得到的是所有的项(元组)，每个键值对是一个元组 &quot;&quot;&quot; #遍历所有的键 student = {&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:18,&quot;id&quot;:1} for key in student.keys(): print(key) &quot;&quot;&quot; name age id &quot;&quot;&quot; #遍历所有的值 student = {&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:18,&quot;id&quot;:1} for value in student.values(): print(value) &quot;&quot;&quot; zhangsan 18 1 &quot;&quot;&quot; #遍历所有的键值对 student = {&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:18,&quot;id&quot;:1} for key,value in student.items(): print(&quot;key = %s,value = %s&quot;%(key,value)) &quot;&quot;&quot; key = name,value = zhangsan key = age,value = 18 key = id,value = 1 &quot;&quot;&quot; # 使用枚举函数(enumerate)，同时得到列表的下标和元素内容 mylist = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,66] for i,x in enumerate(mylist): print(i+1,x) &quot;&quot;&quot; 1 a 2 b 3 c 4 66 &quot;&quot;&quot; 13 函数 定义 def 函数名(): 代码 # 可以返回多个值 def dvd(a,b): return a/b,a%b print(dvd(5,2)) # 运行结果(2.5,1) def a1(): print(&quot;-&quot;*15) def write(numb): x = 0 while x &lt; numb: a1() x += 1 nua = int(input(&quot;the nub do you want: &quot;)) #input默认为str类型 print(type(nua)) write(nua) &quot;&quot;&quot; the nub do you want: 2 &lt;class &#39;int&#39;&gt; --------------- --------------- &quot;&quot;&quot; 14 文件操作 打开/关闭(open/close) f = open(&quot;test.txt&quot;,&quot;w&quot;) # w为写入模式，如果没有test.txt自动创建一个 f.close() #关闭 r :以读打开文件，若没有文件，就报错(默认模式) w :以写打开文件，若没有文件，就自动创建 rb :以二进制打开文件用于只读 wb :以二进制打开文件用于只写 # 将字符串写入(write) f = open(&quot;test.txt&quot;,&quot;w&quot;) f.write(&quot;hello world ,i am here&quot;) f.close() # 读5个字符(read,读完后向后移动) f = open(&quot;test.txt&quot;,&quot;r&quot;) content=f.read(5) print(content) content=f.read(5) print(content) f.close() &quot;&quot;&quot; hello worl &quot;&quot;&quot; # 读取列表readlines(一次性读取全部列表) f = open(&quot;test.txt&quot;,&quot;r&quot;) content = f.readlines() print(content) i = 1 for temp in content: print(&quot;%d,%s&quot;%(i,temp)) i += 1 f.close() &quot;&quot;&quot; 1,hello world ,i am here 2,hello world ,i am here 3,hello world ,i am here 4,hello world ,i am here &quot;&quot;&quot; # 读取列表readline(一次读取一行列表) # 文件重命名os的rename(需要修改的名字，新的名字) import os os.rename(&quot;test.txt&quot;,&quot;abc.txt&quot;) 15 异常处理 print(&quot;---test---1---&quot;) f = open(&quot;123.txt&quot;,&quot;r&quot;) # 会报错，用只读打开了一个不存在的文件 print(&quot;---test---2---&quot;) # 这句代码不会被执行 #捕获所有的异常并且全部打印(Exception,as result) try: print(&quot;---test---1---&quot;) f = open(&quot;123.txt&quot;,&quot;r&quot;) print(num) except Exception as result: # Exception包含所有的错误类型 print(result) #打印所有的错误类型 try....finally和嵌套，不管如何报错，都会执行文件关闭的程序 import time try: f = open(&quot;123.txt&quot;,&quot;r&quot;) try: while True: content = f.readline() if len(content) == 0: break time.sleep(2) print(content) finally: #无论程序能否执行，此代码一定会被执行的 f.close() print(&quot;close wenjian&quot;) except Exception as result: print(&quot;had been error&quot;) &quot;&quot;&quot; had been error &quot;&quot;&quot; 16.正则表达式的常用操作符 &quot;&quot;&quot; . ：表示任何单个字符 [] ：字符集，对单个字符给出取值范围 例子:[abc]表示a、b、c，[a-z]表示a到z单个字符 [^ ] ：非字符集，对单个字符给出排除范围 例子:[^abc] 表示非a或b或c的单个字符 * ：前一个字符0次或无限次扩展 例子：abc*表示ab、abc、abcc、 abccc等 + ：前一个字符1次或无限次扩展 例子：abc+表示abc、abcc、abccc等 ? ：前一个字符0次或1次扩展 例子：abc？表示ab、abc | ：左右表达式任意一个 例子：abc|def表示abc、def {m} ：扩展前一个字符m次 例子：ab{2}c表示abbc {m. n} ；扩展前一个字符m至n次（含n） 例子：ab{1，2}c表示abc、abbc ^ ：匹配字符串开头 例子：^abc表示abc且在一个字符串的开头 $ ：匹配字符串结尾 例子：abc$表示abc且在一个字符串的结尾 () ：分组标记，内部只能使用|操作符 例子：（abc）表示abc，（abc|def）表示abc、def \\d ：数字，等价于[6-9] \\w ：单词字符，等价于[A-Za-z0-9_] &quot;&quot;&quot; 17. &quot;&quot;&quot; re search（） ：在一个字符串中搜索匹配正则表达式的第一个位置，返回 match对象 re match（） ：在一个字符串中搜索匹配正则表达式的第一个位置，返回 match对象 re. finally（） ：搜索字符串，以列表类型返回全部能匹配的子串 re split（） ：将一个字符串按照正则表达式匹配结果进行分割，返回列表类型 re. finditer（） ：搜索字符串，返回一个匹配结果的迭代类型，每个迭代元素是 match对象 re sub（） ：在一个字符串中替换所有匹配正则表达式的子串，返回替换后的字符串 &quot;&quot;&quot; 18. re修饰符 &quot;&quot;&quot; re.l：使匹配对大小写不敏感 re.L：做本地化识别（ ocale- aware）匹配 re.M：多行匹配，影响^和$ re.S：使匹配包括换行在内的所有字符 re.U：根据 Unicode字符集解析字符。这个标志影响w，W，\\b，\\B. re.X：该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。 &quot;&quot;&quot;","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[]},{"title":"解除限速","slug":"破解百度网盘限速","date":"2020-06-13T04:49:16.000Z","updated":"2020-07-11T05:11:16.267Z","comments":true,"path":"2020/06/13/破解百度网盘限速/","link":"","permalink":"http://yoursite.com/2020/06/13/%E7%A0%B4%E8%A7%A3%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E9%99%90%E9%80%9F/","excerpt":"","text":"自己亲自实践有效的解除限速1. 在电脑上下载一个IDM下载器或者迅雷下载器(下面用的IDM举例子) 2. 复制好所要下载文件的链接 3. 打开浏览器，输入http://pan.naifei.cc/? 4. 在上面的那个链接后边，直接将刚刚复制的分享链接粘贴进去即可。然后右键点击下载，选择IDM下载(如图) 5. 然后IMD会自动的帮我们下载，还可以设定下载路径之类的，速度很快的(由于我是电脑连接手机热点，所以图显速度不是很快)，成功解除限速","categories":[],"tags":[]},{"title":"opcv第一讲","slug":"Opencv加载、显示、保存处理图像","date":"2020-06-12T04:49:16.000Z","updated":"2020-07-07T09:10:42.574Z","comments":true,"path":"2020/06/12/Opencv加载、显示、保存处理图像/","link":"","permalink":"http://yoursite.com/2020/06/12/Opencv%E5%8A%A0%E8%BD%BD%E3%80%81%E6%98%BE%E7%A4%BA%E3%80%81%E4%BF%9D%E5%AD%98%E5%A4%84%E7%90%86%E5%9B%BE%E5%83%8F/","excerpt":"","text":"1. 加载图像（cv::imread）Mat src = imread(&quot;D:/c++练习/opencv/可删/1.jpg&quot;); imread 的功能是加载图像文件成为一个 Mat 对象其中第一个参数表示图像文件名称第二个参数，表示加载的图像是什么类型，支持常见的三个参数值如下所示：Mat src = imread(&quot;D:/c++练习/opencv/可删/1.jpg&quot;,IMREAD_GRAYSCALE); // IMREAD_GRAYSCALE 加载出灰色照片 // IMREAD_UNCHANGED (&lt;0) 表示加载原图，不做任何改变 // IMREAD_GRAYSCALE ( 0)表示把原图作为灰度图像加载进来 // IMREAD_COLOR (&gt;0) 表示把原图作为RGB图像加载进来 // 注意：OpenCV支持JPG、PNG、TIFF、RGB等常见格式图像文件加载 2. 显示图像 (cv::namedWindos / cv::imshow)（1）. namedWindos的功能是创建一个OpenCV窗口，它是由OpenCV自动创建与释放，你无需取销毁它。常见用法如下namedWindow(&quot;Window Title&quot;, WINDOW_AUTOSIZE) WINDOW_AUTOSIZE 会自动根据图像大小，显示窗口大小，不能人为改变窗口大小WINDOW_NORMAL 跟QT集成的时候会使用，允许修改窗口大小namedWindow(&quot;test opencv setup&quot;,CV_WINDOW_AUTOSIZE); // test opencv setup 窗口名称可以自己修改定义 （2）. imshow根据窗口名称显示图像到指定的窗口上去，第一个参数是窗口名称，第二参数是Mat对象Mat src = imread(&quot;D:/c++练习/opencv/可删/1.jpg&quot;,IMREAD_GRAYSCALE); imshow(&quot;test opencv setup&quot;, src); // test opencv setup 窗口名称可以自己修改定义 3. 修改图像 (cv::cvtColor)cvtColor的功能是把图像从一个彩色空间转换到另外一个色彩空间，有三个参数，第一个参数表示源图像、第二参数表示色彩空间转换之后的图像、第三个参数表示源和目标色彩空间如：COLOR_BGR2HLS 、COLOR_BGR2GRAY 等 Mat src = imread(&quot;D:/c++练习/opencv/可删/1.jpg&quot;,UNDERFLOW);// 原图 imshow(&quot;123&quot;, src); //123 窗口名称可以自己修改定义,显示src Mat output_image; cvtColor(src, output_image, COLOR_BGR2HLS); // 新图名为 output_image, 转换新图到 COLOR_BGR2HLS 色彩空间 imshow(&quot;111&quot;, output_image); // 显示output_image的新图，窗口名字为111 (4). 保存图像 cv::imwrite保存图像文件到指定目录路径只有8位、16位的PNG、JPG、Tiff文件格式而且是单通道或者三通道的BGR的图像才可以通过这种方式保存保存PNG格式的时候可以保存透明通道的图片可以指定压缩参数imwrite(&quot;D:/new.jpg&quot;, output_image); //将output_image的副本放在D盘，并且命新的名字为 new.jpg","categories":[{"name":"opencv视觉","slug":"opencv视觉","permalink":"http://yoursite.com/categories/opencv%E8%A7%86%E8%A7%89/"}],"tags":[]},{"title":"Essential 视觉Slam第一讲","slug":"Linux下的视觉Slam 第一讲 手把手教你Kdevelop编程","date":"2020-06-10T04:49:16.000Z","updated":"2020-07-01T15:11:16.503Z","comments":true,"path":"2020/06/10/Linux下的视觉Slam 第一讲 手把手教你Kdevelop编程/","link":"","permalink":"http://yoursite.com/2020/06/10/Linux%E4%B8%8B%E7%9A%84%E8%A7%86%E8%A7%89Slam%20%E7%AC%AC%E4%B8%80%E8%AE%B2%20%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0Kdevelop%E7%BC%96%E7%A8%8B/","excerpt":"","text":"这是我在自学Linux下的视觉slam所做的一些笔记，记录了一些坑和经验，方便日后的学习。我将手把手教大家介绍如何在linux系统下，在Kdevelop编译器下进行第一个slam_hello程序的编程。第一讲(1). 首先我们要在Linux系统下打开终端命令窗口(快捷键是 Ctrl + Alt + T)(2). 然后创建一个文件夹用来专门的保存代码，我这里用的是 home 路径下的 slam 文件夹 ，我们等会就在它里面的 ch2 文件夹下来创建我们第一个程序(如下所示) 方法一：(推荐)(1). 我们直接在终端命令输入Kdevelop，就可以打开编程软件了，效果如下所示![](https://gitee.com/two_finger_meditation/bed/raw/master/img/25 (1).png) (2). 然后我们打开工程，点击第一个，从模板新建![](https://gitee.com/two_finger_meditation/bed/raw/master/img/25 (2).png) (3). 然后在类别中选择Standard ，工程类别选择 Terminal ,具体详情如下 (4). 然后填写项目名称和修改保存的路径，如下 (5). 然后点击下一步 (6). 点击完成和ok即可 (7). 然后的界面如图所示 (8). 接下来配置启动器。单击 ”运行“ 中的 ”配置启动“ 进入配置页面。选中自己建立的工程之后单击 “添加”，选下拉菜单中的工程名称，然后点击Apply以及OK。其过程如下图所示。 (9). 然后在初始页面，加上命名空间，再小修改整理下，如下所示 (10). 然后点击”运行”，’’执行启动“(快捷键是 Shift + F9) (11). 运行后的效果如下 方法二：（详见方法一，法二不推荐）(1). 使用 touch 命令创建一个hello_slam.cpp文件，具体操作如下图所示 (2). 然后我们用Kdevelop编译器打开刚刚创建好的文件，具体操作如图所示(附一张打开后的页面) (3). 其他的步骤参考法(一)如果各位小伙伴有什么疑问，欢迎留言一起讨论呀！","categories":[{"name":"视觉Slam","slug":"视觉Slam","permalink":"http://yoursite.com/categories/%E8%A7%86%E8%A7%89Slam/"}],"tags":[]},{"title":"Essential C++ 笔记1","slug":"Essential C++ 笔记1","date":"2020-06-01T04:49:16.000Z","updated":"2020-06-27T03:01:03.656Z","comments":true,"path":"2020/06/01/Essential C++ 笔记1/","link":"","permalink":"http://yoursite.com/2020/06/01/Essential%20C++%20%E7%AC%94%E8%AE%B01/","excerpt":"","text":"Stanley B.Lippman时隔多年所写的轻量级C++，为C++初学者铺的红地毯。侯捷老师翻译，以此做笔记，方便日后回忆。第一章1. Class (类) 用户自定义数据类型2. 输入/输出库 ，名叫iostream ,包含整套的Class3. string Class 用于定义 string user_name , 并且属于声明，要包含 string Class 的头文件 #include “string”4. std 是标准库所驻命名空间 (namespace) 的名称5. 使用命名空间，避免和应用程序发生命名冲突的问题 (具有相同的名字)6. 在程序中使用 string Class 及 cin 、cout 的 iostream 类对象，不仅包含 string 、iostream 的头文件，还得让命名空间 std 内的名称曝光 ——using namespace std;（最简单曝光的方法）7. bool 值为 true / false8. 被定义为 const 对象后，获得初值后，无法再改变9. 数组 Array 与 Vector 容器 int pell [18] ; vector &lt;int&gt; seq(18); 10. 容器第一个元素位置为011. 数组 Array 与 Vector 容器的区别1. //容器定义、初始化必有大小，而数组可没有，例如 int pell []={1,2 ,3}; 2. Vector &lt;int&gt; *addrs[1]={&amp;a}; // 元素类型为 vector&lt;int&gt; * // addrs[0] 值为 a的地址 12. Vector 初始化的两种方式1. vector &lt;int&gt; seq(2); seq[0]=1; seq[1]=2; 2. //利用已初始化的Array 作为该Vector容器的初值 ------重要 int vals[5]={0,1,2,3,4}; vector &lt;int&gt; seq(vals,vals+5); 13. Vector的特点Vector容器知道自己的大小int a = seq.size(); //a中储存的就是vector &lt;int&gt; seq(2)的数据个数（为2） seq.size()会返回该容器的大小 14. 指针内含某特定类型对象的内存地址int *pi; // pi 是个int 类型的对象 int *pi= &amp; inval; // pi储存的是inval的内存地址 未完待续…","categories":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/categories/c/"}],"tags":[]},{"title":"STM32知识点(一)","slug":"STM32知识点(一)","date":"2020-05-28T04:49:16.000Z","updated":"2020-06-01T11:26:52.696Z","comments":true,"path":"2020/05/28/STM32知识点(一)/","link":"","permalink":"http://yoursite.com/2020/05/28/STM32%E7%9F%A5%E8%AF%86%E7%82%B9(%E4%B8%80)/","excerpt":"","text":"以前学习STM32感觉掌握的不牢固，很多知识都遗忘了，所以趁着疫情在家重新学习下，顺便记录下容易混的知识，和大家一起分享。1. GPIO — 指的是通用输入和输出端口引脚与GPIO区别?（1）引脚有的是做GPIO用，有的是做电源引脚，复位引脚，晶振引脚等（2）引脚可以复用，可以做GPIO，也可以做其他的作用(例如做串口…)2. GPIO的八种工作模式 — 重点四种输入：浮空输入: 芯片读取的引脚电平状态不确定，取决于GPIO外部电平，可以做KEY识别上拉输入: IO内带上拉电阻输入下拉输入: IO内带下拉电阻输入模拟输入: ADC模拟输入，不像其他输入模式只有0和1，模拟输入模式可以读取到很细微变化的值，ADC四种输出(以下四个均含上下拉):开漏输出: 只能输出低电平，外部不接上拉电阻时，所以要想输出高电平必须要外接上拉电阻 GPIO_MODE_OUTPUT_PP // 开漏输出 开漏复用输出: 理解为GPIO第二功能IO输出0-接GND， IO输出1 -接VCC，读输入值是未知的推挽式输出: 可以输出强高低电平，连接数字其间。例如IIC (SCL,SDA) GPIO_MODE_OUTPUT_OD // 推挽式输出 推挽式复用输出: 理解为GPIO第二功能,例如串口通信TX,SPI等3.八种模式对应Hal函数（1）GPIO_Mode_IN_FLOATING // 浮空输入 （2）GPIO_Mode_IPU // 上拉输入 （3）GPIO_Mode_IPD // 下拉输入 （4）GPIO_Mode_AIN // 模拟输入 （5）GPIO_Mode_Out_OD // 开漏输出 （6）GPIO_Mode_AF_OD // 开漏复用输出 （7）GPIO_Mode_Out_PP // 推挽输出 （8）GPIO_Mode_AF_PP // 复用推挽输出 4. 注意 — 重点当引脚高有效的我们就下拉，低有效的话我们就上拉,增强其控制能力 后续将继续补充与完善…","categories":[{"name":"STM32","slug":"STM32","permalink":"http://yoursite.com/categories/STM32/"}],"tags":[]},{"title":"Linux操作系统命令","slug":"Linux操作系统命令","date":"2020-05-04T04:49:16.000Z","updated":"2020-06-01T11:26:35.654Z","comments":true,"path":"2020/05/04/Linux操作系统命令/","link":"","permalink":"http://yoursite.com/2020/05/04/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4/","excerpt":"","text":"这是我自己在看视频过程中记录的Linux基础的小知识点。1.ctrl + shift + = // 为放大字体 ctrl + - // 为缩小字体 ctrl + alt + t // 为打开终端 clean // 清屏ls tab // 自动补全目录 2. 以下直接回车即可ls // 查看当前文件夹下内容 pwd // 查看当前所在文件夹 3. 以下需要加上对象，再回车cd // 切换文件夹(注意空格pwd) touch // 如果文件不存在，新建文件 mkdir // 创建文件夹(目录) mkdir -p a/b/c/d //(创建a文件，a包含了b，b包含了c，c包含了d) rm // 删除指定文件(不能删除文件夹（目录）) rm -d // 文件夹名 (删除文件夹(目录)) rm -r // 文件夹名 (删除文件夹(单目录和多目录)) rm -f // (强力删除，不提示任何信息) 4. 命令查询两种方法command --help man command 5. 文件和目录常用命令ls // 查看目录内容 cd // 切换目录 touch // 创建文件(当文件不存在时创建，如果已存在，则修改日期) rm mkdir // 删除 cp // 拷贝 mv // 移动 6. 隐藏文件以 .开头touch .123.txt // (以ls不可看见，ls -a(目录全部)才可见) // 删除时 rm .123.txt // . 代表为当前目录 // .. 代表上一级目录 例如(cd .. 为返回上一级目录) 7. ls常用的命令ls -a // 显示全部文件(包括隐藏的文件) ls -l // 显示文件的详细信息 ls -l -h // 人性化的显示文件的详细信息(ls -lh与前边那种书写相同) 8. 进制B 字节 一般为8位二进制数 K 1K = 1024 B M 1M = 1024 B G 1G = 1024 M T 1T = 1024 G 9. 通配符. // 代表任意个数个字符 ？ // 代表任意一个字符 至少一个 [] // 代表可以匹配字符组中任意一个 [abc] // 匹配 a b c 中任意一个 [a-f] // 匹配 a 到 f 范围的任意一个字符 ls 1* // (显示以1开头的文件) ls *1.txt // (显示以1.txt结尾的文件) ls [1-3].txt /***/// cd 拓展cd // 切换到当前用户的主目录(/home/用户目录) cd ~ // 切换到当前用户的主目录(/home/用户目录) cd . // 保留在当前目录 cd .. // 切换到上一级目录 cd - // 切换最近两次目录 /***/// 相对路径与绝对路径cd /home/zdaxian/Desktop // 绝对路径 // 相对路径 最前边不是/或- 便是相对目录所在目录位置 未完待续…","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[]},{"title":"蓝桥杯-第六届(温度记录)","slug":"蓝桥杯-第六届(温度记录)","date":"2020-04-18T04:49:16.000Z","updated":"2020-06-01T11:26:11.500Z","comments":true,"path":"2020/04/18/蓝桥杯-第六届(温度记录)/","link":"","permalink":"http://yoursite.com/2020/04/18/%E8%93%9D%E6%A1%A5%E6%9D%AF-%E7%AC%AC%E5%85%AD%E5%B1%8A(%E6%B8%A9%E5%BA%A6%E8%AE%B0%E5%BD%95)/","excerpt":"","text":"这是我自己在学习蓝桥杯过程中总结的一些知识，希望对今后的学习和备战蓝桥的同学能够提供一些帮助吧。蓝桥杯-第六届(温度记录)1.试题要求如下 2.题目要点分析1）指示符在显示时，需要闪烁(可以根据奇或偶来进行判断)2) 按下 s6 后，自动显示索引、各个温度(10个)3.注意事项1）运用到了以前几届的 DS18820 和 DS1302知识2）本届难度不大，综合运用了前边的知识4.代码实现开始的一些初始化之类的和第三届一样，这里不再分开叨叙(一笔简明带过)，忘记的朋友可以去看第三届解析#include &quot;stc15f2k60s2.h&quot; #include &quot;ds18b20.h&quot; #include &quot;ds1302.h&quot; uchar tab[]={0xc0, 0xf9,0xa4,0xB0,0x99,0x92,0x82,0xf8,0x80,0x90, 0xbf,0x7f,0xff}; // - . uint yi=0;uint er=0;uint san=0;uint si=0; uint wu=0;uint liu=0;uint qi=0;uint ba=0; uchar time_between=1; // 采集时间间隔 1 5 30 60采集 uchar caiji=0; extern uchar shijian[]; // 1302 时间数组 uint tt=0; // 中断计数 uchar save[10]; // 保留10次采集的温度记录在数组中 uchar save_n=0; // 与数组下标对应 uchar wendu; // 读取温度寄存 bit led1_spot=0; // 小灯开启标志位 bit fla=0; // 小灯闪烁标志位 void delayms(uint ms) { uint a; for(;ms&gt;0;ms--) { for(a=845;a&gt;0;a--); } } void allinit(void) { P2=0XA0; P0=0X00; P2=0X80; P0=0XFF; P2=0XC0; P0=0XFF; P2=0XFF; P0=0XFF; } void display(uchar channel,uchar number) { P2=0XC0; P0=0X01&lt;&lt;channel; P2=0XFF; P0=tab[number]; delayms(1); } void show_SMG() { display(0,yi); display(1,er); display(2,san); display(3,si); display(4,wu); display(5,liu); display(6,qi); display(7,ba); P2=0XC0; // 防止最后一个数码管过亮 P0=0XFF; P2=0XFF; P0=0XFF; } 官方提供的 ds18b20 代码资料 — 需修改 — 重点 /************************************************/ // 以下为官方提供 #include &quot;stc15f2k60s2.h&quot; #include &quot;ds18b20.h&quot; sbit DQ = P1^4; void Delay_OneWire(unsigned int t) { unsigned char i; while(t--){ for(i=0; i&lt;8; i++); } } void Write_DS18B20(unsigned char dat) // 写 { unsigned char i; for(i=0;i&lt;8;i++) { DQ = 0; DQ = dat&amp;0x01; Delay_OneWire(5); DQ = 1; dat &gt;&gt;= 1; } Delay_OneWire(5); } unsigned char Read_DS18B20(void) // 读 { unsigned char i; unsigned char dat; for(i=0;i&lt;8;i++) { DQ = 0; dat &gt;&gt;= 1; DQ = 1; if(DQ) { dat |= 0x80; } Delay_OneWire(5); } return dat; } bit init_ds18b20(void) // ds18b20初始化 { bit initflag = 0; DQ = 1; Delay_OneWire(12); DQ = 0; Delay_OneWire(80); DQ = 1; Delay_OneWire(10); initflag = DQ; Delay_OneWire(5); return initflag; } /*********************************************/ //以下需要自己写 unsigned char Tempget(void) { unsigned char low,high,temp; /***************************/ // 温度读取 init_ds18b20(); Write_DS18B20(0XCC); // 18b20手册 Write_DS18B20(0x44); Delay_OneWire(100); /***************************/ // 温度进行转化 init_ds18b20(); Write_DS18B20(0xcc); Write_DS18B20(0xbe); low=Read_DS18B20(); high=Read_DS18B20(); temp=high&lt;&lt;4; // 注意此处 temp|=(low&gt;&gt;4); return temp; } 官方提供的 ds1302 代码资料 — 需修改 — 重点#include &lt;STC15F2K60S2.H&gt; #include &lt;intrins.h&gt; #include &quot;ds1302.h&quot; sbit SCK=P1^7; sbit SDA=P2^3; sbit RST = P1^3; void Write_Ds1302_Byte(unsigned char temp) { unsigned char i; for (i=0;i&lt;8;i++) { SCK=0; SDA=temp&amp;0x01; temp&gt;&gt;=1; SCK=1; } } void Write_Ds1302( unsigned char address,unsigned char dat ) { RST=0; _nop_(); SCK=0; _nop_(); RST=1; _nop_(); Write_Ds1302_Byte(address); //Write_Ds1302_Byte(dat); // 需要修改如下 Write_Ds1302_Byte((dat/10&lt;&lt;4)|(dat%10)); // 修改后的 RST=0; } unsigned char Read_Ds1302 ( unsigned char address ) { unsigned char i,temp=0x00; uchar dat1,dat2; // 修改添加的 RST=0; _nop_(); SCK=0; _nop_(); RST=1; _nop_(); Write_Ds1302_Byte(address); for (i=0;i&lt;8;i++) { SCK=0; temp&gt;&gt;=1; if(SDA) temp|=0x80; SCK=1; } RST=0; _nop_(); RST=0; SCK=0; _nop_(); SCK=1; _nop_(); SDA=0; _nop_(); SDA=1; _nop_(); dat1=temp/16; // 10进制与16进制的转化 dat2=temp%16; temp=dat1*10+dat2; // 三行自己添加的 return (temp); } /**********************************/ // 以下需要自己写的 uchar shijian[]={50,59,23,0,0,0,0}; // 秒分时 日月周年 void DS_Write(void) { uchar i,add; add=0x80; // 0x80 写 0x81 读 Write_Ds1302(0x8e,0x00); // 开始对其 写(0x00) for(i=0;i&lt;7;i++) { Write_Ds1302(add,shijian[i]); add+=2; // 1302 每次增加2 } Write_Ds1302(0x8e,0x80); // 80 关闭 } void DS_Read(void) { uchar i,add; add=0x81; // 0x81 读取 Write_Ds1302(0x8e,0x00); for(i=0;i&lt;7;i++) { shijian[i]=Read_Ds1302(add); add+=2; } Write_Ds1302(0x8e,0x80); // 80 关闭 } 中断函数 — 重要void Timer0Init(void) // 0 5ms { AUXR |=0X80; TMOD &amp;=0XF0; TL0=0X00; TH0=0X28; TF0=0; TR0=1; EA=1; ET0=1; } void timer0 () interrupt 1 { tt++; if(caiji==1) { if(tt==200*time_between) // 化为1s * 变成间隔多长时间进行采集 { tt=0; save[save_n]=wendu; save_n++; if(save_n==10) { caiji=2; // 采集完成标志位 save_n=0; er=san=0;si=wu=12; // 显示规定的显示 yi=liu=10; qi=save[0]/10; ba=save[0]%10; led1_spot=1; // 小灯开始闪烁的标志位 标志采集完成 } } } if((caiji==2)&amp;&amp;(tt==200)) // 1s 采集完成 闪烁 { tt=0; if(led1_spot==1) // 小灯开始闪烁标志位 { if(fla==0) // 控制小灯闪烁 { P2=0X80; P0=0xfe; fla=1; } else if(fla==1) { P2=0X80; P0=0XFF; fla=0; } } else if(led1_spot==0) // 小灯闪烁标志位为关闭状态 { // 当caiji=2,标志着采集完成，此时按下s6,led1_spot变为0， // 依次显示已经保存的10个温度 索引值也随之改变 yi=liu=10;si=wu=12; er=save_n/10; san=save_n%10; qi=save[save_n]/10; ba=save[save_n]%10; save_n++; if(save_n==10) { save_n=0; caiji=3; // caiji=3,已经显示完了已保存的温度 } } } } 按键功能操作 — 重点void keyscan4() { if(P30==0) { delayms(5); if(P30==0) { if(caiji==3) // caiji=3,已经依次显示完了已保存的温度 { caiji=0; // 恢复s4的再次按键控制作用 } }while(!P30); } if(P31==0) { delayms(5); if(P31==0) { if(caiji==2) // 采集完成后的标志位---也就是依次显示 { led1_spot=0; // 关闭小灯闪烁 P2=0X80; P0=0XFF; } }while(!P31); } if(P32==0) { delayms(5); if(P32==0) { if(caiji==0) // 采集开始后标志为1 { caiji=1; } tt=0; // 再次计数时，恢复中断的计数器 // (当caiji==3时，标志已经依次显示完温度) // 此时tt已经自动计数到很大了，进不到中断判断中，故需清零 }while(!P32); } if(P33==0) // s4 { delayms(5); if(P33==0) { if(caiji==0) // 采集未开始标志 { if(time_between==1) // 按下切换采集间隔时间 { time_between=5; } else if(time_between==5) { time_between=30; } else if(time_between==30) { time_between=60; } else if(time_between==60) { time_between=1; } } }while(!P33); } } 主函数中对标志位进行判断 — 重点void main() { allinit(); DS_Write(); // 初始化1302 Timer0Init(); yi=er=san=si=wu=12; liu=10;qi=0;ba=1; while(1) { wendu=Tempget(); if(caiji==0) // 采集未开始标志 { // 显示 1 5 30 60 采集时间设定 yi=er=san=si=wu=12; liu=10; qi=time_between/10; ba=time_between%10; } else if(caiji==1) // 开始采集的标志 { DS_Read(); // 读取1302时间 yi=shijian[2]/10;er=shijian[2]%10;san=10; si=shijian[1]/10;wu=shijian[1]%10;liu=10; // 分隔符 qi=shijian[0]/10;ba=shijian[0]%10; if(shijian[0]%2==0) // 横杠闪烁 { san=liu=10; // 横杠 } else { san=liu=12; } } show_SMG(); keyscan4(); } } 版权所有，未经允许，不得转载 !","categories":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"http://yoursite.com/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}],"tags":[]},{"title":"蓝桥杯-第五届(温度采集)","slug":"蓝桥杯-第五届(温度采集)","date":"2020-04-10T04:49:16.000Z","updated":"2020-06-01T11:26:01.260Z","comments":true,"path":"2020/04/10/蓝桥杯-第五届(温度采集)/","link":"","permalink":"http://yoursite.com/2020/04/10/%E8%93%9D%E6%A1%A5%E6%9D%AF-%E7%AC%AC%E4%BA%94%E5%B1%8A(%E6%B8%A9%E5%BA%A6%E9%87%87%E9%9B%86)/","excerpt":"","text":"这是我自己在学习蓝桥杯过程中总结的一些知识，希望对今后的学习和备战蓝桥的同学能够提供一些帮助吧。蓝桥杯-第五届(温度采集)1.试题要求如下 2.题目要点分析1）根据当前温度来显示不同的温度区间2）不同的温度区间，led闪烁不同的频率3）矩阵按键输入设置上下温度3.注意事项1）输入进去的温度，要进行最大温度与最小温度的比较，若有误，需清屏2）按键扫描函数延时与中断触发时间可能会有干扰，需解决4.代码实现开始的一些初始化之类的和第三届一样，这里不再分开叨叙(一笔简明带过)，忘记的朋友可以去看第三届解析#include &quot;stc15f2k60s2.h&quot; #include &quot;ds18b20.h&quot; uchar tab[]={0xc0, // 段选 0- 9 加上 - . 熄灭 0xf9,0xa4,0xB0,0x99,0x92,0x82,0xf8,0x80,0x90, 0xbf,0x7f,0xff}; // - . uint yi=0;uint er=0;uint san=0;uint si=0; uint wu=0;uint liu=0;uint qi=0;uint ba=0; // 全局变量 控制数码管的段选显示变化 uchar max=30; // 初始化温度上限30 全局变量 uchar min=20; // 初始化温度下限20 全局变量 uchar qujian; // 寄存判断区间后显示的数值 全局变量 uchar wendu=0; // 读取当前的温度，进行与区间判断 全局变量 uchar shezhi=0; // 按键设置的标志位 初始化为0 全局变量 uchar num; // 按下不同的矩阵的按键后，num发生变化，被赋予不同的数 全局变量 uchar flag=0 // 按下矩阵按键后的标志位，标志其被按下 全局变量 void delayms(uint a) // 延时 1ms { uint b; for(;a&gt;0;a--) { for(b=845;b&gt;0;b--); } } void all_init() // 初始化 关闭蜂咛器 继电器 数码管等 { P2=0XA0; P0=0X00; P2=0X80; P0=0XFF; P2=0XC0; P0=0XFF; P2=0XFF; P0=0XFF; } void display(uchar channel,uchar number) // 数码管的位选与段选 { P2=0XC0; P0=0X01&lt;&lt;channel; P2=0XFF; P0=tab[number]; delayms(1); } void show_SMG() // 数码显示函数 { display(0,yi); display(1,er); display(2,san); display(3,si); display(4,wu); display(5,liu); display(6,qi); display(7,ba); P2=0XC0; // 为了解决最后一个数码管过亮问题 P0=0XFF; P2=0XFF; P0=0XFF; } 官方提供的ds18b20代码资料 — 需修改 — 重点/*************************************************/ // 以下为官方提供 #include &quot;stc15f2k60s2.h&quot; #include &quot;ds18b20.h&quot; sbit DQ = P1^4; void Delay_OneWire(unsigned int t) // 延时函数 { unsigned char i; while(t--){ for(i=0; i&lt;8; i++); } } void Write_DS18B20(unsigned char dat) // 向ds18b20写一个字节 { unsigned char i; for(i=0;i&lt;8;i++) { DQ = 0; DQ = dat&amp;0x01; Delay_OneWire(5); DQ = 1; dat &gt;&gt;= 1; } Delay_OneWire(5); } unsigned char Read_DS18B20(void) // 从ds18b20读取一个字节 { unsigned char i; unsigned char dat; for(i=0;i&lt;8;i++) { DQ = 0; dat &gt;&gt;= 1; DQ = 1; if(DQ) { dat |= 0x80; } Delay_OneWire(5); } return dat; } bit init_ds18b20(void) // ds18b20 设备初始化 { bit initflag = 0; DQ = 1; Delay_OneWire(12); DQ = 0; Delay_OneWire(80); DQ = 1; Delay_OneWire(10); initflag = DQ; Delay_OneWire(5); return initflag; } /*********************************/ // 以下需要自己写 unsigned char Tempget(void) { unsigned char low,high,temp; /***************************/ // 温度进行读取 init_ds18b20(); Write_DS18B20(0XCC); // ds18b20手册 Write_DS18B20(0x44); Delay_OneWire(100); /***************************/ // 温度进行转化 init_ds18b20(); Write_DS18B20(0xcc); Write_DS18B20(0xbe); low=Read_DS18B20(); high=Read_DS18B20(); temp=high&lt;&lt;4; temp|=(low&gt;&gt;4); return temp; } 按键功能操作 — 重点void keyscan16() { /**************************/ // 第一行扫描 P30=0; P31=P32=P33=1; P44=P42=P35=P34=1; if(P44==0) { delayms(5); if(P44==0) { num=0; // 显示数字为0 flag=1; // 按下的标志位 while(!P44); } } else if(P42==0) { delayms(5); if(P42==0) { num=1; flag=1; while(!P42); } } else if(P35==0) { delayms(5); if(P35==0) { num=2; flag=1; while(!P35); } } /**************************/ //第二行扫描 P31=0; P30=P32=P33=1; P44=P42=P35=P34=1; if(P44==0) { delayms(5); if(P44==0) { num=3; flag=1; while(!P44); } } else if(P42==0) { delayms(5); if(P42==0) { num=4; flag=1; while(!P42); } } else if(P35==0) { delayms(5); if(P35==0) { num=5; flag=1; while(!P35); } } /**************************/ // 第三行扫描 P32=0; P30=P31=P33=1; P44=P42=P35=P34=1; if(P44==0) { delayms(5); if(P44==0) { num=6; flag=1; while(!P44); } } else if(P42==0) { delayms(5); if(P42==0) { num=7; flag=1; while(!P42); } } else if(P35==0) { delayms(5); if(P35==0) { num=8; flag=1; while(!P35); } } /**************************/ // 第四行扫描 --- 重点 P33=0; P30=P31=P32=1; P44=P42=P35=P34=1; if(P44==0) { delayms(5); if(P44==0) { num=9; flag=1; while(!P44); } } else if(P42==0) { delayms(5); if(P42==0) { if(shezhi==0) // 设置按键的标志位 { shezhi=1; EA=0; // 按下设置后 关闭中断 实际是为了关闭led灯的闪烁 TR0=0; ET0=0; P2=0X80; // 在设置时 关闭led P0=0XFF; P2=0XA0; // 在设置时 关闭 继电器 蜂咛器 P0=0X00; yi=liu=10; // - 显示设置时候的独特数码管 er=san=si=wu=qi=ba=12; } else if(shezhi==1) // 如果再次按下设置按键 打开中断 恢复小灯的闪烁 { shezhi=0; EA=1; // 按下设置后 打开中断 实际是为了恢复led灯的闪烁 TR0=1; ET0=1; max=er*10+san; // 再次按下这个设置按键时 保存所输入的最大与最小值 min=qi*10+ba; } while(!P42); } } else if(P35==0) { delayms(5); if(P35==0) { if(shezhi==1) // 如果在设置的状态下 按下清除键 则自动的清除当前输入的数值 { er=san=qi=ba=12; } while(!P35); } } 中断函数 — 重要uint tt=0; // 累加的标志位 bit led_spot=0; // led闪烁的标志位 void Timer0Init(void) // 定时器 0 5ms { AUXR |=0x80; TMOD &amp;=0XF0; TL0=0X00; TH0=0X28; TF0=0; TR0=1; ET0=1; EA=1; } void timer0 () interrupt 1 { tt++; /****************************************/ // 0区间 if(qujian==0) { if(tt==160) // 160*5=800ms=0.8s { tt=0; if(led_spot==0) // 设置标志位 实现数码管的闪烁 { led_spot=1; P2=0X80; // 关闭其他数码管 防止干扰 下同 P0=0XFF; P2=0X80; // 点亮 led P00=0; } else if(led_spot==1) { led_spot=0; P2=0X80; // 关闭 led P0=0xff; } } } /***************************************/ // 1区间 if(qujian==1) { if(tt==80) // 80*5=400ms=0.4s { tt=0; if(led_spot==0) { led_spot=1; P2=0X80; P0=0XFF; P2=0X80; P00=0; } else if(led_spot==1) { led_spot=0; P2=0X80; P0=0xff; } } } /***************************************/ //2 if(qujian==2) { if(tt==40) // 40*5=200ms=0.2s { tt=0; if(led_spot==0) { led_spot=1; P2=0X80; P0=0XFF; P2=0X80; P00=0; } else if(led_spot==1) { led_spot=0; P2=0X80; P0=0xff; } } } } 主函数中对标志位进行判断void main() { allinit(); Timer0Init(); yi=san=10;er=1; si=wu=liu=12; while(1) { keyscan16(); // 按键扫描 if(shezhi==0) // 在自动读取温度的页面 { wendu=Tempget(); if(wendu&lt;min) // 区间0 { qujian=0; // 对区间赋值 在中断中进行判断 实现不同频率的小灯闪烁 下同 P2=0XA0; // 关闭继电器 P0=0X00; } else if((wendu&gt;=min)&amp;&amp;(wendu&lt;=max)) // 区间1 注意格式 否则程序易卡死在循环中 { qujian=1; P2=0XA0; P0=0X00; } else if(wendu&gt;max) // 区间2 { qujian=2; P2=0XA0; // 超出最大值 继电器打开 P0=0X10; } yi=10; er=qujian; san=10; si=wu=liu=12; qi=wendu/10; ba=wendu%10; show_SMG(); // 数码管显示 } else if(shezhi==1 // 在设置页面 { if((er==12)&amp;&amp;(flag==1)) // - 判断按键的标志位 并且依次显示按下去的数值 { er=num; flag=0; } else if((san==12)&amp;&amp;(flag==1)) { san=num; flag=0; } else if((qi==12)&amp;&amp;(flag==1)) { qi=num; flag=0; } else if((ba==12)&amp;&amp;(flag==1)) { ba=num; flag=0; if((qi*10+ba)&gt;(er*10+san)) // 如果输入最小值大于最大值，清屏重新输入，并且打开提示，开继电器 { yi=liu=10; er=san=si=wu=qi=ba=12; // 清屏操作 P2=0X80; P01=0; } } show_SMG(); // 显示数码管 } show_SMG(); //再次显示数码管 防漏 } } 版权所有，未经允许，不得转载 !","categories":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"http://yoursite.com/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}],"tags":[]},{"title":"蓝桥杯-第四届(自动灌溉系统)","slug":"蓝桥杯-第四届(自动灌溉)","date":"2020-04-05T04:49:16.000Z","updated":"2020-06-01T11:25:53.332Z","comments":true,"path":"2020/04/05/蓝桥杯-第四届(自动灌溉)/","link":"","permalink":"http://yoursite.com/2020/04/05/%E8%93%9D%E6%A1%A5%E6%9D%AF-%E7%AC%AC%E5%9B%9B%E5%B1%8A(%E8%87%AA%E5%8A%A8%E7%81%8C%E6%BA%89)/","excerpt":"","text":"这是我自己在学习蓝桥杯过程中总结的一些知识，希望对今后的学习和备战蓝桥的同学能够提供一些帮助吧。蓝桥杯-第四届(自动灌溉系统)1.试题要求如下 2.题目要点分析 3.注意事项1）使用电位器RB2输出电压模拟湿度输出值2）系统RTC(1302)通过EEPROM保存阈值3）本届的代码不是很难，但它的思维逻辑要求比较大，重要的是区分清楚手动和自动两种工作的模式4.代码实现开始的一些初始化之类的和第三届一样，这里不再分开叨叙(一笔简明带过)，忘记的朋友可以去看第三届解析uchar tab[]={0xc0, // 段选 0- 9 加上 - . 熄灭 0xf9,0xa4,0xB0,0x99,0x92,0x82,0xf8,0x80,0x90, 0xbf,0x7f,0xff}; // - . uint yi,er,san,si,wu,liu,qi,ba; // 全局变量 控制数码管的段选显示变化 void delayms(uint a) // 延时 { uint b; for(;a&gt;0;a--) { for(b=845;b&gt;0;b--); } } void all_init() // 初始化 关闭蜂咛器 继电器 数码管等 { P2=0XA0; P0=0X00; P2=0X80; P0=0XFF; P2=0XC0; P0=0XFF; P2=0XFF; P0=0XFF; } void display(uint channel,uint num) // 数码管的位选与段选 { P2=0XC0; P0=0X01&lt;&lt;channel; P2=0XE0; P0=tab[num]; delayms(2); } void show_SMG() // 数码管显示函数 { display(0,yi); display(1,er); display(2,san); display(3,si); display(4,wu); display(5,liu); display(6,qi); display(7,ba); } 官方提供的RTC(1302)代码资料 — 需修改 — 重点/**************************************************/ //以下为官方提供 #include &lt;STC15F2K60S2.H&gt; #include &lt;intrins.h&gt; #include &quot;ds1302.h&quot; sbit SCK=P1^7; sbit SDA=P2^3; sbit RST = P1^3; // DS1302复位 void Write_Ds1302_Byte(unsigned char temp) { unsigned char i; for (i=0;i&lt;8;i++) { SCK=0; SDA=temp&amp;0x01; temp&gt;&gt;=1; SCK=1; } } void Write_Ds1302( unsigned char address,unsigned char dat ) { RST=0; _nop_(); SCK=0; _nop_(); RST=1; _nop_(); Write_Ds1302_Byte(address); //Write_Ds1302_Byte(dat); 这为原来官方提供的51例程，但应用在15程序中应该如下修改 Write_Ds1302_Byte((dat/10&lt;&lt;4)|(dat%10)); // 这为修改后的 RST=0; } unsigned char Read_Ds1302 ( unsigned char address ) { unsigned char i,temp=0x00; uchar dat1,dat2; // 本来没有这两个参数，但为了修改成15，添加的 RST=0; _nop_(); SCK=0; _nop_(); RST=1; _nop_(); Write_Ds1302_Byte(address); for (i=0;i&lt;8;i++) { SCK=0; temp&gt;&gt;=1; if(SDA) temp|=0x80; SCK=1; } RST=0; _nop_(); RST=0; SCK=0; _nop_(); SCK=1; _nop_(); SDA=0; _nop_(); SDA=1; _nop_(); /************************************/ //这段代码原来没有，需要自己添加(源代码无删减) dat1=temp/16; // 进制的转化 在1302中 使用的是压缩BCD码 dat2=temp%16; temp=dat1*10+dat2; /************************************/ return (temp); } /****************************************************/ //以下需要自己编写 uchar shijian[]={0,30,8,0,0,0,0}; // 1302 秒 分 时 日 月 周 年 void DS_Write(void) // 在1302中写入数据 { uchar i,add; add=0x80; // 0x80写 0x81读 Write_Ds1302(0x8e,0x00); // 开始(0x00) for(i=0;i&lt;7;i++) { Write_Ds1302(add,shijian[i]); add+=2; // 1302 寄存器定义 读与写 每次加二(可能因为压缩PCB码缘故) } Write_Ds1302(0x8e,0x80); // 关闭(0x80) } void DS_Read(void) // 读取1302的数据 { uchar i,add; add=0x81; // 0x81读 Write_Ds1302(0x8e,0x00); // 开始(0x00) for(i=0;i&lt;7;i++) { shijian[i]=Read_Ds1302(add); add+=2; } Write_Ds1302(0x8e,0x80); // 关闭(0x80) } 官方提供的IIC代码资料 — 需修改成EEPROM — 需修改成AD — 重点/***************************************************/ //以下代码官方提供 #include &quot;STC15F2K60S2.H&quot; #include &quot;intrins.h&quot; #include &quot;iic.h&quot; #define somenop {_nop_();_nop_();_nop_();_nop_();_nop_();} //这里需要扩大8倍延时 #define SlaveAddrW 0xA0 #define SlaveAddrR 0xA1 sbit SDA = P2^1; /* 数据线 */ sbit SCL = P2^0; /* 时钟线 */ void IIC_Start(void) // 总线启动 { SDA = 1; SCL = 1; somenop; SDA = 0; somenop; SCL = 0; } void IIC_Stop(void) // 总线停止 { SDA = 0; SCL = 1; somenop; SDA = 1; } bit IIC_WaitAck(void) // 等待应答 { SDA = 1; somenop; SCL = 1; somenop; if(SDA) { SCL = 0; IIC_Stop(); return 0; } else { SCL = 0; return 1; } } void IIC_SendByte(unsigned char byt) // 发送数据 { unsigned char i; for(i=0;i&lt;8;i++) { if(byt&amp;0x80) { SDA = 1; } else { SDA = 0; } somenop; SCL = 1; byt &lt;&lt;= 1; somenop; SCL = 0; } } unsigned char IIC_RecByte(void) // 接收数据 { unsigned char da; unsigned char i; for(i=0;i&lt;8;i++) { SCL = 1; somenop; da &lt;&lt;= 1; if(SDA) da |= 0x01; SCL = 0; somenop; } return da; } /*********************************************************/ //以下代码需要自己写 uchar AD_read(uchar add) // 与读取IIC代码一样 { uchar temp; IIC_Start(); IIC_SendByte(0x90); IIC_WaitAck(); IIC_SendByte(add); IIC_WaitAck(); IIC_Stop(); IIC_Start(); IIC_SendByte(0x91); IIC_WaitAck(); temp=IIC_RecByte(); IIC_Stop(); return temp; } /***********************/ //EEPROM uchar EEPROM_read(uchar add) { uchar temp; IIC_Start(); IIC_SendByte(0xa0); IIC_WaitAck(); IIC_SendByte(add); IIC_WaitAck(); IIC_Stop(); IIC_Start(); IIC_SendByte(0xa1); IIC_WaitAck(); temp=IIC_RecByte(); IIC_Stop(); return temp; } void EEPROM_write(uchar add,uchar dat) // 写数据 哪个地址 写入什么数据 { IIC_Start(); IIC_SendByte(0xa0); IIC_WaitAck(); IIC_SendByte(add); IIC_WaitAck(); IIC_SendByte(dat); // 写入数据 IIC_WaitAck(); IIC_Stop(); } 按键功能操作 uchar s7_spot=0; // s7标志位 uchar s6_spot=0; // s6标志位 uchar jia_spot=0; // 加的标志位 uchar jian_spot=0; // 减的标志位 uchar fazhi; // 阈值(存入EEPROM) uchar kai=1; // 蜂咛器 uchar jidianqi=0; // 继电器 模拟灌溉设备的打开与关闭 void keyscan() { /***************************///s7 if(P30==0) { delayms(2); if(P30==0) { if(s7_spot==0) // s7_spot = 0 自动状态 { s7_spot=1; P0=0XFF; P2=0X80; // led2 亮 P01=0; } else if(s7_spot==1) // s7_spot = 1 手动状态 { s7_spot=0; P0=0XFF; P2=0X80; // led1 亮 P00=0; } }while(!P30); } /******************************///s6 if(P31==0) { delayms(2); if(P31==0) { if(s7_spot==0) // 说明是在自动状态下 { if(s6_spot==0) { s6_spot=1; } else if(s6_spot==1) { s6_spot=0; } } else if(s7_spot==1) // 说明在手动状态下 { kai = ~kai; // 蜂咛器开和关的标志位 } }while(!P31); } /*******************************///s5 +1 if(P32==0) { delayms(2); if(P32==0) { if(s7_spot==0) // 在自动状态下 { jia_spot=1; // 加 标志位 } else if(s7_spot==1) // 在手动状态下 { jidianqi=1; // 灌溉设备打开 } }while(!P32); } /*****************************///s4 -1 if(P33==0) { delayms(2); if(P33==0) { if(s7_spot==0) // 在自动状态下 { jian_spot=1; // 减 标志位 } else if(s7_spot==1) // 在手动状态下 { jidianqi=0; // 灌溉设备关闭 } }while(!P33); } } 主函数中对标志位进行判断extern uchar shijian[]; // 对1302的储存数组进行声明 void main() { uchar shidu=0; yi=0;er=8;san=10;si=3;wu=0;liu=12;qi=5;ba=0; all_init(); P2=0X80; // L1亮 自动工作模式 P00=0; DS_Write(); // ds1302写 while(1) { DS_Read(); // ds1302读 shidu=AD_read(0x03); // 从AD里面读取电压模拟湿度 shidu=shidu*0.39; // 225转换为0~5伏 if(s7_spot==0) // s7没有被按下 为自动状态 L1 { // EEPROM_write(0x10,50); // 已经初始值为50，不在打开，将其地址赋予0x10，下次上电直接从EEPROM读取，不再赋予初值和地址 // delayms(5); // 延时等待应答 fazhi=EEPROM_read(0x10); // 读取阈值 /*当前读取的湿度与阈值进行比较 小于则自动打开灌溉设备(通过继电器模拟)*/ if(shidu&lt;fazhi) { P2=0XA0; P0=0X10; } else { P2=0XA0; P0=0X00; } if(s6_spot==1) // s6按下 需要对阈值进行调整 { if(jia_spot==1) // 在s6按下后，s5被按下，加标志位为1 阈值加1 { jia_spot=0; fazhi=fazhi+1; } if(jian_spot==1) // 在s6按下后，s4被按下，减标志位为1 阈值减1 { jian_spot=0; fazhi=fazhi-1; } EEPROM_write(0x10,fazhi); // 将改变的值写入EEPROM中 yi=er=10; // 在进行阈值调整时，显示独特的显示页面 san=si=wu=liu=12; qi=fazhi/10; ba=fazhi%10; } else if(s6_spot==0) // s6没有按下 显示1302里面存储的数 { yi=shijian[2]/10; er=shijian[2]%10; san=10; si=shijian[1]/10; wu=shijian[1]%10; liu=12; qi=shidu/10; // 显示湿度 ba=shidu%10; } } /**************************************************************/ //以下两种按键实际就是 在手动工作模式下 当湿度小于阈值时，蜂咛器报警，s6可以将蜂咛 //器关闭，再次按下s6,可以开启对蜂咛器的控制。而在手动工作模式下，蜂咛器的工作(叫或 //者不叫)不会被s5、s4按键的按下所干扰，s5、s4按下只控制灌溉系统(继电器)的工作 。 else if(s7_spot==1) // s7被按下 为手动状态 L2 { if((shidu&lt;fazhi)&amp;&amp;(kai==0)) // 在手动状态下，s6被按下，蜂咛器标志位kai取反为0 { if(jidianqi==1) // 手动状态下 s5按下 只有继电器亮(暗示蜂咛器被关闭) { P2=0XA0; P0=0X10; } else if(jidianqi==0) // 手动状态下 s4按下 继电器灭 { P2=0XA0; P0=0X00; } } else if((shidu&lt;fazhi)&amp;&amp;(kai==1)) // 在手动状态下，s6没有被按下(s6被按下后 // 又被按下)，蜂咛器标志位为1 { if(jidianqi==1) // 在手动情况下，蜂咛器报警，开启灌溉 { // s5按下 继电器亮 蜂咛器叫 P2=0XA0; P0=0X50; } else if(jidianqi==0) { // s4按下 继电器灭 蜂咛器叫 P2=0XA0; P0=0X40; } } /**************************************************************/ else if(shidu&gt;fazhi) { if(jidianqi==1) // 手动状态下 s5按下 继电器亮 { P2=0XA0; P0=0X10; } else if(jidianqi==0) // 手动状态下 s4按下 继电器灭 { P2=0XA0; P0=0X00; } } yi=shijian[2]/10; er=shijian[2]%10; san=10; si=shijian[1]/10; wu=shijian[1]%10; liu=12; qi=shidu/10; ba=shidu%10; } // else if(s7_spot==1) 的括号 keyscan(); // 按键扫描函数 show_SMG(); // 对全局变量 yi~ba 返回的值进行数码管显示 } // while的括号 } // main的括号 版权所有，未经允许，不得转载 !","categories":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"http://yoursite.com/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}],"tags":[]},{"title":"蓝桥杯-第三届(自动售水机)","slug":"蓝桥杯-第三届(自动售水机)","date":"2020-03-28T04:49:16.000Z","updated":"2020-06-01T11:25:44.767Z","comments":true,"path":"2020/03/28/蓝桥杯-第三届(自动售水机)/","link":"","permalink":"http://yoursite.com/2020/03/28/%E8%93%9D%E6%A1%A5%E6%9D%AF-%E7%AC%AC%E4%B8%89%E5%B1%8A(%E8%87%AA%E5%8A%A8%E5%94%AE%E6%B0%B4%E6%9C%BA)/","excerpt":"","text":"这是我自己在学习蓝桥杯过程中总结的一些知识，希望对今后的学习和备战蓝桥的同学能够提供一些帮助吧。蓝桥杯-第三届(自动售水机)1.试题要求如下 2.题目要点分析1) 上电后各部分要初始化(关闭蜂咛器、数码管、led灯、继电器)，并且数码管要显示题目要求初始的数(含格式)2）按下 S7 清屏开始计数(计数器中断)流水显示，S6停止流水计数并且计算显示出流水价格3) 通过光敏电阻读取环境的亮度，当其发生改变时，做出不同的响应4）掌握IIC3.注意事项1）数码管小数的显示，需要重新计算数码管段选数组 tab_spot[] ，都加上h，使其显示出小数点2）S7按键不会改变流水的状态，唯有S6可以改变, S7作用只有一个，就是清屏开始流水计数3）通过流水量计算出价格这方法要注意4）光敏电阻读取数据与显示的转换要注意（ IIC 写0x90, 读0x91)5) 引用头文件并且定义无符号类型#include &quot;STC15f2k60S2.h&quot; #include &quot;intrins.h&quot; // 引用头文件 调用iic里面的延时函数 _nop_() #define uchar unsigned char #define uint unsigned int 4.代码实现首先是进行初始化void allinit() // 初始化 { P2=0XA0; P0=0X00; P2=0X80; P0=0XFF; P2=0XC0; P0=0XFF; P2=0XFF; P0=0XFF; } 延时函数void delayms(uchar a) { uint b; for(;a&gt;0;a--) { for(b=845;b&gt;0;b--) { } } } 数码管显示(双重—-正常不加小数点和加小数点)uchar tab[]={0xc0, 0xf9,0xa4,0xB0,0x99,0x92,0x82,0xf8,0x80,0x90, 0xff}; // 不加小数点 uchar tab_spot[]={0x40, 0x79,0x24,0x30,0x19,0x12,0x02,0x78,0x00,0x10, 0xff}; // 加上小数点的 void display(uchar channel,uchar num) // 不加小数点段选的数码管显示 { P2=0XC0; P0=0X01&lt;&lt;channel; P2=0XE0; P0=tab[num]; delayms(2); } void display_spot(uchar channel,uchar num) // 加小数点段选的数码管显示 { P2=0XC0; P0=0X01&lt;&lt;channel; P2=0XE0; P0=tab_spot[num]; delayms(2); } 题目要求的数码管显示格式uchar yi,er,san,si,wu,liu,qi,ba; // 全局变量 void display_SMG() { display(0,yi); display_spot(1,er); display(2,san); display(3,si); display(4,wu); display_spot(5,liu); display(6,qi); display(7,ba); } 中断void Timer0Init(void) // 5毫秒 来源stc定时器计算器 波特率11.0592 定时器0 16位自动重载 { AUXR |= 0x80; TMOD &amp;= 0xF0; TL0 = 0x00; TH0 = 0x28; TF0 = 0; TR0 = 1; } uint aa=0; // 三个全局变量 进行时间、金钱计算 uint bb=0; uint money=0; void time0 () interrupt 1 // 定时器中断服务函数 1 { aa++; if(aa==20) // 100毫秒 { bb++; // 100毫秒=10毫升 (相当于数码管最后一位) aa=0; ba=bb%10; qi=bb%100/10; liu=bb%1000/100; wu=bb/1000; } if(bb==9999) { bb=0; money=bb*0.5; // 进行金钱转化 ba=money%10; qi=money%100/10; liu=money%1000/100; wu=money/1000; } } 按键操作void start() // S7按下 开启 { wu=liu=qi=ba=0; // 使得开始按按键时 数码管后四位清零 P2=0XA0; // 开启继电器 P0=0X10; ET0=1; // 开启定时器 EA=1; } void off() // S6按下 关闭 { P2=0XA0; // 关闭继电器 P0=0X00; EA=0; // 关闭定时器 ET0=0; money=bb*0.5; // 关闭时自动显示价钱 ba=money%10; qi=money%100/10; liu=money%1000/100; wu=money/1000; bb=0; // 确保下次开始计数时 从0开始 } void keyscan() { if(P30==0) { delayms(2); if(P30==0) { start(); } while(!P30); } if(P31==0) { delayms(2); if(P31==0) { off(); } while(!P31); } } 实现光敏电阻的各项功能 (要利用给的IIC文件夹，稍加修改即可)/*********************************************/ // 以下函数在官方数据手册提供 /*********************************************/ // _nop_() 需要引入头文件 &quot;intrins.h&quot; #define somenop {_nop_();_nop_();_nop_();_nop_();_nop_();} // 这为官方给的51 #define somenop {_nop_();_nop_();_nop_();_nop_();_nop_(); // 15的延时大概为51的8倍 _nop_();_nop_();_nop_();_nop_();_nop_(); _nop_();_nop_();_nop_();_nop_();_nop_(); _nop_();_nop_();_nop_();_nop_();_nop_(); _nop_();_nop_();_nop_();_nop_();_nop_(); _nop_();_nop_();_nop_();_nop_();_nop_(); _nop_();_nop_();_nop_();_nop_();_nop_(); _nop_();_nop_();_nop_();_nop_();_nop_(); } #define SlaveAddrW 0xA0 // 写 #define SlaveAddrR 0xA1 // 读 sbit SDA = P2^1; /* 数据线 */ sbit SCL = P2^0; /* 时钟线 */ void IIC_Start(void) // 启动条件 { SDA = 1; SCL = 1; somenop; SDA = 0; somenop; SCL = 0; } void IIC_Stop(void) // 停止条件 { SDA = 0; SCL = 1; somenop; SDA = 1; } bit IIC_WaitAck(void) // 等待应答 { SDA = 1; somenop; SCL = 1; somenop; if(SDA) { SCL = 0; IIC_Stop(); return 0; } else { SCL = 0; return 1; } } void IIC_SendByte(unsigned char byt) // 通过iic发送数据 { unsigned char i; for(i=0;i&lt;8;i++) { if(byt&amp;0x80) { SDA = 1; } else { SDA = 0; } somenop; SCL = 1; byt &lt;&lt;= 1; somenop; SCL = 0; } } unsigned char IIC_RecByte(void) // 接收iic数据 { unsigned char da; unsigned char i; for(i=0;i&lt;8;i++) { SCL = 1; somenop; da &lt;&lt;= 1; if(SDA) da |= 0x01; SCL = 0; somenop; } return da; } /***********************************/ //以下的函数需要自己根据官方提供的函数来编写 uchar iic_read(uchar add) { uchar temp; /******************/ IIC_Start(); IIC_SendByte(0x90); IIC_WaitAck(); IIC_SendByte(add); IIC_WaitAck(); IIC_Stop(); /*****************/ IIC_Start(0x91); IIC_SendByte(0x91); IIC_WaitAck(); temp=IIC_RecByte(); IIC_WaitAck(); IIC_Stop(); /****************/ return temp; } 主函数void main() { uchar guangmin; // 记录数码管的值 all_init(); // 初始化，关闭蜂咛器，继电器之类 Timer0Init(); // 中断初始化 yi=10,er=0,san=5,si=0,wu=0,liu=1,qi=0,ba=0; // 开始数码管的显示 while(1) { display_SMG(); // 初始化数码管 keyscan(); // 读取按键反馈回来的全局变量 yi ~ ba 的值，并且控制其他模块 guangmin=iic_read(0x01); // !!! iic读取光敏电阻的值并进行转换 if(guangmin&lt;64) // !!! { P0=0XFF; // 避免其小灯的干扰 P2=0X80; P00=0; // 点亮 } else { P2=0X80; P0=0XFF; } } } 5.完整的代码参考(仅供学习)链接：https://pan.baidu.com/s/138PEwdj5GlsxOEjPLrFB4Q提取码：6kt5 注: 本文为原创，未经允许，禁止转载！","categories":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"http://yoursite.com/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}],"tags":[]},{"title":"蓝桥杯基础","slug":"蓝桥杯基础","date":"2020-03-19T04:49:16.000Z","updated":"2020-06-01T11:25:35.145Z","comments":true,"path":"2020/03/19/蓝桥杯基础/","link":"","permalink":"http://yoursite.com/2020/03/19/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%9F%BA%E7%A1%80/","excerpt":"","text":"这是我自己在学习蓝桥杯过程中总结的一些知识，希望对今后的学习和备战蓝桥的同学能够提供一些帮助吧。必须要知道的知识1. void delayms(uint ms) // 15芯片延时一毫秒软件实现 { uint a; for(;ms&gt;0;ms--) { for(a=845;a&gt;0;a--); } } 2.void allinit(void) // 初始化关闭其他模块(led、继电器、蜂咛器、数码管) { P2=0XA0; // 继电器，蜂咛器 P0=0X00; P2=0X80; // 小灯 P0=0XFF; P2=0XC0; // 段选 1~8 P0=0XFF; P2=0XFF; P0=0XFF; } 3.void keyscan(void ) // 独立按键 从上至下 S7 - S4 (P30 - P33) { if(P30==0) { delayms(5); if(P30==0) { } while(!P30); // 消抖操作 } if(P31==0) { delayms(5); if(P31==0) { } while(!P31); } if(P32==0) { delayms(5); if(P32==0) { } while(!P32); } if(P33==0) { delayms(5); if(P33==0) { } while(!P33); } } 4.void display16() // 矩阵按键(需要改变按键跳线帽) P37 = P44 P36 = P42 { /**************************/ // 第1横行读取 P30=0; P31=P32=P33=1; // 从上至下(行) S7 - S4 (P30 - P33) P44=P42=P35=P34=1; // 从左至右(列) P44(P37) P42(P36) P35 P34 if(P44==0) { delayms(5); if(P44==0) { while(!P44); // 消抖 } } else if(P42==0) { delayms(5); if(P42==0) { while(!P42); } } else if(P35==0) { delayms(5); if(P35==0) { while(!P35); } } else if(P34==0) { delayms(5); if(P34==0) { while(!P34); } } /**************************/ // 第2横行读取 P31=0; P30=P32=P33=1; P44=P42=P35=P34=1; if(P44==0) { delayms(5); if(P44==0) { while(!P44); } } else if(P42==0) { delayms(5); if(P42==0) { while(!P42); } } else if(P35==0) { delayms(5); if(P35==0) { while(!P35); } } else if(P34==0) { delayms(5); if(P34==0) { while(!P34); } } /**************************/ // 第3横行读取 P32=0; P30=P31=P33=1; P44=P42=P35=P34=1; if(P44==0) { delayms(5); if(P44==0) { while(!P44); } } else if(P42==0) { delayms(5); if(P42==0) { while(!P42); } } else if(P35==0) { delayms(5); if(P35==0) { while(!P35); } } else if(P34==0) { delayms(5); if(P34==0) { while(!P34); } } /**************************/ // 第4横行读取 P33=0; P30=P31=P32=1; P44=P42=P35=P34=1; if(P44==0) { delayms(5); if(P44==0) { while(!P44); } } else if(P42==0) { delayms(5); if(P42==0) { while(!P42); } } else if(P35==0) { delayms(5); if(P35==0) { while(!P35); } } else if(P34==0) { delayms(5); if(P34==0) { while(!P34); } } } 5.uchar tab[]={0xc0, 0xf9,0xa4,0xB0,0x99,0x92,0x82,0xf8,0x80,0x90, 0xbf,0x7f,0xff}; // - . void display(uchar channel,uchar number) // 位选 段选 { P2=0XC0; // 段选 P0=0X01&lt;&lt;channel; P2=0XFF; // 段选 P0=tab[number]; delayms(1); } display(7,1); // 使得数码管 从左数第七个 显示1 后续将继续补充与完善…","categories":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"http://yoursite.com/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}],"tags":[]},{"title":"c与c++知识点(四)","slug":"C与C++笔记4","date":"2020-03-17T04:49:16.000Z","updated":"2020-06-01T11:25:14.574Z","comments":true,"path":"2020/03/17/C与C++笔记4/","link":"","permalink":"http://yoursite.com/2020/03/17/C%E4%B8%8EC++%E7%AC%94%E8%AE%B04/","excerpt":"","text":"这是我自己在学习c++基础的过程中，顺便复习了下C语言，然后总结的一些小小知识点。—写在前面的话第四节1.c++面向对象特性 封装 继承 多态 万事万物都皆为对象2. c++ class aa { //访问权限 //属性（变量） //行为（函数） } 3.属性和行为 都称之为 成员 成员属性 = 属性4. public // 公共权限 成员 类内可以访问 类外可以访问 Protected // 保护权限 成员 类内可以访问 类外不可以访问（儿子可以访问父亲的保护内容） Private // 私有权限 成员 类内可以访问 类外不可以访问（儿子不可以访问父亲私有权限） 5.struct class // 区别在于 默认访问权限不同 struct // 默认为公共 public class // 默认为私有 private 未完待续…","categories":[{"name":"c与c++","slug":"c与c","permalink":"http://yoursite.com/categories/c%E4%B8%8Ec/"}],"tags":[]},{"title":"c与c++知识点(三)","slug":"C与C++笔记3","date":"2020-03-16T04:49:16.000Z","updated":"2020-06-01T11:25:05.209Z","comments":true,"path":"2020/03/16/C与C++笔记3/","link":"","permalink":"http://yoursite.com/2020/03/16/C%E4%B8%8EC++%E7%AC%94%E8%AE%B03/","excerpt":"","text":"这是我自己在学习c++基础的过程中，顺便复习了下C语言，然后总结的一些小小知识点。—写在前面的话第三节1.C++内存分为四个区 // 代码区 存放函数体的二进制代码 // 全局区 存放全局变量和静态变量以及常量 // 栈区 编译器自动分配 存放函数参数值 局部变量 // 堆区 程序员分配和释放，程序员不释放，程序结束时操作系统回收 // 意义： 不同区域存放的数据，赋予不同的生命中秋，给予更大的灵活编程 // 代码区 （程序运行前就有）存放二进制机器指令 特点 : 共享、只读 // 全局区 （程序运行前就有）存放全局变量和静态变量以及常量 该区的数据在程序结束后，由操作系统释放 // 在全局区（静态变量 static关键字 常量（字符串常量和const 修饰的全局变量）） 不在全局区的数据（局部常量） // 栈区 （程序运行后才有）不要返回局部变量的地址 // 堆区 （程序运行后才有）（程序员手动开辟和释放（delete））利用new关键字，将数据开辟到堆区返回的直接是地址 int * p = new int (10) ; // 指针本质在栈区，其数据在堆区 2. new // 返回的是该数据类型的指针 int * p=new int(10) ; // 创建了一个new型为10的变量地址 (释放 delete p;) 3. int * array = nem int[10]; // 创建了一个变量为整型个数为10的数组，他的首地址给了array (释放数组 delete[] arr;) 4.// 引用：就是给变量起别名 // 语法：数据类型 &amp;别名=原名 对别名进行操作等于对原名的数据进行操作 int a=10; int &amp; b = a; b = 20; // 那么 a也为20 5. // 引用的注意事项 // 1) 引用的时候必须要给予初始化 int &amp; b = a; (引用过程给予初始化，只有这一种写法) // 2) 引用一旦初始化后，不可更改 6. // 引用也会使得形参修饰实参 void my3(int &amp;a,int &amp;b) // 有两种解决办法 指针 和 引用 // 注意事项: // 1 )不要返回局部变量的引用 int &amp;test() { int a=10;return a; } // 2 )函数的调用可以作为左值 int &amp;ref=test(); test()=100; cout &lt;&lt; ref &lt;&lt; endl; ref = 100; 7. //引用的本质是一个指针常量 int a=10; int &amp;b = a; // 相当于 int * const b = &amp;a; 这也就是为什么引用不可修改，因为指针常量的指针指 向不可修改(b中保存着a的地址) cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl; a = b = 10; // b = 20解引用 也就是*b = 20; 8. // 常量引用 // 引用的两种写法 // 1 ) int a=10； int &amp; b = a // (必须为名称，不能为10)； // 2) const int &amp; b = 10; // 第二种相当于编译器系统设置了一个变量 int temp = 10； const int &amp;b = temp； b = 20 // (这是错误的，因为加上const 之后变为只读不可修改状态) 9. // 函数默认参数 优先用户自定义的 int fun(int a,int b=10,int c=30) { return a+b+c; } main { cout &lt;&lt; fun (10 , 30 , 30 ) ; } // 70; // 当某个位置有了默认参数，那么他后边都必须是默认参数(例如 b为默认参数，那么 c 也必须是默认参数) 10.// 声明和实现 只能有一个有默认参数 int fun (int a = 10,int b = 30); int fun(int a , int b) { return a + b; } // 40 11.// 占位参数（只有函数类型，没有名字） void fun ( int a , int) { cout &lt;&lt; ” abc ” ; } // 引用时fun(10 , 10) 占位参数还可以有默认参数 void fun(int a , int = 10) { return “ abc ” ; } // 引用时 fun( 10 ) 12. // 函数重载(函数名可以相同) // 条件 : 同一个作用域下 函数名称相同 函数的参数类型不同 或者 个数不同或者顺序不同 // 注意：函数的返回值不可以作为函数重载的条件,如下 void fun ( ) void fun(int a) void fun(double b) 未完待续…","categories":[{"name":"c与c++","slug":"c与c","permalink":"http://yoursite.com/categories/c%E4%B8%8Ec/"}],"tags":[]},{"title":"c与c++知识点(二)","slug":"C与C++笔记2","date":"2020-03-14T04:49:16.000Z","updated":"2020-06-01T11:24:58.271Z","comments":true,"path":"2020/03/14/C与C++笔记2/","link":"","permalink":"http://yoursite.com/2020/03/14/C%E4%B8%8EC++%E7%AC%94%E8%AE%B02/","excerpt":"","text":"这是我自己在学习c++基础的过程中，顺便复习了下C语言，然后总结的一些小小知识点。—写在前面的话第二节1./*二维数组 总元素*/ sizeof ( arr ) ; /* 第一行元素 */ sizeof ( arr [0] ) ; /* 行数 */ sizeof ( arr ) / sizeof ( arr [0] ) /* 列数 */ sizeof ( arr [0]) / sizeof( arr [0] [0] ) ) 2./* 二维数组首地址 */ cout &lt;&lt; arr &lt;&lt; endl; /* 第一行首地址 */ cout &lt;&lt; arr [0] &lt;&lt; endl; /*第一个元素首地址 */ cout &lt;&lt; &amp; arr [0] [0] &lt;&lt; endl; // 此三者相等三者相等 /* 第二行首地址 */ cout &lt;&lt; arr[1] &lt;&lt; endl; 3./*指针就是地址*/ int *p; （p为指针变量） //使用时需要解引用 *p 即可 ( *p解引用） 4./*空指针: 用来给指针变量进行初始化，空指针不可以进行访问的*/ int *p = NULL; //不可再将地址赋值给 p 输出 5.const修饰指针 ---重点 1）const修饰指针---常量指针 2）const修饰常量---指针常量 3）const既修饰指针又修饰常量 6.—重点—//1）常量指针 const int * p = &amp;a; /*指针的指向可以修改，但是指针指向 的值不可修改 */ //2）指针常量 int * const p = &amp;a; /*指针的指向不可以修改，指针的值可以修改 */ //3）既修饰指针又修饰常量 const int * const p = &amp;a; /*指针的指向和指针的值都不可以修改 */ //（如何记忆: const—常量 ，* p —指针 如何用：紧接着 const 的是p / * 紧跟着谁 谁不能操作） 7.int arr [10], int * p; p = arr ; cout &lt;&lt; *p; //（数组的名称为其的首地址) 8.值传递，不能修改实参的值，只能修改形参的值。地址传递可以修改实参的值。9.结构体struct student/**** 自己创建的结构体类型为 student, 此类型的变量名字为s1, s2 ***/ { string name; int age; int score; }; //1 struct student s1; //2 struct student s2 = { }; //3 创建结构体时顺便创建结构体变量,通过.来访问结构体中的属性 10.结构体创建自定义类型过程中struct不能省略，但是创建变量的过程c++ struct可以 省略11. // 结构体数组 struct 结构体名字 数组名字{个数}={ { }，{ } ，{ } } // 结构体指针 利用-&gt;可以通过结构体来访问结构体的属性 student s1 = { &quot;李斯&quot;,56,99 }; student * p = &amp;s1; cout &lt;&lt; &quot;姓名:&quot; &lt;&lt; p-&gt;name &lt;&lt; &quot;年龄:&quot; &lt;&lt; p-&gt;age &lt;&lt; &quot;分数&quot; &lt;&lt; p-&gt;score; 12.结构体嵌套结构体 struct student { string name; int scroe; }; struct teacher { int id; string name; int age; struct student s1;//学生 s1 }; teacher t; t.id = 10086; t.name = &quot;老王&quot;; t.age = 58; t.s1. name = &quot;小王&quot;; t.s1.scroe = 99; teacher * p = &amp;t; cout &lt;&lt; &quot;老师姓名：&quot; &lt;&lt; p-&gt;name &lt;&lt; &quot;老师工号: &quot; &lt;&lt; p-&gt;id &lt;&lt; &quot;老师年龄: &quot; &lt;&lt; p-&gt;age &lt;&lt; &quot;老师的学生名字: &quot; &lt;&lt; p-&gt;s1.name &lt;&lt; &quot;老师的学生分数: &quot; &lt;&lt; p-&gt;s1.scroe; 13. 结构体中使用const来防止误操作14.—重点—main里面调用函数，形参相当于把参数复制了一遍，增大了储存空间和代码量。将函数的形参变为指针，可以大大减少内存的占用（指针不会复制数据，其只是进行地址传递）15. system( “ pause ” ); //请按任意键继续 system( “ cls ” ); //清屏操作 未完待续…","categories":[{"name":"c与c++","slug":"c与c","permalink":"http://yoursite.com/categories/c%E4%B8%8Ec/"}],"tags":[]},{"title":"c与c++知识点(一)","slug":"C与C++笔记1","date":"2020-03-09T04:49:16.000Z","updated":"2020-06-01T11:24:49.257Z","comments":true,"path":"2020/03/09/C与C++笔记1/","link":"","permalink":"http://yoursite.com/2020/03/09/C%E4%B8%8EC++%E7%AC%94%E8%AE%B01/","excerpt":"","text":"这是我自己在学习c++基础的过程中，顺便复习了下C语言，然后总结的一些小小知识点。—写在前面的话第一节1.int a; sizeof(int) = sizeof(a); ---求所储存的字节 2.float aa = &#39;A&#39; cout &lt;&lt; (int)aa &lt;&lt; endl; //输出A的数值(强制转化为 int) 注意格式 3.float f2 = 3e2 //3*10^2 float f3 = 3e-2 //3*0.1^2 4.bool 真或假 bool flag = false/true(0/1); —除了0为假，其余都为真5.字符串&nbsp;&nbsp;(1)char str[ ] = &quot;hello world&quot; cout&lt;&lt;str&lt;&lt;endl; &nbsp;&nbsp;(2) string 变量名 =”字符串值” （引用头文件include“string” 有的是在iostream头文件中）string name[3] = {&quot;张三&quot;,&quot;李四&quot;,&quot;王麻子&quot;}; string name=”胖虎”； 6.int a1 = 10; ++a1*10; //(运算结果为110)先加1后乘以10， int a1 =10; a1++*10; //(运算结果为101)先乘以10 后加1，先执行表达式，再增加 7.-= /= %= int a=10; int b=5; cout&lt;&lt;(a==b); //输出结果为0(假) 8.rand() % 80; //生成0-79的随机数 rand() % 80+1; // 生成0-80随机数 /* 需要包含头文件 #include “cstdlib” */ // #include ”ctime“ (伪函数) srand((unsigned int)time(NULL)); 利用系统时钟生成伪数字 9.int a = 10; int b = 20; (a&lt;b?a:b)=100; cout &lt;&lt;a; a=100 cout&lt;&lt;b; //b=2 10.int a = 354; //个位 a%10 十位 a%100/10 百位 a/100 11. \\t 制表符代替空格 12.goto flag ； flag： //跳转语句 ---读懂就可，不建议使用 13./*数组*/ int arr[5] = {1,2,3,4,5} /*每个数组占用的内存空间*/ sizeof(arr) /*每个素占用的内存空间 */ sizeof(arr[0]), /*数组中元素个数为*/ sizeof(arr) / sizeof(arr[0]) //------重点 14./*数组地址 */ int arr[5] = {1,2,3,4,5} /*数组首整型地址*/ cout&lt;&lt; (int)arr; /*第一个元素整型地址*/ cout&lt;&lt;(int)&amp;arr[0]; //------重点 15.冒泡排序法void fun(int c[], int d) { int temp=0; for (int a = 0; a &lt; d - 1; a++) { for (int b = 0; b &lt; d - 1 - a; b++) { if (c[b] &lt;c[b + 1]) { temp = c[b]; c[b] = c[b + 1]; c[b + 1] = temp; } } } } 未完待续…","categories":[{"name":"c与c++","slug":"c与c","permalink":"http://yoursite.com/categories/c%E4%B8%8Ec/"}],"tags":[]},{"title":"MDK、KEIL的兼容与破解","slug":"MDK、KEIL的兼容与破解","date":"2020-03-02T04:49:16.000Z","updated":"2020-03-29T13:50:29.084Z","comments":true,"path":"2020/03/02/MDK、KEIL的兼容与破解/","link":"","permalink":"http://yoursite.com/2020/03/02/MDK%E3%80%81KEIL%E7%9A%84%E5%85%BC%E5%AE%B9%E4%B8%8E%E7%A0%B4%E8%A7%A3/","excerpt":"很多人可能有和我一样的经历，刚刚学完51单片机就转手来学32开发板，可面临的第一个很尴尬的问题就是KEIL和MDK不能同时兼容存在，自己想学32就要用到MDK,可又放不下刚刚捧热的”情人”keil”","text":"很多人可能有和我一样的经历，刚刚学完51单片机就转手来学32开发板，可面临的第一个很尴尬的问题就是KEIL和MDK不能同时兼容存在，自己想学32就要用到MDK,可又放不下刚刚捧热的”情人”keil” 第一章其实keil和mdk的共存是很简单的，话不多说，下文直接上硬菜(附keil&amp;mdk的安装包)先在d盘创建英文的文件夹(名件名为英文的是为了防止在后续的开发中出现莫名奇妙的警告错误信息)我创建的文件名称为 MDK5 然后打开我们mdk的安装包，按照顺序将程序安装到d盘MDK5的路径下(安装包文末会提供)（以32的f4包来举个栗子） 第二章请务必按如下顺序安装：安装MDK521A安装Keil.STM32F4xx_DFP（安装过程中需要输入的用户名字和Email可随意填写） 然后打开我们keil的安装包，将程序安装到d盘MDK5的路径下(安装包文末会提供)（两个安装包安装路径一定要相同） mdK和KEIL是安装在同一路径下，使用同一个桌面快捷方式，接下来教大家如何分别创建51和32新文件. 第三章双击打开我们的keil,Project -&gt;第一个New uVision Project当我们需要写32代码时，选择下面如图这个选项，然后选择相应的芯片来写代码。 当我们需要写51代码时，选择下面如图这个选项，然后在Atmel中选择stc89c52来写代码 在文章的结尾我为大家分享下keil&amp;mdk的安装包软件keil&amp;mdk安装包链接：https://pan.baidu.com/s/1IPHFC7OMV42ard_GX4LL0w提取码：rrki如果链接失效，请留言进行补充(小白的第一篇博客，不喜勿喷，若有不足之处，还望多多指出,谢谢！) 喜欢就常来看看呗，武汉加油，中国加油噢","categories":[{"name":"单片机","slug":"单片机","permalink":"http://yoursite.com/categories/%E5%8D%95%E7%89%87%E6%9C%BA/"}],"tags":[]}],"categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"},{"name":"opencv视觉","slug":"opencv视觉","permalink":"http://yoursite.com/categories/opencv%E8%A7%86%E8%A7%89/"},{"name":"视觉Slam","slug":"视觉Slam","permalink":"http://yoursite.com/categories/%E8%A7%86%E8%A7%89Slam/"},{"name":"c++","slug":"c","permalink":"http://yoursite.com/categories/c/"},{"name":"STM32","slug":"STM32","permalink":"http://yoursite.com/categories/STM32/"},{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"http://yoursite.com/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"},{"name":"c与c++","slug":"c与c","permalink":"http://yoursite.com/categories/c%E4%B8%8Ec/"},{"name":"单片机","slug":"单片机","permalink":"http://yoursite.com/categories/%E5%8D%95%E7%89%87%E6%9C%BA/"}],"tags":[]}