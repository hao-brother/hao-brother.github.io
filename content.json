{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2020-03-28T12:50:44.000Z","updated":"2020-03-29T03:25:06.161Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"search","date":"2020-03-28T12:55:50.000Z","updated":"2020-03-28T12:56:19.471Z","comments":true,"path":"search/index.html","permalink":"http://yoursite.com/search/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-03-28T12:52:27.000Z","updated":"2020-03-29T03:27:15.002Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"H-bの博客","slug":"H-bの博客","date":"2020-03-29T12:37:08.353Z","updated":"2020-03-29T12:37:08.353Z","comments":true,"path":"2020/03/29/H-bの博客/","link":"","permalink":"http://yoursite.com/2020/03/29/H-b%E3%81%AE%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"蓝桥杯-第四届(自动灌溉系统)","slug":"蓝桥杯-第四届(自动灌溉)","date":"2020-03-09T04:49:16.000Z","updated":"2020-04-02T15:26:33.856Z","comments":true,"path":"2020/03/09/蓝桥杯-第四届(自动灌溉)/","link":"","permalink":"http://yoursite.com/2020/03/09/%E8%93%9D%E6%A1%A5%E6%9D%AF-%E7%AC%AC%E5%9B%9B%E5%B1%8A(%E8%87%AA%E5%8A%A8%E7%81%8C%E6%BA%89)/","excerpt":"","text":"这是我自己在学习蓝桥杯过程中总结的一些知识，希望对今后的学习和备战蓝桥的同学能够提供一些帮助吧。蓝桥杯-第四届(自动灌溉系统)1.试题要求如下 2.题目要点分析 3.注意事项1）使用电位器RB2输出电压模拟湿度输出值2）系统RTC(1302)通过EEPROM保存阈值3）本届的代码不是很难，但它的思维逻辑要求比较大，重要的是区分清楚手动和自动两种工作的模式4.代码实现开始的一些初始化之类的和第三届一样，这里不再分开叨叙(一笔简明带过)，忘记的朋友可以去看第三届解析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354uchar tab[]=&#123;0xc0, // 段选 0- 9 加上 - . 熄灭0xf9,0xa4,0xB0,0x99,0x92,0x82,0xf8,0x80,0x90,0xbf,0x7f,0xff&#125;; // - .uint yi,er,san,si,wu,liu,qi,ba; // 全局变量 控制数码管的段选显示变化void delayms(uint a) // 延时&#123;uint b; for(;a&gt;0;a--) &#123; for(b=845;b&gt;0;b--); &#125;&#125;void all_init() // 初始化 关闭蜂咛器 继电器 数码管等&#123;P2=0XA0;P0=0X00; P2=0X80;P0=0XFF;P2=0XC0;P0=0XFF;P2=0XFF;P0=0XFF; &#125;void display(uint channel,uint num) // 数码管的位选与段选&#123;P2=0XC0;P0=0X01&lt;&lt;channel; P2=0XE0;P0=tab[num]; delayms(2);&#125;void show_SMG() // 数码管显示函数&#123;display(0,yi);display(1,er);display(2,san);display(3,si); display(4,wu);display(5,liu);display(6,qi);display(7,ba);&#125; 官方提供的RTC(1302)代码资料 — 需修改 — 重点123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106/**************************************************/ //以下为官方提供#include &lt;STC15F2K60S2.H&gt;#include &lt;intrins.h&gt;#include \"ds1302.h\"sbit SCK=P1^7; sbit SDA=P2^3; sbit RST = P1^3; // DS1302复位 void Write_Ds1302_Byte(unsigned char temp) &#123; unsigned char i; for (i=0;i&lt;8;i++) &#123; SCK=0; SDA=temp&amp;0x01; temp&gt;&gt;=1; SCK=1; &#125;&#125; void Write_Ds1302( unsigned char address,unsigned char dat ) &#123; RST=0; _nop_(); SCK=0; _nop_(); RST=1; _nop_(); Write_Ds1302_Byte(address); //Write_Ds1302_Byte(dat); 这为原来官方提供的51例程，但应用在15程序中应该如下修改 Write_Ds1302_Byte((dat/10&lt;&lt;4)|(dat%10)); // 这为修改后的 RST=0; &#125;unsigned char Read_Ds1302 ( unsigned char address )&#123; unsigned char i,temp=0x00; uchar dat1,dat2; // 本来没有这两个参数，但为了修改成15，添加的 RST=0; _nop_(); SCK=0; _nop_(); RST=1; _nop_(); Write_Ds1302_Byte(address); for (i=0;i&lt;8;i++) &#123; SCK=0; temp&gt;&gt;=1; if(SDA) temp|=0x80; SCK=1; &#125; RST=0; _nop_(); RST=0; SCK=0; _nop_(); SCK=1; _nop_(); SDA=0; _nop_(); SDA=1; _nop_(); /************************************/ //这段代码原来没有，需要自己添加(源代码无删减) dat1=temp/16; // 进制的转化 在1302中 使用的是压缩BCD码 dat2=temp%16; temp=dat1*10+dat2; /************************************/ return (temp); &#125;/****************************************************/ //以下需要自己编写uchar shijian[]=&#123;0,30,8,0,0,0,0&#125;; // 1302 秒 分 时 日 月 周 年 void DS_Write(void) // 在1302中写入数据&#123;uchar i,add; add=0x80; // 0x80写 0x81读 Write_Ds1302(0x8e,0x00); // 开始(0x00) for(i=0;i&lt;7;i++) &#123; Write_Ds1302(add,shijian[i]); add+=2; // 1302 寄存器定义 读与写 每次加二(可能因为压缩PCB码缘故) &#125; Write_Ds1302(0x8e,0x80); // 关闭(0x80)&#125;void DS_Read(void) // 读取1302的数据&#123;uchar i,add; add=0x81; // 0x81读 Write_Ds1302(0x8e,0x00); // 开始(0x00) for(i=0;i&lt;7;i++) &#123; shijian[i]=Read_Ds1302(add); add+=2; &#125; Write_Ds1302(0x8e,0x80); // 关闭(0x80)&#125; 官方提供的IIC代码资料 — 需修改成EEPROM — 需修改成AD — 重点123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145/***************************************************/ //以下代码官方提供#include \"STC15F2K60S2.H\"#include \"intrins.h\"#include \"iic.h\"#define somenop &#123;_nop_();_nop_();_nop_();_nop_();_nop_();&#125; //这里需要扩大8倍延时 #define SlaveAddrW 0xA0#define SlaveAddrR 0xA1sbit SDA = P2^1; /* 数据线 */sbit SCL = P2^0; /* 时钟线 */void IIC_Start(void) // 总线启动&#123; SDA = 1; SCL = 1; somenop; SDA = 0; somenop; SCL = 0; &#125;void IIC_Stop(void) // 总线停止&#123; SDA = 0; SCL = 1; somenop; SDA = 1;&#125;bit IIC_WaitAck(void) // 等待应答&#123; SDA = 1; somenop; SCL = 1; somenop; if(SDA) &#123; SCL = 0; IIC_Stop(); return 0; &#125; else &#123; SCL = 0; return 1; &#125;&#125;void IIC_SendByte(unsigned char byt) // 发送数据&#123; unsigned char i; for(i=0;i&lt;8;i++) &#123; if(byt&amp;0x80) &#123; SDA = 1; &#125; else &#123; SDA = 0; &#125; somenop; SCL = 1; byt &lt;&lt;= 1; somenop; SCL = 0; &#125;&#125;unsigned char IIC_RecByte(void) // 接收数据&#123; unsigned char da; unsigned char i; for(i=0;i&lt;8;i++) &#123; SCL = 1; somenop; da &lt;&lt;= 1; if(SDA) da |= 0x01; SCL = 0; somenop; &#125; return da;&#125;/*********************************************************/ //以下代码需要自己写uchar AD_read(uchar add) // 与读取IIC代码一样&#123; uchar temp; IIC_Start(); IIC_SendByte(0x90); IIC_WaitAck(); IIC_SendByte(add); IIC_WaitAck(); IIC_Stop(); IIC_Start(); IIC_SendByte(0x91); IIC_WaitAck(); temp=IIC_RecByte(); IIC_Stop(); return temp;&#125;/***********************/ //EEPROMuchar EEPROM_read(uchar add)&#123;uchar temp; IIC_Start(); IIC_SendByte(0xa0); IIC_WaitAck(); IIC_SendByte(add); IIC_WaitAck(); IIC_Stop(); IIC_Start(); IIC_SendByte(0xa1); IIC_WaitAck(); temp=IIC_RecByte(); IIC_Stop(); return temp;&#125;void EEPROM_write(uchar add,uchar dat) // 写数据 哪个地址 写入什么数据&#123; IIC_Start(); IIC_SendByte(0xa0); IIC_WaitAck(); IIC_SendByte(add); IIC_WaitAck(); IIC_SendByte(dat); // 写入数据 IIC_WaitAck(); IIC_Stop();&#125; 按键功能操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192uchar s7_spot=0; // s7标志位uchar s6_spot=0; // s6标志位uchar jia_spot=0; // 加的标志位uchar jian_spot=0; // 减的标志位uchar fazhi; // 阈值(存入EEPROM)uchar kai=1; // 蜂咛器uchar jidianqi=0; // 继电器 模拟灌溉设备的打开与关闭void keyscan()&#123; /***************************///s7if(P30==0) &#123; delayms(2); if(P30==0) &#123; if(s7_spot==0) // s7_spot = 0 自动状态 &#123; s7_spot=1; P0=0XFF; P2=0X80; // led2 亮 P01=0; &#125; else if(s7_spot==1) // s7_spot = 1 手动状态 &#123; s7_spot=0; P0=0XFF; P2=0X80; // led1 亮 P00=0; &#125; &#125;while(!P30); &#125; /******************************///s6 if(P31==0) &#123; delayms(2); if(P31==0) &#123; if(s7_spot==0) // 说明是在自动状态下 &#123; if(s6_spot==0) &#123; s6_spot=1; &#125; else if(s6_spot==1) &#123; s6_spot=0; &#125; &#125; else if(s7_spot==1) // 说明在手动状态下 &#123; kai = ~kai; // 蜂咛器开和关的标志位 &#125; &#125;while(!P31); &#125; /*******************************///s5 +1 if(P32==0) &#123; delayms(2); if(P32==0) &#123; if(s7_spot==0) // 在自动状态下 &#123; jia_spot=1; // 加 标志位 &#125; else if(s7_spot==1) // 在手动状态下 &#123; jidianqi=1; // 灌溉设备打开 &#125; &#125;while(!P32); &#125; /*****************************///s4 -1 if(P33==0) &#123; delayms(2); if(P33==0) &#123; if(s7_spot==0) // 在自动状态下 &#123; jian_spot=1; // 减 标志位 &#125; else if(s7_spot==1) // 在手动状态下 &#123; jidianqi=0; // 灌溉设备关闭 &#125; &#125;while(!P33); &#125; &#125; 主函数中对标志位进行判断123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143extern uchar shijian[]; // 对1302的储存数组进行声明void main()&#123; uchar shidu=0; yi=0;er=8;san=10;si=3;wu=0;liu=12;qi=5;ba=0; all_init(); P2=0X80; // L1亮 自动工作模式 P00=0; DS_Write(); // ds1302写while(1) &#123; DS_Read(); // ds1302读 shidu=AD_read(0x03); // 从AD里面读取电压模拟湿度 shidu=shidu*0.39; // 225转换为0~5伏 if(s7_spot==0) // s7没有被按下 为自动状态 L1&#123; // EEPROM_write(0x10,50); // 已经初始值为50 不在打开 将其地址赋予0x10 下次上电直接从EEPROM读取 不再赋予初值// delayms(5); // 延时等待应答 fazhi=EEPROM_read(0x10); // 读取阈值 if(shidu&lt;fazhi) // 当前读取的湿度与阈值进行比较 小于则自动打开灌溉设备(通过继电器模拟) &#123; P2=0XA0; P0=0X10; &#125; else &#123; P2=0XA0; P0=0X00; &#125; if(s6_spot==1) // s6按下 需要对阈值进行调整 &#123; if(jia_spot==1) // 在s6按下后，s5被按下，加标志位为1 阈值加1 &#123; jia_spot=0; fazhi=fazhi+1; &#125; if(jian_spot==1) // 在s6按下后，s4被按下，减标志位为1 阈值减1 &#123; jian_spot=0; fazhi=fazhi-1; &#125; EEPROM_write(0x10,fazhi); // 将改变的值写入EEPROM中 yi=er=10; // 在进行阈值调整时，显示独特的显示页面 san=si=wu=liu=12; qi=fazhi/10; ba=fazhi%10; &#125; else if(s6_spot==0) // s6没有按下 显示1302里面存储的数 &#123; yi=shijian[2]/10; er=shijian[2]%10; san=10; si=shijian[1]/10; wu=shijian[1]%10; liu=12; qi=shidu/10; // 显示湿度 ba=shidu%10; &#125; &#125; /**************************************************************/ //以下两种按键实际就是 在手动工作模式下 当湿度小于阈值时，蜂咛器报警，s6可以将蜂咛器关闭，再次按下s6,可以开启对蜂咛器的控制。而在手动工作模式下，蜂咛器的工作(叫或者不叫)不会被s5、s4按键的按下所干扰，s5、s4按下只控制灌溉系统(继电器)的工作 else if(s7_spot==1) // s7被按下 为手动状态 L2 &#123; if((shidu&lt;fazhi)&amp;&amp;(kai==0)) // 在手动状态下，s6被按下，蜂咛器标志位kai取反为0 &#123; if(jidianqi==1) // 手动状态下 s5按下 只有继电器亮(暗示蜂咛器被关闭) &#123; P2=0XA0; P0=0X10; &#125; else if(jidianqi==0) // 手动状态下 s4按下 继电器灭 &#123; P2=0XA0; P0=0X00; &#125; &#125; else if((shidu&lt;fazhi)&amp;&amp;(kai==1)) // 在手动状态下，s6没有被按下(s6被按下后又被按下)，蜂咛器标志位为1 &#123; if(jidianqi==1) // 在手动情况下，蜂咛器报警，开启灌溉 &#123; // s5按下 继电器亮 蜂咛器叫 P2=0XA0; P0=0X50; &#125; else if(jidianqi==0) &#123; // s4按下 继电器灭 蜂咛器叫 P2=0XA0; P0=0X40; &#125; &#125; /**************************************************************/ else if(shidu&gt;fazhi) &#123; if(jidianqi==1) // 手动状态下 s5按下 继电器亮 &#123; P2=0XA0; P0=0X10; &#125; else if(jidianqi==0) // 手动状态下 s4按下 继电器灭 &#123; P2=0XA0; P0=0X00; &#125; &#125; yi=shijian[2]/10; er=shijian[2]%10; san=10; si=shijian[1]/10; wu=shijian[1]%10; liu=12; qi=shidu/10; ba=shidu%10; &#125; // else if(s7_spot==1) 的括号 keyscan(); // 按键扫描函数 show_SMG(); // 对全局变量 yi~ba 返回的值进行数码管显示 &#125; // while的括号&#125; // main的括号 版权所有，未经允许，不得转载 !","categories":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"http://yoursite.com/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}],"tags":[]},{"title":"蓝桥杯-第三届(自动售水机)","slug":"蓝桥杯-第三届(自动售水机)","date":"2020-03-08T04:49:16.000Z","updated":"2020-04-01T04:23:32.682Z","comments":true,"path":"2020/03/08/蓝桥杯-第三届(自动售水机)/","link":"","permalink":"http://yoursite.com/2020/03/08/%E8%93%9D%E6%A1%A5%E6%9D%AF-%E7%AC%AC%E4%B8%89%E5%B1%8A(%E8%87%AA%E5%8A%A8%E5%94%AE%E6%B0%B4%E6%9C%BA)/","excerpt":"","text":"这是我自己在学习蓝桥杯过程中总结的一些知识，希望对今后的学习和备战蓝桥的同学能够提供一些帮助吧。蓝桥杯-第三届(自动售水机)1.试题要求如下 2.题目要点分析1) 上电后各部分要初始化(关闭蜂咛器、数码管、led灯、继电器)，并且数码管要显示题目要求初始的数(含格式)2）按下 S7 清屏开始计数(计数器中断)流水显示，S6停止流水计数并且计算显示出流水价格3) 通过光敏电阻读取环境的亮度，当其发生改变时，做出不同的响应4）掌握IIC3.注意事项1）数码管小数的显示，需要重新计算数码管段选数组 tab_spot[] ，都加上h，使其显示出小数点2）S7按键不会改变流水的状态，唯有S6可以改变, S7作用只有一个，就是清屏开始流水计数3）通过流水量计算出价格这方法要注意4）光敏电阻读取数据与显示的转换要注意（ IIC 写0x90, 读0x91)5) 引用头文件并且定义无符号类型12345#include \"STC15f2k60S2.h\"#include \"intrins.h\" // 引用头文件 调用iic里面的延时函数 _nop_()#define uchar unsigned char#define uint unsigned int 4.代码实现首先是进行初始化1234567891011121314void allinit() // 初始化&#123; P2=0XA0; P0=0X00; P2=0X80; P0=0XFF; P2=0XC0; P0=0XFF; P2=0XFF; P0=0XFF;&#125; 延时函数12345678910void delayms(uchar a)&#123; uint b; for(;a&gt;0;a--) &#123; for(b=845;b&gt;0;b--) &#123; &#125; &#125;&#125; 数码管显示(双重—-正常不加小数点和加小数点)12345678910111213141516171819202122232425262728uchar tab[]=&#123;0xc0,0xf9,0xa4,0xB0,0x99,0x92,0x82,0xf8,0x80,0x90,0xff&#125;; // 不加小数点uchar tab_spot[]=&#123;0x40,0x79,0x24,0x30,0x19,0x12,0x02,0x78,0x00,0x10,0xff&#125;; // 加上小数点的void display(uchar channel,uchar num) // 不加小数点段选的数码管显示&#123; P2=0XC0; P0=0X01&lt;&lt;channel; P2=0XE0; P0=tab[num]; delayms(2);&#125;void display_spot(uchar channel,uchar num) // 加小数点段选的数码管显示&#123; P2=0XC0; P0=0X01&lt;&lt;channel; P2=0XE0; P0=tab_spot[num]; delayms(2);&#125; 题目要求的数码管显示格式1234567891011121314uchar yi,er,san,si,wu,liu,qi,ba; // 全局变量void display_SMG()&#123; display(0,yi); display_spot(1,er); display(2,san); display(3,si); display(4,wu); display_spot(5,liu); display(6,qi); display(7,ba);&#125; 中断1234567891011121314151617181920212223242526272829303132333435363738void Timer0Init(void) // 5毫秒 来源stc定时器计算器 波特率11.0592 定时器0 16位自动重载&#123; AUXR |= 0x80; TMOD &amp;= 0xF0; TL0 = 0x00; TH0 = 0x28; TF0 = 0; TR0 = 1; &#125;uint aa=0; // 三个全局变量 进行时间、金钱计算uint bb=0;uint money=0;void time0 () interrupt 1 // 定时器中断服务函数 1&#123; aa++; if(aa==20) // 100毫秒 &#123; bb++; // 100毫秒=10毫升 (相当于数码管最后一位) aa=0; ba=bb%10; qi=bb%100/10; liu=bb%1000/100; wu=bb/1000; &#125; if(bb==9999) &#123; bb=0; money=bb*0.5; // 进行金钱转化 ba=money%10; qi=money%100/10; liu=money%1000/100; wu=money/1000; &#125; &#125; 按键操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253void start() // S7按下 开启&#123; wu=liu=qi=ba=0; // 使得开始按按键时 数码管后四位清零 P2=0XA0; // 开启继电器 P0=0X10; ET0=1; // 开启定时器 EA=1;&#125;void off() // S6按下 关闭&#123; P2=0XA0; // 关闭继电器 P0=0X00; EA=0; // 关闭定时器 ET0=0; money=bb*0.5; // 关闭时自动显示价钱 ba=money%10; qi=money%100/10; liu=money%1000/100; wu=money/1000; bb=0; // 确保下次开始计数时 从0开始&#125;void keyscan()&#123;if(P30==0) &#123; delayms(2); if(P30==0) &#123; start(); &#125; while(!P30); &#125; if(P31==0) &#123; delayms(2); if(P31==0) &#123; off(); &#125; while(!P31); &#125;&#125; 实现光敏电阻的各项功能 (要利用给的IIC文件夹，稍加修改即可)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124/*********************************************/ // 以下函数在官方数据手册提供/*********************************************/ // _nop_() 需要引入头文件 \"intrins.h\"#define somenop &#123;_nop_();_nop_();_nop_();_nop_();_nop_();&#125; // 这为官方给的51#define somenop &#123;_nop_();_nop_();_nop_();_nop_();_nop_(); // 15的延时大概为51的8倍_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_(); &#125; #define SlaveAddrW 0xA0 // 写#define SlaveAddrR 0xA1 // 读sbit SDA = P2^1; /* 数据线 */sbit SCL = P2^0; /* 时钟线 */void IIC_Start(void) // 启动条件&#123; SDA = 1; SCL = 1; somenop; SDA = 0; somenop; SCL = 0; &#125;void IIC_Stop(void) // 停止条件&#123; SDA = 0; SCL = 1; somenop; SDA = 1;&#125;bit IIC_WaitAck(void) // 等待应答&#123; SDA = 1; somenop; SCL = 1; somenop; if(SDA) &#123; SCL = 0; IIC_Stop(); return 0; &#125; else &#123; SCL = 0; return 1; &#125;&#125;void IIC_SendByte(unsigned char byt) // 通过iic发送数据&#123; unsigned char i; for(i=0;i&lt;8;i++) &#123; if(byt&amp;0x80) &#123; SDA = 1; &#125; else &#123; SDA = 0; &#125; somenop; SCL = 1; byt &lt;&lt;= 1; somenop; SCL = 0; &#125;&#125;unsigned char IIC_RecByte(void) // 接收iic数据&#123; unsigned char da; unsigned char i; for(i=0;i&lt;8;i++) &#123; SCL = 1; somenop; da &lt;&lt;= 1; if(SDA) da |= 0x01; SCL = 0; somenop; &#125; return da;&#125;/***********************************/ //以下的函数需要自己根据官方提供的函数来编写uchar iic_read(uchar add)&#123; uchar temp; /******************/ IIC_Start(); IIC_SendByte(0x90); IIC_WaitAck(); IIC_SendByte(add); IIC_WaitAck(); IIC_Stop(); /*****************/ IIC_Start(0x91); IIC_SendByte(0x91); IIC_WaitAck(); temp=IIC_RecByte(); IIC_WaitAck(); IIC_Stop(); /****************/ return temp;&#125; 主函数1234567891011121314151617181920212223242526void main()&#123; uchar guangmin; // 记录数码管的值 all_init(); // 初始化，关闭蜂咛器，继电器之类 Timer0Init(); // 中断初始化 yi=10,er=0,san=5,si=0,wu=0,liu=1,qi=0,ba=0; // 开始数码管的显示 while(1) &#123; display_SMG(); // 初始化数码管 keyscan(); // 读取按键反馈回来的全局变量 yi ~ ba 的值，并且控制其他模块 guangmin=iic_read(0x01); // !!! iic读取光敏电阻的值并进行转换 if(guangmin&lt;64) // !!! &#123; P0=0XFF; // 避免其小灯的干扰 P2=0X80; P00=0; // 点亮 &#125; else &#123; P2=0X80; P0=0XFF; &#125; &#125;&#125; 5.完整的代码参考(仅供学习)链接：https://pan.baidu.com/s/138PEwdj5GlsxOEjPLrFB4Q提取码：6kt5 注: 本文为原创，未经允许，禁止转载！","categories":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"http://yoursite.com/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}],"tags":[]},{"title":"蓝桥杯基础","slug":"蓝桥杯基础","date":"2020-03-07T04:49:16.000Z","updated":"2020-03-31T02:34:17.269Z","comments":true,"path":"2020/03/07/蓝桥杯基础/","link":"","permalink":"http://yoursite.com/2020/03/07/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%9F%BA%E7%A1%80/","excerpt":"","text":"这是我自己在学习蓝桥杯过程中总结的一些知识，希望对今后的学习和备战蓝桥的同学能够提供一些帮助吧。必须要知道的知识1.1234567891011 void delayms(uint ms) // 15芯片延时一毫秒软件实现&#123; uint a; for(;ms&gt;0;ms--) &#123; for(a=845;a&gt;0;a--); &#125;&#125; 2.1234567891011121314void allinit(void) // 初始化关闭其他模块(led、继电器、蜂咛器、数码管)&#123; P2=0XA0; // 继电器，蜂咛器 P0=0X00; P2=0X80; // 小灯 P0=0XFF; P2=0XC0; // 段选 1~8 P0=0XFF; P2=0XFF; P0=0XFF;&#125; 3.123456789101112131415161718192021222324252627282930313233343536373839404142void keyscan(void ) // 独立按键 从上至下 S7 - S4 (P30 - P33)&#123;if(P30==0) &#123; delayms(5); if(P30==0) &#123; &#125; while(!P30); // 消抖操作 &#125;if(P31==0) &#123; delayms(5); if(P31==0) &#123; &#125; while(!P31); &#125; if(P32==0) &#123; delayms(5); if(P32==0) &#123; &#125; while(!P32); &#125; if(P33==0) &#123; delayms(5); if(P33==0) &#123; &#125; while(!P33); &#125;&#125; 4.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147void display16() // 矩阵按键(需要改变按键跳线帽) P37 = P44 P36 = P42 &#123;/**************************/ // 第1横行读取 P30=0; P31=P32=P33=1; // 从上至下(行) S7 - S4 (P30 - P33) P44=P42=P35=P34=1; // 从左至右(列) P44(P37) P42(P36) P35 P34 if(P44==0) &#123; delayms(5); if(P44==0) &#123; while(!P44); // 消抖 &#125; &#125; else if(P42==0) &#123; delayms(5); if(P42==0) &#123; while(!P42); &#125; &#125; else if(P35==0) &#123; delayms(5); if(P35==0) &#123; while(!P35); &#125; &#125; else if(P34==0) &#123; delayms(5); if(P34==0) &#123; while(!P34); &#125; &#125; /**************************/ // 第2横行读取 P31=0; P30=P32=P33=1; P44=P42=P35=P34=1; if(P44==0) &#123; delayms(5); if(P44==0) &#123; while(!P44); &#125; &#125; else if(P42==0) &#123; delayms(5); if(P42==0) &#123; while(!P42); &#125; &#125; else if(P35==0) &#123; delayms(5); if(P35==0) &#123; while(!P35); &#125; &#125; else if(P34==0) &#123; delayms(5); if(P34==0) &#123; while(!P34); &#125; &#125; /**************************/ // 第3横行读取 P32=0; P30=P31=P33=1; P44=P42=P35=P34=1; if(P44==0) &#123; delayms(5); if(P44==0) &#123; while(!P44); &#125; &#125; else if(P42==0) &#123; delayms(5); if(P42==0) &#123; while(!P42); &#125; &#125; else if(P35==0) &#123; delayms(5); if(P35==0) &#123; while(!P35); &#125; &#125; else if(P34==0) &#123; delayms(5); if(P34==0) &#123; while(!P34); &#125; &#125; /**************************/ // 第4横行读取 P33=0; P30=P31=P32=1; P44=P42=P35=P34=1; if(P44==0) &#123; delayms(5); if(P44==0) &#123; while(!P44); &#125; &#125; else if(P42==0) &#123; delayms(5); if(P42==0) &#123; while(!P42); &#125; &#125; else if(P35==0) &#123; delayms(5); if(P35==0) &#123; while(!P35); &#125; &#125; else if(P34==0) &#123; delayms(5); if(P34==0) &#123; while(!P34); &#125; &#125;&#125; 5.12345678910111213141516uchar tab[]=&#123;0xc0, 0xf9,0xa4,0xB0,0x99,0x92,0x82,0xf8,0x80,0x90, 0xbf,0x7f,0xff&#125;; // - . void display(uchar channel,uchar number) // 位选 段选 &#123; P2=0XC0; // 段选 P0=0X01&lt;&lt;channel; P2=0XFF; // 段选 P0=tab[number]; delayms(1);&#125;display(7,1); // 使得数码管 从左数第七个 显示1 后续将继续补充与完善…","categories":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"http://yoursite.com/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}],"tags":[]},{"title":"c与c++知识点(四)","slug":"C与C++笔记4","date":"2020-03-06T04:49:16.000Z","updated":"2020-03-30T12:35:40.403Z","comments":true,"path":"2020/03/06/C与C++笔记4/","link":"","permalink":"http://yoursite.com/2020/03/06/C%E4%B8%8EC++%E7%AC%94%E8%AE%B04/","excerpt":"","text":"这是我自己在学习c++基础的过程中，顺便复习了下C语言，然后总结的一些小小知识点。—写在前面的话第四节1.c++面向对象特性 封装 继承 多态 万事万物都皆为对象2.1234567891011c++ class aa&#123;//访问权限//属性（变量）//行为（函数）&#125; 3.属性和行为 都称之为 成员 成员属性 = 属性4.12345public // 公共权限 成员 类内可以访问 类外可以访问Protected // 保护权限 成员 类内可以访问 类外不可以访问（儿子可以访问父亲的保护内容）Private // 私有权限 成员 类内可以访问 类外不可以访问（儿子不可以访问父亲私有权限） 5.12345struct class // 区别在于 默认访问权限不同 struct // 默认为公共 public class // 默认为私有 private 未完待续…","categories":[{"name":"c与c++","slug":"c与c","permalink":"http://yoursite.com/categories/c%E4%B8%8Ec/"}],"tags":[]},{"title":"c与c++知识点(三)","slug":"C与C++笔记3","date":"2020-03-05T04:49:16.000Z","updated":"2020-03-31T02:30:06.917Z","comments":true,"path":"2020/03/05/C与C++笔记3/","link":"","permalink":"http://yoursite.com/2020/03/05/C%E4%B8%8EC++%E7%AC%94%E8%AE%B03/","excerpt":"","text":"这是我自己在学习c++基础的过程中，顺便复习了下C语言，然后总结的一些小小知识点。—写在前面的话第三节1.C++内存分为四个区123456789// 代码区 存放函数体的二进制代码// 全局区 存放全局变量和静态变量以及常量// 栈区 编译器自动分配 存放函数参数值 局部变量// 堆区 程序员分配和释放，程序员不释放，程序结束时操作系统回收// 意义： 不同区域存放的数据，赋予不同的生命中秋，给予更大的灵活编程 1234567891011// 代码区 （程序运行前就有）存放二进制机器指令 特点 : 共享、只读// 全局区 （程序运行前就有）存放全局变量和静态变量以及常量 该区的数据在程序结束后，由操作系统释放 // 在全局区（静态变量 static关键字 常量（字符串常量和const 修饰的全局变量）） 不在全局区的数据（局部常量）// 栈区 （程序运行后才有）不要返回局部变量的地址 // 堆区 （程序运行后才有）（程序员手动开辟和释放（delete））利用new关键字，将数据开辟到堆区返回的直接是地址 int * p = new int (10) ; // 指针本质在栈区，其数据在堆区 2.12new // 返回的是该数据类型的指针 int * p=new int(10) ; // 创建了一个new型为10的变量地址 (释放 delete p;) 3.12 int * array = nem int[10]; // 创建了一个变量为整型个数为10的数组，他的首地址给了array (释放数组 delete[] arr;) 4.1234567// 引用：就是给变量起别名 // 语法：数据类型 &amp;别名=原名 对别名进行操作等于对原名的数据进行操作 int a=10; int &amp; b = a; b = 20; // 那么 a也为20 5.1234567// 引用的注意事项 // 1) 引用的时候必须要给予初始化 int &amp; b = a; (引用过程给予初始化，只有这一种写法) // 2) 引用一旦初始化后，不可更改 6.123456789101112131415161718192021// 引用也会使得形参修饰实参 void my3(int &amp;a,int &amp;b) // 有两种解决办法 指针 和 引用 // 注意事项:// 1 )不要返回局部变量的引用 int &amp;test() &#123; int a=10;return a; &#125; // 2 )函数的调用可以作为左值 int &amp;ref=test(); test()=100; cout &lt;&lt; ref &lt;&lt; endl; ref = 100; 7.123456789//引用的本质是一个指针常量 int a=10; int &amp;b = a; // 相当于 int * const b = &amp;a; 这也就是为什么引用不可修改，因为指针常量的指针指 向不可修改(b中保存着a的地址) cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl; a = b = 10;// b = 20解引用 也就是*b = 20; 8.12345678910111213141516// 常量引用 // 引用的两种写法// 1 ) int a=10； int &amp; b = a // (必须为名称，不能为10)；// 2) const int &amp; b = 10; // 第二种相当于编译器系统设置了一个变量 int temp = 10； const int &amp;b = temp； b = 20 // (这是错误的，因为加上const 之后变为只读不可修改状态) 9.1234567891011121314// 函数默认参数 优先用户自定义的 int fun(int a,int b=10,int c=30)&#123; return a+b+c;&#125;main&#123; cout &lt;&lt; fun (10 , 30 , 30 ) ; &#125; // 70; // 当某个位置有了默认参数，那么他后边都必须是默认参数(例如 b为默认参数，那么 c 也必须是默认参数) 10.12345678910// 声明和实现 只能有一个有默认参数 int fun (int a = 10,int b = 30); int fun(int a , int b) &#123; return a + b; &#125; // 40 11.1234567891011121314// 占位参数（只有函数类型，没有名字） void fun ( int a , int) &#123; cout &lt;&lt; ” abc ” ; &#125; // 引用时fun(10 , 10) 占位参数还可以有默认参数void fun(int a , int = 10) &#123; return “ abc ” ; &#125; // 引用时 fun( 10 ) 12.12345678// 函数重载(函数名可以相同) // 条件 : 同一个作用域下 函数名称相同 函数的参数类型不同 或者 个数不同或者顺序不同 // 注意：函数的返回值不可以作为函数重载的条件,如下 void fun ( ) void fun(int a) void fun(double b) 未完待续…","categories":[{"name":"c与c++","slug":"c与c","permalink":"http://yoursite.com/categories/c%E4%B8%8Ec/"}],"tags":[]},{"title":"c与c++知识点(二)","slug":"C与C++笔记2","date":"2020-03-04T04:49:16.000Z","updated":"2020-03-30T12:34:23.425Z","comments":true,"path":"2020/03/04/C与C++笔记2/","link":"","permalink":"http://yoursite.com/2020/03/04/C%E4%B8%8EC++%E7%AC%94%E8%AE%B02/","excerpt":"","text":"这是我自己在学习c++基础的过程中，顺便复习了下C语言，然后总结的一些小小知识点。—写在前面的话第二节1.1234/*二维数组 总元素*/ sizeof ( arr ) ;/* 第一行元素 */ sizeof ( arr [0] ) ;/* 行数 */ sizeof ( arr ) / sizeof ( arr [0] ) /* 列数 */ sizeof ( arr [0]) / sizeof( arr [0] [0] ) ) 2.1234/* 二维数组首地址 */ cout &lt;&lt; arr &lt;&lt; endl; /* 第一行首地址 */ cout &lt;&lt; arr [0] &lt;&lt; endl; /*第一个元素首地址 */ cout &lt;&lt; &amp; arr [0] [0] &lt;&lt; endl; // 此三者相等三者相等 /* 第二行首地址 */ cout &lt;&lt; arr[1] &lt;&lt; endl; 3.1/*指针就是地址*/ int *p; （p为指针变量） //使用时需要解引用 *p 即可 ( *p解引用） 4.12/*空指针: 用来给指针变量进行初始化，空指针不可以进行访问的*/ int *p = NULL; //不可再将地址赋值给 p 输出 5.1234567const修饰指针 ---重点1）const修饰指针---常量指针 2）const修饰常量---指针常量 3）const既修饰指针又修饰常量 6.—重点—12345678910//1）常量指针 const int * p = &amp;a; /*指针的指向可以修改，但是指针指向 的值不可修改 *///2）指针常量 int * const p = &amp;a; /*指针的指向不可以修改，指针的值可以修改 *///3）既修饰指针又修饰常量 const int * const p = &amp;a; /*指针的指向和指针的值都不可以修改 *///（如何记忆: const—常量 ，* p —指针 如何用：紧接着 const 的是p / * 紧跟着谁 谁不能操作） 7.12int arr [10], int * p; p = arr ; cout &lt;&lt; *p;//（数组的名称为其的首地址) 8.值传递，不能修改实参的值，只能修改形参的值。地址传递可以修改实参的值。9.结构体123456789101112131415struct student/**** 自己创建的结构体类型为 student, 此类型的变量名字为s1, s2 ***/ &#123; string name; int age; int score; &#125;;//1 struct student s1;//2 struct student s2 = &#123; &#125;;//3 创建结构体时顺便创建结构体变量,通过.来访问结构体中的属性 10.结构体创建自定义类型过程中struct不能省略，但是创建变量的过程c++ struct可以 省略11.12345678910111213// 结构体数组 struct 结构体名字 数组名字&#123;个数&#125;=&#123; &#123; &#125;，&#123; &#125; ，&#123; &#125; &#125;// 结构体指针 利用-&gt;可以通过结构体来访问结构体的属性student s1 = &#123; \"李斯\",56,99 &#125;;student * p = &amp;s1;cout &lt;&lt; \"姓名:\" &lt;&lt; p-&gt;name &lt;&lt; \"年龄:\" &lt;&lt; p-&gt;age &lt;&lt; \"分数\" &lt;&lt; p-&gt;score; 12.结构体嵌套结构体12345678910111213141516171819202122232425262728293031323334353637383940414243 struct student &#123; string name; int scroe; &#125;; struct teacher&#123; int id; string name; int age; struct student s1;//学生 s1&#125;; teacher t; t.id = 10086; t.name = \"老王\"; t.age = 58; t.s1. name = \"小王\"; t.s1.scroe = 99; teacher * p = &amp;t; cout &lt;&lt; \"老师姓名：\" &lt;&lt; p-&gt;name &lt;&lt; \"老师工号: \" &lt;&lt; p-&gt;id &lt;&lt; \"老师年龄: \" &lt;&lt; p-&gt;age &lt;&lt; \"老师的学生名字: \" &lt;&lt; p-&gt;s1.name &lt;&lt; \"老师的学生分数: \" &lt;&lt; p-&gt;s1.scroe; 13. 结构体中使用const来防止误操作14.—重点—main里面调用函数，形参相当于把参数复制了一遍，增大了储存空间和代码量。将函数的形参变为指针，可以大大减少内存的占用（指针不会复制数据，其只是进行地址传递）15.123system( “ pause ” ); //请按任意键继续 system( “ cls ” ); //清屏操作 未完待续…","categories":[{"name":"c与c++","slug":"c与c","permalink":"http://yoursite.com/categories/c%E4%B8%8Ec/"}],"tags":[]},{"title":"c与c++知识点(一)","slug":"C与C++笔记1","date":"2020-03-03T04:49:16.000Z","updated":"2020-03-30T12:32:58.451Z","comments":true,"path":"2020/03/03/C与C++笔记1/","link":"","permalink":"http://yoursite.com/2020/03/03/C%E4%B8%8EC++%E7%AC%94%E8%AE%B01/","excerpt":"","text":"这是我自己在学习c++基础的过程中，顺便复习了下C语言，然后总结的一些小小知识点。—写在前面的话第一节1.1int a; sizeof(int) = sizeof(a); ---求所储存的字节 2.1float aa = 'A' cout &lt;&lt; (int)aa &lt;&lt; endl; //输出A的数值(强制转化为 int) 注意格式 3.1float f2 = 3e2 //3*10^2 float f3 = 3e-2 //3*0.1^2 4.bool 真或假 bool flag = false/true(0/1); —除了0为假，其余都为真5.字符串&nbsp;&nbsp;(1)1char str[ ] = \"hello world\" cout&lt;&lt;str&lt;&lt;endl; &nbsp;&nbsp;(2) string 变量名 =”字符串值” （引用头文件include“string” 有的是在iostream头文件中）1string name[3] = &#123;\"张三\",\"李四\",\"王麻子\"&#125;; string name=”胖虎”； 6.12int a1 = 10; ++a1*10; //(运算结果为110)先加1后乘以10，int a1 =10; a1++*10; //(运算结果为101)先乘以10 后加1，先执行表达式，再增加 7.12-= /= %= int a=10; int b=5; cout&lt;&lt;(a==b); //输出结果为0(假) 8.1234rand() % 80; //生成0-79的随机数 rand() % 80+1; // 生成0-80随机数 /* 需要包含头文件 #include “cstdlib” */// #include ”ctime“ (伪函数) srand((unsigned int)time(NULL)); 利用系统时钟生成伪数字 9.1int a = 10; int b = 20; (a&lt;b?a:b)=100; cout &lt;&lt;a; a=100 cout&lt;&lt;b; //b=2 10.1int a = 354; //个位 a%10 十位 a%100/10 百位 a/100 11.1\\t 制表符代替空格 12.1goto flag ； flag： //跳转语句 ---读懂就可，不建议使用 13.1234/*数组*/ int arr[5] = &#123;1,2,3,4,5&#125; /*每个数组占用的内存空间*/ sizeof(arr)/*每个素占用的内存空间 */ sizeof(arr[0]),/*数组中元素个数为*/ sizeof(arr) / sizeof(arr[0]) //------重点 14.123/*数组地址 */ int arr[5] = &#123;1,2,3,4,5&#125; /*数组首整型地址*/ cout&lt;&lt; (int)arr; /*第一个元素整型地址*/ cout&lt;&lt;(int)&amp;arr[0]; //------重点 15.冒泡排序法12345678910111213141516void fun(int c[], int d)&#123; int temp=0; for (int a = 0; a &lt; d - 1; a++) &#123; for (int b = 0; b &lt; d - 1 - a; b++) &#123; if (c[b] &lt;c[b + 1]) &#123; temp = c[b]; c[b] = c[b + 1]; c[b + 1] = temp; &#125; &#125; &#125;&#125; 未完待续…","categories":[{"name":"c与c++","slug":"c与c","permalink":"http://yoursite.com/categories/c%E4%B8%8Ec/"}],"tags":[]},{"title":"MDK、KEIL的兼容与破解","slug":"MDK、KEIL的兼容与破解","date":"2020-03-02T04:49:16.000Z","updated":"2020-03-29T13:50:29.084Z","comments":true,"path":"2020/03/02/MDK、KEIL的兼容与破解/","link":"","permalink":"http://yoursite.com/2020/03/02/MDK%E3%80%81KEIL%E7%9A%84%E5%85%BC%E5%AE%B9%E4%B8%8E%E7%A0%B4%E8%A7%A3/","excerpt":"很多人可能有和我一样的经历，刚刚学完51单片机就转手来学32开发板，可面临的第一个很尴尬的问题就是KEIL和MDK不能同时兼容存在，自己想学32就要用到MDK,可又放不下刚刚捧热的”情人”keil”","text":"很多人可能有和我一样的经历，刚刚学完51单片机就转手来学32开发板，可面临的第一个很尴尬的问题就是KEIL和MDK不能同时兼容存在，自己想学32就要用到MDK,可又放不下刚刚捧热的”情人”keil” 第一章其实keil和mdk的共存是很简单的，话不多说，下文直接上硬菜(附keil&amp;mdk的安装包)先在d盘创建英文的文件夹(名件名为英文的是为了防止在后续的开发中出现莫名奇妙的警告错误信息)我创建的文件名称为 MDK5 然后打开我们mdk的安装包，按照顺序将程序安装到d盘MDK5的路径下(安装包文末会提供)（以32的f4包来举个栗子） 第二章请务必按如下顺序安装：安装MDK521A安装Keil.STM32F4xx_DFP（安装过程中需要输入的用户名字和Email可随意填写） 然后打开我们keil的安装包，将程序安装到d盘MDK5的路径下(安装包文末会提供)（两个安装包安装路径一定要相同） mdK和KEIL是安装在同一路径下，使用同一个桌面快捷方式，接下来教大家如何分别创建51和32新文件. 第三章双击打开我们的keil,Project -&gt;第一个New uVision Project当我们需要写32代码时，选择下面如图这个选项，然后选择相应的芯片来写代码。 当我们需要写51代码时，选择下面如图这个选项，然后在Atmel中选择stc89c52来写代码 在文章的结尾我为大家分享下keil&amp;mdk的安装包软件keil&amp;mdk安装包链接：https://pan.baidu.com/s/1IPHFC7OMV42ard_GX4LL0w提取码：rrki如果链接失效，请留言进行补充(小白的第一篇博客，不喜勿喷，若有不足之处，还望多多指出,谢谢！) 喜欢就常来看看呗，武汉加油，中国加油噢","categories":[{"name":"单片机","slug":"单片机","permalink":"http://yoursite.com/categories/%E5%8D%95%E7%89%87%E6%9C%BA/"}],"tags":[]}],"categories":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"http://yoursite.com/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"},{"name":"c与c++","slug":"c与c","permalink":"http://yoursite.com/categories/c%E4%B8%8Ec/"},{"name":"单片机","slug":"单片机","permalink":"http://yoursite.com/categories/%E5%8D%95%E7%89%87%E6%9C%BA/"}],"tags":[]}