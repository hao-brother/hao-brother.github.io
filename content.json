{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2020-03-28T12:50:44.000Z","updated":"2020-03-29T03:25:06.161Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"search","date":"2020-03-28T12:55:50.000Z","updated":"2020-03-28T12:56:19.471Z","comments":true,"path":"search/index.html","permalink":"http://yoursite.com/search/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-03-28T12:52:27.000Z","updated":"2020-03-29T03:27:15.002Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Untitled","slug":"Untitled","date":"2020-03-29T12:37:08.353Z","updated":"2020-03-29T12:37:08.353Z","comments":true,"path":"2020/03/29/Untitled/","link":"","permalink":"http://yoursite.com/2020/03/29/Untitled/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"c与c++知识点(一)","slug":"C与C++笔记1","date":"2020-03-02T04:49:16.000Z","updated":"2020-03-29T13:12:51.877Z","comments":true,"path":"2020/03/02/C与C++笔记1/","link":"","permalink":"http://yoursite.com/2020/03/02/C%E4%B8%8EC++%E7%AC%94%E8%AE%B01/","excerpt":"","text":"这是我自己在学习c++基础的过程中，顺便复习了下C语言，然后总结的一些小小知识点。—写在前面的话第一节1.int a; sizeof(int) = sizeof(a); —求所储存的字节2.float aa = ‘A’ cout &lt;&lt; (int)aa &lt;&lt; endl; 输出A的数值(强制转化为 int) 注意格式3.float f2 = 3e2 //310^2 float f3 = 3e-2 //30.1^24.bool 真或假 bool flag = false/true(0/1); —除了0为假，其余都为真5.字符串&nbsp;&nbsp;(1) char str[ ] = “hello world” cout&lt;&lt;str&lt;&lt;endl;&nbsp;&nbsp;(2) string 变量名 =”字符串值” （引用头文件include“string” 有的是在iostream头文件中）string name[3] = {“张三”,”李四”,”王麻子”}; string name=”胖虎”； 第二节1.int a1 = 10; ++a110(运算结果为110)先加1后乘以10，a1++10(100)先乘以10 后加1，先执行表达式，再增加。2.-= /= %= int a=10; int b=5; cout&lt;&lt;(a==b); 输出结果为0(假)3.rand() % 80, 生成0-79的随机数 rand() % 80+1 , 生成0-80随机数需要包含头文件 #include “cstdlib” #include ”ctime“ (伪函数) srand((unsigned int)time(NULL)); 利用系统时钟生成伪数字4.int a = 10; int b = 20; (a&lt;b?a:b)=100; cout &lt;&lt;a; a=100 cout&lt;&lt;b; b=205.int a = 354; 个位 a%10 十位 a%100/10 百位 a/100 第三节1. \\t 制表符代替空格2. goto flag ； flag： 跳转语句 —读懂就可，不建议使用3. 数组 int arr[5] = {1,2,3,4,5} 每个数组占用的内存空间sizeof(arr), 每个 元素占用的内存空间 sizeof(arr[0]), 数组中元素个数为 sizeof(arr) / sizeof(arr[0]) ——重点4. 数组地址 int arr[5] = {1,2,3,4,5} 数组首整型地址cout&lt;&lt; (int)arr; 第一个元素整型地址 cout&lt;&lt;(int)&amp;arr[0];——重点5.冒泡排序法void fun(int c[], int d){| int temp=0;| for (int a = 0; a &lt; d - 1; a++)| {| | for (int b = 0; b &lt; d - 1 - a; b++)| | {| | | if (c[b] &lt;c[b + 1])| | | {| | | | temp = c[b];| | | | c[b] = c[b + 1];| | | | c[b + 1] = temp;| | | }| | }| }} 未完待续…","categories":[{"name":"c与c++","slug":"c与c","permalink":"http://yoursite.com/categories/c%E4%B8%8Ec/"}],"tags":[]},{"title":"c与c++知识点(二)","slug":"C与C++笔记2","date":"2020-03-02T04:49:16.000Z","updated":"2020-03-29T13:31:08.921Z","comments":true,"path":"2020/03/02/C与C++笔记2/","link":"","permalink":"http://yoursite.com/2020/03/02/C%E4%B8%8EC++%E7%AC%94%E8%AE%B02/","excerpt":"","text":"这是我自己在学习c++基础的过程中，顺便复习了下C语言，然后总结的一些小小知识点。—写在前面的话第一节1. 二维数组 总元素 sizeof ( arr ) 第一行元素 sizeof ( arr [0] ) 行数: sizeof ( arr ) / sizeof ( arr [0] ) 列数: sizeof ( arr [0]) / sizeof( arr [0] [0] ) ）2. 二维数组首地址 cout &lt;&lt; arr &lt;&lt; endl; 第一行首地址 cout &lt;&lt; arr [0] &lt;&lt; endl; 第一个元素首地址 cout &lt;&lt; &amp; arr [0] [0] &lt;&lt; endl; 三者相等 第二行首地址 cout &lt;&lt; arr[1] &lt;&lt; endl;3. 指针就是地址 int *p; （p为指针变量） 使用时需要解引用 *p 即可 ( *p解引用）4. 空指针 ：用来给指针变量进行初始化，空指针不可以进行访问的 Int *p = NULL; 不可再将地址赋值给 p 输出5. const修饰指针 —重点1）const修饰指针—常量指针2）const修饰常量—指针常量3）const既修饰指针又修饰常量 第二节1. —重点1）常量指针 const int * p = &a; 指针的指向可以修改，但是指针指向 的值不可修改2）指针常量 int * const p = &a; 指针的指向不可以修改，指针的值可以修改3）既修饰指针又修饰常量 const int * const p = &a; 指针的指向和指针的值都不可以修改（如何记忆: const—常量 ，* p —指针 如何用：紧接着 const 的是p / * 紧跟着谁 谁不能操作）2. int arr [10], int * p; p = arr ; cout &lt;&lt; *p;（数组的名称为其的首地址)3. 值传递，不能修改实参的值，只能修改形参的值。地址传递可以修改实参的值。4. 结构体struct student/***自己创建的结构体类型为 student, 此类型的变量名字为s1, s2*** ***/ { string name; int age; int score; }; //1 struct student s1; //2 struct student s2 = { }; //3 创建结构体时顺便创建结构体变量,通过.来访问结构体中的属性 5.结构体创建自定义类型过程中struct不能省略，但是创建变量的过程c++ struct可以省略 第三节1.结构体数组 struct 结构体名字 数组名字{个数}={ { }，{ } ，{ } }结构体指针 利用-&gt;可以通过结构体来访问结构体的属性 student s1 = { “李斯”,56,99 }; student * p = &s1; cout &lt;&lt; “姓名:” &lt;&lt; p-&gt;name &lt;&lt; “年龄:” &lt;&lt; p-&gt;age &lt;&lt; “分数” &lt;&lt; p-&gt;score; 2.结构体嵌套结构体struct student { string name; int scroe; }; struct teacher { int id; string name; int age; struct student s1;//学生 s1 }; teacher t; t.id = 10086; t.name = “老王”; t.age = 58; t.s1. name = “小王”; t.s1.scroe = 99; teacher * p = &t; cout &lt;&lt; “老师姓名：” &lt;&lt; p-&gt;name ​ &lt;&lt; “老师工号: “ &lt;&lt; p-&gt;id ​ &lt;&lt; “老师年龄: “ &lt;&lt; p-&gt;age ​ &lt;&lt; “老师的学生名字: “ &lt;&lt; p-&gt;s1.name ​ &lt;&lt; “老师的学生分数: “ &lt;&lt; p-&gt;s1.scroe; 3. 结构体中使用const来防止误操作4. Main里面调用函数，形参相当于把参数复制了一遍，增大了储存空间和代码量。将函数的形参变为指针，可以大大减少内存的占用（指针不会复制数据，其只是进行地址传递）—重点5.system( “ pause ” ); 请按任意键继续system( “ cls ” ); 清屏操作 未完待续…","categories":[{"name":"c与c++","slug":"c与c","permalink":"http://yoursite.com/categories/c%E4%B8%8Ec/"}],"tags":[]},{"title":"c与c++知识点(三)","slug":"C与C++笔记3","date":"2020-03-02T04:49:16.000Z","updated":"2020-03-29T13:26:38.017Z","comments":true,"path":"2020/03/02/C与C++笔记3/","link":"","permalink":"http://yoursite.com/2020/03/02/C%E4%B8%8EC++%E7%AC%94%E8%AE%B03/","excerpt":"","text":"这是我自己在学习c++基础的过程中，顺便复习了下C语言，然后总结的一些小小知识点。—写在前面的话第一节1. C++内存分为四个区 代码区 存放函数体的二进制代码 全局区 存放全局变量和静态变量以及常量 栈区 编译器自动分配 存放函数参数值 局部变量 堆区 程序员分配和释放，程序员不释放，程序结束时操作系统回收 意义：不同区域存放的数据，赋予不同的生命中秋，给予更大的灵活编程 2. 代码区 （程序运行前就有）存放二进制机器指令 特点 : 共享、只读3. 全局区 （程序运行前就有）存放全局变量和静态变量以及常量 该区的数据在程序结束后由操作系统释放在全局区（静态变量 static关键字 常量（字符串常量和const 修饰的全局变量））不在全局区的数据（局部常量）4. 栈区（程序运行后才有）不要返回局部变量的地址5. 堆区 (程序运行后才有）(程序员手动开辟和释放（delete））利用new关键字，将数据开辟到堆区 返回的直接是地址, int * p = new int (10) ; 指针本质在栈区，其数据在堆区 第二节1.new 返回的是该数据类型的指针 int * p=new int(10) ; 创建了一个new型为10的变量地址 (释放 delete p;)int * array = nem int[10]; 创建了一个变量为整型个数为10的数组，他的首地址给了array (释放数组 delete[] arr;)2. 引用: 就是给变量起别名语法：数据类型 &amp;别名=原名 对别名进行操作等于对原名的数据进行操作 int a=10; Int &amp; b = a; b = 20; 那么 a也为20 3.引用的注意事项1) 引用的时候必须要给予初始化 int &amp; b = a; (引用过程给予初始化，只有这一种写法)2) 引用一旦初始化后，不可更改4. 引用也会使得形参修饰实参 void my3(int &amp;a,int &amp;b) 有两种解决办法 指针 和 引用注意事项:1 )不要返回局部变量的引用int &amp;test(){int a=10;return a;}2 )函数的调用可以作为左值 int &amp;ref=test();test()=100;cout &lt;&lt; ref &lt;&lt; endl; ref = 100; 5.引用的本质是一个指针常量 int a=10; Int &amp;b = a;相当于 int * const b = &a; 这也就是为什么引用不可修改，因为指针常量的指针指向不可修改(b中保存着a的地址)。cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl; a = b = 10; b = 20解引用 也就是*b = 20; 第三节1.常量引用引用的两种写法1 ) int a=10；int &amp; b = a(必须为名称，不能为10);2). const int &amp; b = 10; 第二种相当于编译器系统设置了一个变量int temp = 10；const int &amp;b = temp;b = 20(这是错误的，因为加上const 之后变为只读不可修改状态) 2.函数默认参数 优先用户自定义的 int fun(int a,int b=10,int c=30){ return a+b+c;}main{ cout &lt;&lt; fun (10 , 30 , 30 ) ; } 70; 当某个位置有了默认参数，那么他后边都必须是默认参数(例如 b为默认参数，那么 c 也必须是默认参数) 3. 声明和实现 只能有一个有默认参数 int fun (int a = 10,int b = 30); int fun(int a , int b) {return a + b;} 404. 占位参数（只有函数类型，没有名字） void fun ( int a , int){cout &lt;&lt; ” abc ” ; } 引用时fun(10 , 10) 占位参数还可以有默认参数void fun(int a , int = 10) {return “ abc ” ; } 引用时 fun( 10 ) ;5. 函数重载(函数名可以相同)条件 : 同一个作用域下 函数名称相同 函数的参数类型不同 或者 个数不同或者顺序不同注意：函数的返回值不可以作为函数重载的条件 void fun ( ) void fun(int a) void fun(double b) 未完待续…","categories":[{"name":"c与c++","slug":"c与c","permalink":"http://yoursite.com/categories/c%E4%B8%8Ec/"}],"tags":[]},{"title":"MDK、KEIL的兼容与破解","slug":"MDK、KEIL的兼容与破解","date":"2020-03-02T04:49:16.000Z","updated":"2020-03-29T08:56:45.029Z","comments":true,"path":"2020/03/02/MDK、KEIL的兼容与破解/","link":"","permalink":"http://yoursite.com/2020/03/02/MDK%E3%80%81KEIL%E7%9A%84%E5%85%BC%E5%AE%B9%E4%B8%8E%E7%A0%B4%E8%A7%A3/","excerpt":"很多人可能有和我一样的经历，刚刚学完51单片机就转手来学32开发板，可面临的第一个很尴尬的问题就是KEIL和MDK不能同时兼容存在，自己想学32就要用到MDK,可又放不下刚刚捧热的”情人”keil”","text":"很多人可能有和我一样的经历，刚刚学完51单片机就转手来学32开发板，可面临的第一个很尴尬的问题就是KEIL和MDK不能同时兼容存在，自己想学32就要用到MDK,可又放不下刚刚捧热的”情人”keil” 第一章其实keil和mdk的共存是很简单的，话不多说，下文直接上硬菜(附keil&amp;mdk的安装包)先在d盘创建英文的文件夹(名件名为英文的是为了防止在后续的开发中出现莫名奇妙的警告错误信息)我创建的文件名称为 MDK5 然后打开我们mdk的安装包，按照顺序将程序安装到d盘MDK5的路径下(安装包文末会提供)（以32的f4包来举个栗子） 第二章请务必按如下顺序安装：安装MDK521A安装Keil.STM32F4xx_DFP（安装过程中需要输入的用户名字和Email可随意填写） 然后打开我们keil的安装包，将程序安装到d盘MDK5的路径下(安装包文末会提供)（两个安装包安装路径一定要相同） mdK和KEIL是安装在同一路径下，使用同一个桌面快捷方式，接下来教大家如何分别创建51和32新文件. 第三章双击打开我们的keil,Project -&gt;第一个New uVision Project当我们需要写32代码时，选择下面如图这个选项，然后选择相应的芯片来写代码。 当我们需要写51代码时，选择下面如图这个选项，然后在Atmel中选择stc89c52来写代码 在文章的结尾我为大家分享下keil&amp;mdk的安装包软件keil&amp;mdk安装包链接：https://pan.baidu.com/s/1IPHFC7OMV42ard_GX4LL0w提取码：rrki如果链接失效，请留言进行补充(小白的第一篇博客，不喜勿喷，若有不足之处，还望多多指出,谢谢！) 喜欢就常来看看呗，武汉加油，中国加油噢","categories":[{"name":"单片机","slug":"单片机","permalink":"http://yoursite.com/categories/%E5%8D%95%E7%89%87%E6%9C%BA/"}],"tags":[]}],"categories":[{"name":"c与c++","slug":"c与c","permalink":"http://yoursite.com/categories/c%E4%B8%8Ec/"},{"name":"单片机","slug":"单片机","permalink":"http://yoursite.com/categories/%E5%8D%95%E7%89%87%E6%9C%BA/"}],"tags":[]}